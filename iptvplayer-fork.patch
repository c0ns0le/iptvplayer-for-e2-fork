diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/configbase.py ./IPTVPlayer/components/configbase.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/configbase.py	2015-11-16 06:19:04.566308000 +0100
+++ ./IPTVPlayer/components/configbase.py	2015-11-25 06:44:14.474668001 +0100
@@ -8,10 +8,9 @@
 ###################################################
 # LOCAL import
 ###################################################
-from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc
-from Plugins.Extensions.IPTVPlayer.components.iptvdirbrowser import IPTVDirectorySelectorWidget
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, IsExecutable, GetBinDir
 ###################################################
-
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
 ###################################################
 # FOREIGN import
 ###################################################
@@ -30,28 +29,9 @@
 
 
 class ConfigBaseWidget(Screen, ConfigListScreen):
-    screenwidth = getDesktop(0).size().width()
-    if screenwidth and screenwidth == 1920:
-        skin = """
-            <screen name="IPTVConfigBaseWidget" position="center,center" size="920,860" title="" >
-                <widget name="config"    position="10,70" size="900,780" zPosition="1" transparent="1" scrollbarMode="showOnDemand" />
-                <widget name="key_red"   position="10,10" zPosition="2" size="600,35" valign="center" halign="left"   font="Regular;28" transparent="1" foregroundColor="red" />
-                <widget name="key_ok"    position="10,10" zPosition="2" size="600,35" valign="center" halign="center" font="Regular;28" transparent="1" foregroundColor="white" />
-                <widget name="key_green" position="10,10" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;28" transparent="1" foregroundColor="green" />
-                <widget name="key_blue"    position="0,0" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;28" transparent="1" foregroundColor="green" />
-                <widget name="key_yellow"  position="0,0" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;28" transparent="1" foregroundColor="green" />
-            </screen>"""
-    else:
-        skin = """
-            <screen name="IPTVConfigBaseWidget" position="center,center" size="620,440" title="" >
-                <widget name="config"    position="10,50" size="600,370" zPosition="1" transparent="1" scrollbarMode="showOnDemand" />
-                <widget name="key_red"   position="10,10" zPosition="2" size="600,35" valign="center" halign="left"   font="Regular;22" transparent="1" foregroundColor="red" />
-                <widget name="key_ok"    position="10,10" zPosition="2" size="600,35" valign="center" halign="center" font="Regular;22" transparent="1" foregroundColor="white" />
-                <widget name="key_green" position="10,10" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;22" transparent="1" foregroundColor="green" />
-                
-                <widget name="key_blue"    position="0,0" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;22" transparent="1" foregroundColor="green" />
-                <widget name="key_yellow"  position="0,0" zPosition="2" size="600,35" valign="center" halign="right"  font="Regular;22" transparent="1" foregroundColor="green" />
-            </screen>"""      
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import LoadSkin
+    skin=LoadSkin('ConfigBaseWidget')
+
     def __init__(self, session):
         printDBG("ConfigBaseWidget.__init__ -------------------------------")
         Screen.__init__(self, session)
@@ -220,6 +200,12 @@
         if isinstance(currItem, ConfigDirectory):
             def SetDirPathCallBack(curIndex, newPath):
                 if None != newPath: self["config"].list[curIndex][1].value = newPath
+            if IsExecutable(GetBinDir('lsdir')):
+                printDBG('lsdir found, starting iptv browser') 
+                from Plugins.Extensions.IPTVPlayer.components.iptvdirbrowser import IPTVDirectorySelectorWidget
+            else:
+                printDBG('No lsdir utility, starting generic browser') 
+                from Plugins.Extensions.IPTVPlayer.components.filebrowserwidget.py import DirectorySelectorWidget as IPTVDirectorySelectorWidget
             self.session.openWithCallback(boundFunction(SetDirPathCallBack, curIndex), IPTVDirectorySelectorWidget, currDir=currItem.value,  title=_('Select the directory'))
             return
         elif isinstance(currItem, ConfigText):
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/filebrowserwidget.py ./IPTVPlayer/components/filebrowserwidget.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/filebrowserwidget.py	2015-11-05 22:26:57.905660252 +0100
+++ ./IPTVPlayer/components/filebrowserwidget.py	2015-11-25 06:44:14.474668001 +0100
@@ -29,25 +29,9 @@
 ###################################################
  
 class DirectorySelectorWidget(Screen):
-    screenwidth = getDesktop(0).size().width()
-    if screenwidth and screenwidth == 1920:  
-        skin = """
-        <screen name="IPTVDirectorySelectorWidget" position="center,center" size="820,860" title="">
-            <widget name="key_red"     position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;28" transparent="1" foregroundColor="red" />
-            <widget name="key_blue"    position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="center" font="Regular;28" transparent="1" foregroundColor="blue" />
-            <widget name="key_green"   position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="right"  font="Regular;28" transparent="1" foregroundColor="green" />
-            <widget name="curr_dir"    position="10,50"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;28" transparent="1" foregroundColor="white" />
-            <widget name="filelist"    position="10,95"  zPosition="1"  size="800,725" transparent="1" scrollbarMode="showOnDemand" />
-        </screen>"""
-    else:
-        skin = """
-        <screen name="IPTVDirectorySelectorWidget" position="center,center" size="620,440" title="">
-            <widget name="key_red"     position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;22" transparent="1" foregroundColor="red" />
-            <widget name="key_blue"    position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="center" font="Regular;22" transparent="1" foregroundColor="blue" />
-            <widget name="key_green"   position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="right"  font="Regular;22" transparent="1" foregroundColor="green" />
-            <widget name="curr_dir"    position="10,50"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;18" transparent="1" foregroundColor="white" />
-            <widget name="filelist"    position="10,85"  zPosition="1"  size="580,335" transparent="1" scrollbarMode="showOnDemand" />
-        </screen>"""      
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import LoadSkin
+    skin=LoadSkin('DirectorySelectorWidget')
+    
     def __init__(self, session, currDir, title="Directory browser"):
         printDBG("DirectorySelectorWidget.__init__ -------------------------------")
         Screen.__init__(self, session)
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvchoicebox.py ./IPTVPlayer/components/iptvchoicebox.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvchoicebox.py	2015-11-11 07:16:27.391282027 +0100
+++ ./IPTVPlayer/components/iptvchoicebox.py	2015-11-25 06:44:14.474668001 +0100
@@ -11,7 +11,7 @@
 from Plugins.Extensions.IPTVPlayer.components.iptvmultipleinputbox import IPTVMultipleInputBox
 from Plugins.Extensions.IPTVPlayer.components.iptvlist import IPTVRadioButtonList
 ###################################################
-
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
 ###################################################
 # FOREIGN import
 ###################################################
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvconfigmenu.py ./IPTVPlayer/components/iptvconfigmenu.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvconfigmenu.py	2015-11-19 06:26:29.092565999 +0100
+++ ./IPTVPlayer/components/iptvconfigmenu.py	2015-11-25 06:44:14.478666000 +0100
@@ -7,12 +7,11 @@
 ###################################################
 # LOCAL import
 ###################################################
-from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, GetSkinsList, GetHostsList, IsHostEnabled, IsExecutable, CFakeMoviePlayerOption, GetAvailableIconSize
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, GetSkinsList, GetHostsList, IsHostEnabled, IsExecutable, GetBinDir, CFakeMoviePlayerOption, GetAvailableIconSize
 from Plugins.Extensions.IPTVPlayer.iptvupdate.updatemainwindow import IPTVUpdateWindow, UpdateMainAppImpl
 from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, IPTVPlayerNeedInit
 from Plugins.Extensions.IPTVPlayer.components.configbase import ConfigBaseWidget
 from Plugins.Extensions.IPTVPlayer.components.confighost import ConfigHostsMenu
-from Plugins.Extensions.IPTVPlayer.components.iptvdirbrowser import IPTVDirectorySelectorWidget
 from Plugins.Extensions.IPTVPlayer.setup.iptvsetupwidget import IPTVSetupMainWidget
 ###################################################
 
@@ -46,7 +45,7 @@
 config.plugins.iptvplayer.uchardetpath    = ConfigText(default = "", fixed_size = False)
 config.plugins.iptvplayer.set_curr_title  = ConfigYesNo(default = False)
 config.plugins.iptvplayer.curr_title_file = ConfigText(default = "", fixed_size = False) 
-config.plugins.iptvplayer.plarform        = ConfigSelection(default = "auto", choices = [("auto", "auto"),("mipsel", _("mipsel")),("sh4", _("sh4")),("i686", _("i686")),("unknown", _("unknown"))])
+config.plugins.iptvplayer.plarform        = ConfigSelection(default = "auto", choices = [("auto", "auto"),("mipsel", _("mipsel")),("sh4", _("sh4")),("i686", _("i686")),("arm", _("arm")),("unknown", _("unsupported"))])
 
 config.plugins.iptvplayer.showcover          = ConfigYesNo(default = True)
 config.plugins.iptvplayer.deleteIcons        = ConfigSelection(default = "3", choices = [("0", _("after closing")),("1", _("after day")),("3", _("after three days")),("7", _("after a week"))]) 
@@ -72,13 +71,13 @@
 
 
 def GetMoviePlayerName(player):
-    map = {"auto":_("auto"), "mini": _("internal"), "standard":_("standard"), 'exteplayer': _("external eplayer3"), 'extgstplayer': _("external gstplayer")}
+    map = {"auto":_("auto"), "mini": _("internal"), "standard":_("standard"), "afp":_("Advanced Free Player"), 'exteplayer': _("external eplayer3"), 'extgstplayer': _("external gstplayer")}
     return map.get(player, _('unknown'))
     
 def ConfigPlayer(player):
     return (player, GetMoviePlayerName(player))
 
-config.plugins.iptvplayer.NaszPlayer = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"), ConfigPlayer("mini"), ConfigPlayer('extgstplayer'), ConfigPlayer("standard")])
+config.plugins.iptvplayer.NaszPlayer = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"), ConfigPlayer("mini"), ConfigPlayer("afp"), ConfigPlayer('extgstplayer'), ConfigPlayer("standard")])
 
 # without buffering mode
 #sh4
@@ -92,6 +91,10 @@
 #i686
 config.plugins.iptvplayer.defaultI686MoviePlayer0        = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
 config.plugins.iptvplayer.alternativeI686MoviePlayer0    = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
+
+#arm
+config.plugins.iptvplayer.defaultARMMoviePlayer0        = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
+config.plugins.iptvplayer.alternativeARMMoviePlayer0    = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
 # end without buffering mode players
 
 
@@ -107,6 +110,10 @@
 #i686
 config.plugins.iptvplayer.defaultI686MoviePlayer        = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
 config.plugins.iptvplayer.alternativeI686MoviePlayer    = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
+
+#i686
+config.plugins.iptvplayer.defaultARMMoviePlayer        = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
+config.plugins.iptvplayer.alternativeARMMoviePlayer    = ConfigSelection(default = "auto", choices = [ConfigPlayer("auto"),ConfigPlayer("mini"),ConfigPlayer("standard"),ConfigPlayer('extgstplayer')])
 # end with buffering mode players
 
 config.plugins.iptvplayer.SciezkaCache = ConfigDirectory(default = "/hdd/IPTVCache/") #, fixed_size = False)
@@ -164,7 +171,9 @@
 config.plugins.iptvplayer.search_history_size  = ConfigInteger(50, (0, 1000000))
 
 ###################################################
-
+j00zekFork=True
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import AlternateOptionsList, ExtendConfigsList, RemoveDuplicatesFromList
+ExtendConfigsList()
 ########################################################
 # Generate list of hosts options for Enabling/Disabling
 ########################################################
@@ -207,6 +216,8 @@
         
     @staticmethod
     def fillConfigList(list, hiddenOptions=False):
+        if 'j00zekFork' in globals():
+            AlternateOptionsList(list)
         if hiddenOptions:
             list.append( getConfigListEntry(_("Last checked version"), config.plugins.iptvplayer.updateLastCheckedVersion) )
             list.append( getConfigListEntry(_("Show all version in the update menu"), config.plugins.iptvplayer.hiddenAllVersionInUpdate) )
@@ -308,6 +319,17 @@
             list.append(getConfigListEntry(_("Second move player in buffering mode"), config.plugins.iptvplayer.alternativeI686MoviePlayer))
             players.append(config.plugins.iptvplayer.alternativeI686MoviePlayer)
             
+        elif 'arm' == config.plugins.iptvplayer.plarform.value:
+            list.append(getConfigListEntry(_("First move player without buffering mode"), config.plugins.iptvplayer.defaultARMMoviePlayer0))
+            players.append(config.plugins.iptvplayer.defaultARMMoviePlayer0)
+            list.append(getConfigListEntry(_("Second move player without buffering mode"), config.plugins.iptvplayer.alternativeARMMoviePlayer0))
+            players.append(config.plugins.iptvplayer.alternativeARMMoviePlayer0)
+            
+            list.append(getConfigListEntry(_("First move player in buffering mode"), config.plugins.iptvplayer.defaultARMMoviePlayer))
+            players.append(config.plugins.iptvplayer.defaultARMMoviePlayer)
+            list.append(getConfigListEntry(_("Second move player in buffering mode"), config.plugins.iptvplayer.alternativeARMMoviePlayer))
+            players.append(config.plugins.iptvplayer.alternativeARMMoviePlayer)
+            
         else: 
             list.append(getConfigListEntry(_("Movie player"), config.plugins.iptvplayer.NaszPlayer))
         
@@ -323,6 +345,8 @@
         list.append(getConfigListEntry(_("Debug logs"), config.plugins.iptvplayer.debugprint))
         list.append(getConfigListEntry(_("Allow downgrade"), config.plugins.iptvplayer.downgradePossible))
         list.append(getConfigListEntry(_("Update packet type"), config.plugins.iptvplayer.possibleUpdateType))
+        if 'j00zekFork' in globals():
+            RemoveDuplicatesFromList(list)
 
     def runSetup(self):
         self.list = []
@@ -346,8 +370,12 @@
             self.doUpdate()
 
     def doUpdate(self):
-        printDBG("ConfigMenu.doUpdate")
-        self.session.open(IPTVUpdateWindow, UpdateMainAppImpl(self.session))
+        if 'j00zekFork' in globals():
+            from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import j00zekIPTVPlayerConsole, j00zekRunUpdateList
+            self.session.open(j00zekIPTVPlayerConsole, title = _("Updating plugin"), cmdlist = j00zekRunUpdateList)
+        else:
+            printDBG("ConfigMenu.doUpdate")
+            self.session.open(IPTVUpdateWindow, UpdateMainAppImpl(self.session))
         
 
     def save(self):
@@ -371,7 +399,12 @@
         if isinstance(currItem, ConfigDirectory):
             def SetDirPathCallBack(curIndex, newPath):
                 if None != newPath: self["config"].list[curIndex][1].value = newPath
-            self.session.openWithCallback(boundFunction(SetDirPathCallBack, curIndex), IPTVDirectorySelectorWidget, currDir=currItem.value, title="Wybierz katalog")
+            if IsExecutable(GetBinDir('lsdir')):
+                from Plugins.Extensions.IPTVPlayer.components.iptvdirbrowser import IPTVDirectorySelectorWidget
+                self.session.openWithCallback(boundFunction(SetDirPathCallBack, curIndex), IPTVDirectorySelectorWidget, currDir=currItem.value, title="Wybierz katalog")
+            else:
+                from Plugins.Extensions.IPTVPlayer.components.filebrowserwidget import DirectorySelectorWidget
+                self.session.openWithCallback(boundFunction(SetDirPathCallBack, curIndex), DirectorySelectorWidget, currDir=currItem.value, title="Wybierz katalog")
         elif config.plugins.iptvplayer.fakePin == currItem:
             self.changePin(start = True)
         elif config.plugins.iptvplayer.fakeUpdate == currItem:
@@ -409,6 +442,11 @@
             players.append(config.plugins.iptvplayer.alternativeI686MoviePlayer0)
             players.append(config.plugins.iptvplayer.defaultI686MoviePlayer)
             players.append(config.plugins.iptvplayer.alternativeI686MoviePlayer)
+        elif 'arm' == config.plugins.iptvplayer.plarform.value:
+            players.append(config.plugins.iptvplayer.defaultARMMoviePlayer0)
+            players.append(config.plugins.iptvplayer.alternativeARMMoviePlayer0)
+            players.append(config.plugins.iptvplayer.defaultARMMoviePlayer)
+            players.append(config.plugins.iptvplayer.alternativeARMMoviePlayer)
         else:
             players.append(config.plugins.iptvplayer.NaszPlayer)
         tab.extend(players)
@@ -487,6 +525,14 @@
         else:
             player = config.plugins.iptvplayer.defaultI686MoviePlayer0
             alternativePlayer = config.plugins.iptvplayer.alternativeI686MoviePlayer0
+            
+    elif 'arm' == config.plugins.iptvplayer.plarform.value:
+        if buffering:
+            player = config.plugins.iptvplayer.defaultARMMoviePlayer
+            alternativePlayer = config.plugins.iptvplayer.alternativeARMMoviePlayer
+        else:
+            player = config.plugins.iptvplayer.defaultARMMoviePlayer0
+            alternativePlayer = config.plugins.iptvplayer.alternativeARMMoviePlayer0
     else:
         player = config.plugins.iptvplayer.NaszPlayer
         alternativePlayer = config.plugins.iptvplayer.NaszPlayer
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvdirbrowser.py ./IPTVPlayer/components/iptvdirbrowser.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvdirbrowser.py	2015-11-11 07:16:27.391282027 +0100
+++ ./IPTVPlayer/components/iptvdirbrowser.py	2015-11-25 06:44:14.478666000 +0100
@@ -41,25 +41,8 @@
         IPTVMainNavigatorList.__init__(self)
 
 class IPTVDirectorySelectorWidget(Screen):
-    screenwidth = getDesktop(0).size().width()
-    if screenwidth and screenwidth == 1920:  
-        skin = """
-        <screen name="IPTVDirectorySelectorWidget" position="center,center" size="820,860" title="">
-            <widget name="key_red"     position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;28" transparent="1" foregroundColor="red" />
-            <widget name="key_green"   position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="center"  font="Regular;28" transparent="1" foregroundColor="green" />
-            <widget name="key_blue"    position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="right" font="Regular;28" transparent="1" foregroundColor="blue" />
-            <widget name="curr_dir"    position="10,50"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;28" transparent="1" foregroundColor="white" />
-            <widget name="list"        position="10,95"  zPosition="1"  size="800,725" transparent="1" scrollbarMode="showOnDemand" />
-        </screen>"""
-    else:
-        skin = """
-        <screen name="IPTVDirectorySelectorWidget" position="center,center" size="620,440" title="">
-            <widget name="key_red"     position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;22" transparent="1" foregroundColor="red" />
-            <widget name="key_green"   position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="center"  font="Regular;22" transparent="1" foregroundColor="green" />
-            <widget name="key_blue"    position="10,10"  zPosition="2"  size="600,35" valign="center"  halign="right" font="Regular;22" transparent="1" foregroundColor="blue" />
-            <widget name="curr_dir"    position="10,50"  zPosition="2"  size="600,35" valign="center"  halign="left"   font="Regular;18" transparent="1" foregroundColor="white" />
-            <widget name="list"        position="10,85"  zPosition="1"  size="580,335" transparent="1" scrollbarMode="showOnDemand" />
-        </screen>"""
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import LoadSkin
+    skin=LoadSkin('IPTVDirectorySelectorWidget')
         
     def __init__(self, session, currDir, title="Directory browser"):
         printDBG("IPTVDirectorySelectorWidget.__init__ -------------------------------")
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvfavouriteswidgets.py ./IPTVPlayer/components/iptvfavouriteswidgets.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvfavouriteswidgets.py	2015-11-05 22:26:57.905660252 +0100
+++ ./IPTVPlayer/components/iptvfavouriteswidgets.py	2015-11-25 06:44:14.478666000 +0100
@@ -133,30 +133,8 @@
         self.close(self.result)
 
 class IPTVFavouritesMainWidget(Screen):
-    sz_w = getDesktop(0).size().width() - 190
-    sz_h = getDesktop(0).size().height() - 195
-    if sz_h < 500: sz_h += 4
-    skin = """
-        <screen name="IPTVFavouritesMainWidget" position="center,center" title="%s" size="%d,%d">
-         <ePixmap position="5,9"   zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         <ePixmap position="180,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         <ePixmap position="355,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         
-         <widget name="label_red"     position="45,9"  size="175,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-         <widget name="label_yellow"  position="220,9" size="175,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-         <widget name="label_green"   position="395,9" size="175,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-         
-         <widget name="list"  position="5,80"  zPosition="2" size="%d,%d" scrollbarMode="showOnDemand" transparent="1"  backgroundColor="#00000000" />
-         <widget name="title" position="5,47"  zPosition="1" size="%d,23" font="Regular;20"            transparent="1"  backgroundColor="#00000000"/>
-        </screen>""" %(
-            _("Favourites manager"),
-            sz_w, sz_h, # size
-            GetIconDir("red.png"),
-            GetIconDir("yellow.png"),
-            GetIconDir("green.png"),
-            sz_w - 10, sz_h - 105, # size list
-            sz_w - 135, # size title
-            )
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import LoadSkin
+    skin=LoadSkin('IPTVFavouritesMainWidget')
             
     def __init__(self, session):
         self.session = session
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvpin.py ./IPTVPlayer/components/iptvpin.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvpin.py	2015-11-05 22:26:57.905660252 +0100
+++ ./IPTVPlayer/components/iptvpin.py	2015-11-25 06:44:14.482664000 +0100
@@ -22,15 +22,8 @@
 
 class IPTVPinWidget(Screen):
     PIN_LEN = 4
-    skin = """
-        <screen name="IPTVPinWidget" position="center,center" title="IPTV Player" size="300,260">
-         <widget name="titel" position="5,5" zPosition="1" size="290,40" font="Regular;24" transparent="1" halign="center" valign="center" backgroundColor="black"/>
-         <widget name="cover_0" zPosition="4" position="5,80" size="60,60" transparent="1" alphatest="on" />
-         <widget name="cover_1" zPosition="4" position="75,80" size="60,60" transparent="1" alphatest="on" />
-         <widget name="cover_2" zPosition="4" position="145,80" size="60,60" transparent="1" alphatest="on" />
-         <widget name="cover_3" zPosition="4" position="215,80" size="60,60" transparent="1" alphatest="on" />
-         <ePixmap position="100,150" zPosition="4" size="100,100" pixmap="/usr/lib/enigma2/python/Plugins/Extensions/IPTVPlayer/icons/Pin/lock.png" transparent="1" alphatest="on" />
-        </screen>"""
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
+    skin = LoadSkin("IPTVPinWidget")
    
     def __init__(self, session, title = ""):
         self.session = session
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvplayerwidget.py ./IPTVPlayer/components/iptvplayerwidget.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/iptvplayerwidget.py	2015-11-16 06:19:04.570306000 +0100
+++ ./IPTVPlayer/components/iptvplayerwidget.py	2015-11-26 13:17:34.078595847 +0100
@@ -11,6 +11,10 @@
 from urllib import quote as urllib_quote
 
 ####################################################
+#                  j00zek E2
+####################################################
+j00zekFork=True
+####################################################
 #                   E2 components
 ####################################################
 from Screens.Screen import Screen
@@ -69,59 +73,26 @@
 
 class IPTVPlayerWidget(Screen):
     IPTV_VERSION = GetIPTVPlayerVerstion()
-    screenwidth = getDesktop(0).size().width()
-    if screenwidth and screenwidth == 1920:
-        skin =  """
-                    <screen name="IPTVPlayerWidget" position="center,center" size="1590,825" title="IPTV Player HD wersja %s">
-                            <ePixmap position="5,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="180,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="385,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="700,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <widget render="Label" source="key_red" position="45,9" size="140,32" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;32" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_yellow" position="220,9" size="180,32" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;32" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_green" position="425,9" size="300,32" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;32" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_blue" position="740,9" size="140,32" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;32" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget name="headertext" position="15,55" zPosition="1" size="1080,30" font="Regular;30" transparent="1" backgroundColor="#00000000" />
-                            <widget name="statustext" position="15,148" zPosition="1" size="985,90" font="Regular;30" halign="center" valign="center" transparent="1" backgroundColor="#00000000" />
-                            <widget name="list" position="5,115" zPosition="2" size="860,690" scrollbarMode="showOnDemand" transparent="1" backgroundColor="#00000000" />
-                            <widget name="console" position="1020,310" zPosition="1" size="500,630" font="Regular;26" transparent="1" backgroundColor="#00000000" />
-                            <widget name="cover" zPosition="2" position="1020,80" size="244,280" alphatest="blend" />     
-                            <widget name="playerlogo" zPosition="4" position="1264,3" size="240,80" alphatest="blend" />
-                            <widget name="sequencer" position="0,0" zPosition="6" size="1090,625" font="Regular;160" halign="center" valign="center" transparent="1" backgroundColor="#00000000" />
-                            <widget name="spinner"   zPosition="2" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_1" zPosition="1" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_2" zPosition="1" position="479,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_3" zPosition="1" position="495,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_4" zPosition="1" position="511,200" size="16,16" transparent="1" alphatest="blend" />
-                    </screen>
-                """ %( IPTV_VERSION, GetIconDir('red.png'), GetIconDir('yellow.png'), GetIconDir('green.png'), GetIconDir('blue.png'))
-    else:
-        skin =  """
-                    <screen name="IPTVPlayerWidget" position="center,center" size="1090,525" title="IPTV Player wersja %s">
-                            <ePixmap position="30,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="287,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="554,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <ePixmap position="801,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-                            <widget render="Label" source="key_red"    position="65,9"  size="210,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_green"  position="322,9" size="210,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_yellow" position="589,9" size="210,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget render="Label" source="key_blue"   position="836,9" size="210,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-                            <widget name="headertext" position="5,47" zPosition="1" size="1080,23" font="Regular;20" transparent="1" backgroundColor="#00000000" />
-                            <widget name="statustext" position="5,140" zPosition="1" size="985,90" font="Regular;20" halign="center" valign="center" transparent="1" backgroundColor="#00000000" />
-                            <widget name="list" position="5,100" zPosition="2" size="1080,280" scrollbarMode="showOnDemand" transparent="1" backgroundColor="#00000000" />
-                            <widget name="console" position="165,430" zPosition="1" size="935,140" font="Regular;20" transparent="1" backgroundColor="#00000000" />
-                            <widget name="cover" zPosition="2" position="5,400" size="122,140" alphatest="blend" />     
-                            <widget name="playerlogo" zPosition="4" position="964,3" size="120,40" alphatest="blend" />
-                            <ePixmap zPosition="4" position="5,395" size="1080,5" pixmap="%s" transparent="1" />
-                            <widget name="sequencer" position="0,0" zPosition="6" size="1090,525" font="Regular;160" halign="center" valign="center" transparent="1" backgroundColor="#00000000" />
-                            
-                            <widget name="spinner"   zPosition="2" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_1" zPosition="1" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_2" zPosition="1" position="479,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_3" zPosition="1" position="495,200" size="16,16" transparent="1" alphatest="blend" />
-                            <widget name="spinner_4" zPosition="1" position="511,200" size="16,16" transparent="1" alphatest="blend" />
-                    </screen>
-                """ %( IPTV_VERSION, GetIconDir('red.png'), GetIconDir('green.png'), GetIconDir('yellow.png'), GetIconDir('blue.png'), GetIconDir('line.png'))      
+    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import LoadSkin
+    skin=LoadSkin('IPTVPlayerWidget')
+    currHostsCategory = ''
+    def j00zekSelectHostCategory(self):
+        def CB(ret):
+            if ret:
+                if ret[1] == 'ClosePlugin':
+                    self.selectHostCallback2('noupdate')
+                else:
+                    self.currHostsCategory=ret[1]
+            else:
+                self.currHostsCategory=''
+            self.selectHost()
+        HostsCategories=[]
+        from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import GetHostsCategories
+        HostsCategories=GetHostsCategories()
+        HostsCategories.append((_("all"),''))
+        #HostsCategories.append((_("Exit"),'ClosePlugin'))
+        self.session.openWithCallback(CB, ChoiceBox, title=_("Select Category"), list = HostsCategories)
+    
     def __init__(self, session):
         printDBG("IPTVPlayerWidget.__init__ desktop IPTV_VERSION[%s]\n" % (IPTVPlayerWidget.IPTV_VERSION) )
         self.session = session
@@ -318,7 +289,7 @@
         try:
             asynccall.gMainFunctionsQueue.setProcFun(None)
             asynccall.gMainFunctionsQueue.clearQueue()
-            iptv_system('echo 1 > /proc/sys/vm/drop_caches')
+            ClearMemory()
         except:
             printExc()
         self.activePlayer = None
@@ -876,14 +847,21 @@
         #self.onLayoutFinish.remove(self.onStart)
         self.loadSpinner()
         self.hideSpinner()
-        self.askUpdateAvailable(self.selectHost)
+        if 'j00zekFork' in globals() and config.plugins.iptvplayer.j00zekTreeHostsSelector.value == True:
+            self.currHostsCategory = self.askUpdateAvailable(self.j00zekSelectHostCategory)
+        else:
+            self.askUpdateAvailable(self.selectHost)
     
     def __requestCheckUpdate(self):
-        lastVerUrl = 'http://iptvplayer.pl/download/update/lastversion.php'
         if config.plugins.iptvplayer.autoCheckForUpdate.value:
             self.checkUpdateTimer.start(self.checkUpdateTimer_interval, True)
             if IsExecutable( DMHelper.GET_WGET_PATH() ):
-                cmd = '%s "%s" -O - 2> /dev/null ' % (DMHelper.GET_WGET_PATH(), lastVerUrl)
+                if 'j00zekFork' in globals():
+                    lastVerUrl = 'https://raw.githubusercontent.com/j00zek/iptvplayer-for-e2-fork/master/IPTVPlayer/version.py'
+                    cmd = '%s -q "%s" -O -|grep IPTV_VERSION|grep -o "[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]" 2> /dev/null ' % (DMHelper.GET_WGET_PATH(), lastVerUrl)
+                else:
+                    lastVerUrl = 'http://iptvplayer.pl/download/update/lastversion.php'
+                    cmd = '%s "%s" -O - 2> /dev/null ' % (DMHelper.GET_WGET_PATH(), lastVerUrl)
                 if None != self.checkUpdateConsole: self.checkUpdateConsole.terminate()
                 printDBG("__requestCheckUpdate cmd[%r]" % cmd)
                 self.checkUpdateConsole = iptv_system( cmd, self.__checkUpdateCmdFinished )
@@ -896,7 +874,7 @@
     def askUpdateAvailable(self, NoUpdateCallback):
         if  config.plugins.iptvplayer.autoCheckForUpdate.value \
             and  0 < GetVersionNum( self.lastPluginVersion ) \
-            and GetVersionNum( self.lastPluginVersion ) > GetVersionNum( GetIPTVPlayerVerstion() ) \
+            and GetVersionNum( self.lastPluginVersion ) > GetVersionNum( GetIPTVPlayerVerstion().replace('j','') ) \
             and self.lastPluginVersion != config.plugins.iptvplayer.updateLastCheckedVersion.value:
             
             message = _('There is a new version available do you want to update? \nYour version [%s], latest version on server [%s]') % (GetIPTVPlayerVerstion(), self.lastPluginVersion)
@@ -922,8 +900,8 @@
         self.currList = []
         self.currItem = CDisplayListItem()
 
-        self.displayHostsList = [] 
-        sortedList = SortHostsList( GetHostsList() )
+        self.displayHostsList = []
+        sortedList = SortHostsList( GetHostsList(self.currHostsCategory) )
         brokenHostList = []
         for hostName in sortedList:
             hostEnabled  = False
@@ -980,10 +958,8 @@
     def selectHostCallback(self, ret):
         try:
             if os_path.isfile('/etc/init.d/graterlia_init'):
-                message = "Ostrzężenie (faza 1/3)\n"
-                message += "Używając IPTVPlayer na tej dystrybucji systemu E2 łamiesz licencje.\n\n"
-                message += "WARNING (phase 1/3)\n"
-                message += "You are breaking license using IPTVPlayer on your E2 distribution.\n\n"
+                message = _("WARNING (phase 1/3)\n")
+                message += _("You are breaking license using IPTVPlayer on your E2 distribution.\n\n")
                 #self.session.openWithCallback(self.close, MessageBox, text=message, type=MessageBox.TYPE_ERROR)
                 self.session.open(MessageBox, text=message, type=MessageBox.TYPE_ERROR)
         except:
@@ -1007,7 +983,11 @@
                 self.close()
                 return
             elif ret[1] == "update":
-                self.session.openWithCallback(self.displayListOfHosts, IPTVUpdateWindow, UpdateMainAppImpl(self.session))
+                if 'j00zekFork' in globals():
+                    from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import j00zekIPTVPlayerConsole, j00zekRunUpdateList
+                    self.session.openWithCallback(self.displayListOfHosts, j00zekIPTVPlayerConsole, title = _("Updating plugin"), cmdlist = j00zekRunUpdateList)
+                else:
+                    self.session.openWithCallback(self.displayListOfHosts, IPTVUpdateWindow, UpdateMainAppImpl(self.session))
                 return
             elif ret[1] == "IPTVDM":
                 self.runIPTVDM(self.selectHost)
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/playerselector.py ./IPTVPlayer/components/playerselector.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/components/playerselector.py	2015-11-11 07:16:45.118414000 +0100
+++ ./IPTVPlayer/components/playerselector.py	2015-11-26 13:21:04.170595847 +0100
@@ -210,6 +210,8 @@
             "up":    self.keyUp,
             "down":  self.keyDown,
             "blue":  self.keyBlue,
+            "green":  self.keyGreen,
+
         }, -1)
         
 
@@ -369,6 +371,16 @@
         
     def keyBlue(self):
         self.close((_("IPTV download manager"), "IPTVDM"))
+
+    def keyGreen(self):
+        myHostName=self.currList[self.currLine * self.numOfCol +  self.dispX][1]
+        def CB(ret):
+            if ret:
+                ManageHostsAndCategories(myHostName, ret[1])
+                
+        from Screens.ChoiceBox import ChoiceBox
+        from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import ManageHostsAndCategories, GetHostsCategories
+        self.session.openWithCallback(CB, ChoiceBox, title=_("Assign to/Remove from Category"), list = GetHostsCategories() )
     
     def hideWindow(self):
         self.visible = False
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimecentrum.py ./IPTVPlayer/hosts/Cartoons/hostanimecentrum.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimecentrum.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Cartoons/hostanimecentrum.py	2015-11-05 22:26:57.909660252 +0100
@@ -0,0 +1,223 @@
+# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, GetLogoDir
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import re
+import urllib
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+# None
+
+
+def GetConfigList():
+    optionList = []
+    return optionList
+###################################################
+
+
+def gettytul():
+    return 'Anime-Centrum'
+
+
+class AnimeCentrum(CBaseHostClass):
+    MAINURL = 'http://anime-centrum.net'
+    SERVICE_MENU_TABLE = {
+        1: "Lista anime (alfabetycznie)",
+    }
+
+    def __init__(self):
+        CBaseHostClass.__init__(self)
+
+    def setTable(self):
+        return self.SERVICE_MENU_TABLE
+
+    def getVideoUrl(self, url):
+        printDBG("getVideoUrl url[%s]" % url)
+        sts,data = self.cm.getPage(url)
+        if not sts: return ''
+        
+        match = re.search('file: "(.+?)"', data)
+        if match:
+            return match.group(1)
+        else:
+            printDBG('nie znaleziono mp4 link')
+        return ''
+
+    def listsMainMenu(self, table):
+        for num, val in table.items():
+            params = {'name': 'main-menu', 'category': val, 'title': val, 'icon': ''}
+            self.addDir(params)
+
+    def listsABCMenu(self, table):
+        for i in range(len(table)):
+            params = {'name': 'abc-menu', 'category': table[i], 'title': table[i], 'icon': ''}
+            self.addDir(params)
+
+    def listsGenre(self, url):
+        sts,data = self.cm.getPage(url)
+        if not sts: return
+        r = re.compile('<input id=".+?"  type="checkbox" name="genre.." value="(.+?)">').findall(data)
+        if len(r) > 0:
+            for i in range(len(r)):
+                params = {'name': 'genset', 'title': r[i].replace('+', ' '), 'page': r[i], 'icon': ''}
+                self.addDir(params)
+
+# LISTOWANIE TYTUŁOW
+    def getAnimeList(self, url):
+        sts,data = self.cm.getPage(self.MAINURL + url)
+        if not sts: return
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<div id="episodes-list">', '</section>', False)[1]
+        data = data.split('<div class="push-left th-1">')
+        if len(data): del data[0]
+        for item in data:
+            tmp    = self.cm.ph.getSearchGroups(item, 'href="http://anime-centrum.net/([^"]+?)"[^>]*?>([^<]+?)<', 2)
+            url    = tmp[0]
+            title  = tmp[1]
+            desc   = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<span class="tip-text">', '</a>', False)[1] )
+            icon   = self.cm.ph.getSearchGroups(item, 'src="([^"]+?)"')[0]
+            title  = self.cleanHtmlStr(title + ' ' + item.split('</a>')[-1])
+            if '' != url:
+                params = {'name': 'episodelist', 'title': title, 'page': url, 'icon': icon, 'plot': desc}
+                self.addDir(params)
+
+# LISTOWANIE ODCINKOW
+    def getEpisodeList(self, url):
+        sts,data = self.cm.getPage(url)
+        if not sts: return
+# cover
+        grafika = re.search('<meta property="og:image" content="(.+?)" />', data)
+        if grafika: icon = grafika.group(1)
+        else: icon = ''
+# description
+        opis = re.search('<strong>Opis:</strong>(.+)', data)
+        if opis: plot = self.cleanHtmlStr(opis.group(1))
+        else: plot = ''
+        match = re.compile('<div class="info">(.+?)<div id="screens">', re.DOTALL).findall(data)
+        if len(match) > 0:
+            match2 = re.compile('<a href="http://(.+?)">Odcinek(.+?)</a>').findall(match[0])
+            if len(match2) > 0:
+                for i in range(len(match2)):
+                    value = match2[i]
+                    value2 = 'http://' + urllib.quote(value[0])
+                    if '<!--' not in value[1]:
+                        params = {'title': "Odcinek " + value[1], 'page': value2, 'icon': icon, 'plot': plot}
+                        self.addVideo(params)
+
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('handleService start')
+        if 0 == refresh:
+            if len(self.currList) <= index:
+                printDBG("handleService wrong index: %s, len(self.currList): %d" % (index, len(self.currList)))
+                return
+            if -1 == index:
+                # use default value
+                self.currItem = {"name": None}
+                printDBG("handleService for first self.category")
+            else:
+                self.currItem = self.currList[index]
+
+        name = self.currItem.get("name", '')
+        title    = self.currItem.get("title", '')
+        category = self.currItem.get("category", '')
+        page = self.currItem.get("page", '')
+        icon     = self.currItem.get("icon", '')
+
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| [%s] " % name )
+        self.currList = []
+
+        if str(page)=='None' or page=='': page = '0'
+
+    #MAIN MENU
+        if name is None:
+            self.listsMainMenu(self.SERVICE_MENU_TABLE)
+    #LISTA ANIME (Alfabetycznie)
+        elif category == self.setTable()[1]:
+            self.listsABCMenu(self.cm.makeABCList())
+        elif name == 'abc-menu':
+            self.getAnimeList('/anime-online/' + category + '.html')
+    #LISTA ODCINKÓW
+        elif name == 'episodelist':
+            url = self.MAINURL + '/' + page
+            self.getEpisodeList(url)
+
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, AnimeCentrum(), False)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value=[GetLogoDir('animecentrumlogo.png')])
+
+    def getLinksForVideo(self, Index=0, selItem=None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG("ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index))
+            return RetHost(RetHost.ERROR, value=[])
+
+        if self.host.currList[Index]["type"] != 'video':
+            printDBG("ERROR getLinksForVideo - current item has wrong type")
+            return RetHost(RetHost.ERROR, value=[])
+
+        retlist = []
+
+        urlItem = self.host.getVideoUrl(self.host.currList[Index]["page"])
+        if '' != urlItem:
+            retlist.append(CUrlItem("anime-centrum", urlItem, 0))
+
+        return RetHost(RetHost.OK, value=retlist)
+    # end getLinksForVideo
+
+    def getResolvedURL(self, url):
+#        if url != None and url != '':
+        if url is not None and url is not '':
+            ret = self.host.up.getVideoLink(url)
+            list = []
+            if ret:
+                list.append(ret)
+            return RetHost(RetHost.OK, value=list)
+        return RetHost(RetHost.NOT_IMPLEMENTED, value=[])
+
+    def convertList(self, cList):
+        hostList = []
+
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+
+            if cItem['type'] == 'category':
+                type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                page = cItem.get('page', '')
+                if '' != page:
+                    hostLinks.append(CUrlItem("Link", page, 1))
+
+            title = cItem.get('title', '')
+            description = cItem.get('plot', '')
+            icon = cItem.get('icon', '')
+
+            hostItem = CDisplayListItem(name=title,
+                                        description=description,
+                                        type=type,
+                                        urlItems=hostLinks,
+                                        urlSeparateRequest=1,
+                                        iconimage=icon)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
+
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimeodcinki.py ./IPTVPlayer/hosts/Cartoons/hostanimeodcinki.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimeodcinki.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Cartoons/hostanimeodcinki.py	2015-11-05 22:26:57.909660252 +0100
@@ -0,0 +1,356 @@
+﻿# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+import re
+import urllib
+import time
+import random
+try:    import simplejson as json
+except: import json
+
+
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+def GetConfigList():
+    optionList = []
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Anime-Odcinki.pl'
+
+class AnimeOdcinki(CBaseHostClass):
+    MAINURL  = 'http://www.anime-odcinki.pl/'
+    SEARCH_URL = MAINURL + '/search/node/'
+    MAIN_CAT_TAB = [{ 'category':'list_letters',          'title':'Lista anime',           'url':MAINURL+'lista-anime'  },
+                    { 'category':'list_letters',          'title':'Lista filmów',          'url':MAINURL+'lista-filmow' },
+                    { 'category':'list_emiotwane',        'title':'Anime Emitowane',       'url':MAINURL                },
+                    { 'category':'list_new_episodes',     'title':'Nowe odcinki emitowane','url':MAINURL                },
+                    { 'category':'list_new_added',        'title':'Ostatnio dodane odcinki z poprzednich sezonów',  'url':MAINURL },
+                    { 'category':'Wyszukaj',              'title':'Wyszukaj'             },
+                    { 'category':'Historia wyszukiwania', 'title':'Historia wyszukiwania'} ]
+                    
+    
+    def __init__(self):
+        printDBG("AnimeOdcinki.__init__")
+        CBaseHostClass.__init__(self, {'history':'AnimeOdcinki.com'})
+            
+    def _checkNexPage(self, data):
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<ul class="pagenav">', '</ul>', False)[1]
+        if 'Go to next page' in data and '<a href=' in data:
+            return True
+        else:
+            return False
+            
+    def _resolveUrl(self, url, currPath=''):
+        if not url.startswith('http') and '' != url:
+            if '' == currPath:
+                return AnimeOdcinki.MAINURL + url
+            else:
+                return currPath + url
+        else:
+            return url
+            
+    def listsTab(self, tab, cItem):
+        printDBG("AnimeOdcinki.listsMainMenu")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            self.addDir(params)
+            
+    def _listBase(self, cItem, category, m1, m2, sp):
+        url = self._resolveUrl(cItem['url'])
+        sts, data = self.cm.getPage(url)
+        if not sts: return
+        data = self.cm.ph.getDataBeetwenMarkers(data, m1, m2, False)[1]
+        data = data.split(sp)
+        if len(data): del data[-1]
+        for item in data:
+            params = dict(cItem)
+            url   = self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"', 1)[0]
+            title = self.cleanHtmlStr(item)
+            icon  = self._resolveUrl( self.cm.ph.getSearchGroups(item, """<img src=['"]([^"^']+?\.jpg[^"^']*?)['"]""")[0] )
+            if len(title) and '|' == title[0]: title = title[1:]
+            params.update({'title':title, 'url':url, 'category':category, 'icon':icon})
+            if '/film/' in url or category == 'video': self.addVideo(params)
+            else: self.addDir(params)
+                
+    def listsLetters(self, cItem, category):
+        printDBG('AnimeOdcinki.listsLetters start')
+        self._listBase(cItem, category, '<div class="view-content">', '</div>', '</span>')
+            
+    def listsAnimes(self, cItem, category):
+        printDBG('AnimeOdcinki.listsAnimes start')
+        self._listBase(cItem, category, '<tbody>', '</tbody>', '</tr>')
+        
+    def listEmitowane(self, cItem, category):
+        printDBG('AnimeOdcinki.listEmitowane start')
+        self._listBase(cItem, category, 'Anime Emitowane', '</ul>', '</li>')
+        
+    def listNewEpisodes(self, cItem):
+        printDBG('AnimeOdcinki.listNewEpisodes start')
+        self._listBase(cItem, 'video', '<ul class="jcarousel jcarousel-view--new-emitowane--block jcarousel-dom-1 jcarousel-skin-default">', '</ul>', '</div>')
+
+    def listNewAdded(self, cItem):
+        printDBG('AnimeOdcinki.listNewAdded start')
+        self._listBase(cItem, 'video', '<ul class="jcarousel jcarousel-view--nowe-odcinki--block jcarousel-dom-2 jcarousel-skin-default">', '</ul>', '</div>')            
+                
+    def listEpisodes(self, cItem):
+        printDBG('AnimeOdcinki.listEpisodes start')
+        page = cItem.get('page', 0)
+        url  = self._resolveUrl(cItem['url']) + ('?page=%d' % page)
+        sts, data = self.cm.getPage(url)
+        if not sts: return
+        desc = self.cm.ph.getDataBeetwenMarkers(data, '<div class="content">', "</section>", False)[1]
+        icon = self._resolveUrl( self.cm.ph.getSearchGroups(desc, """<img src=['"]([^"^']+?\.jpg[^"^']*?)['"]""")[0] )
+        desc = self.cleanHtmlStr(desc)
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="view-content">', '</section>', False)[1]
+        nextPage = False
+        if '<ul class="pagination">' in data:
+            if '"Przejdź do następnej strony"' in data: nextPage = True
+            data = data[:data.find('<ul class="pagination">')] 
+        '''
+        trailer = self.cm.ph.getSearchGroups(data, """href=['"](http[^"^']+?youtu[^"^']+?)['"]""")[0]
+        if '' != trailer:
+            params = dict(cItem)
+            params.update({'title':_('Zwiastun'), 'url':trailer, 'desc':desc, 'icon':icon})
+            self.addVideo(params)
+        '''
+        data = data.split('<div class="views-row views-row')
+        for item in data:
+            idx = item.find('>')
+            if 0 > idx: continue
+            item = item[idx+1:]
+            title = self.cleanHtmlStr(item)
+            url   = self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"', 1)[0]
+            params= {'title':title, 'url':url, 'desc':desc, 'icon':icon}
+            self.addVideo(params)
+        
+        if nextPage:
+            params = dict(cItem)
+            params.update({'title':'Następna strona', 'page':page+1})
+            self.addDir(params)
+                    
+    def listItems(self, cItem):
+        printDBG('AnimeOdcinki.listItems start')     
+        page     = cItem.get('page', 0)
+        url = self._resolveUrl(cItem['url']) + '?rowstart=%d' % (page * 20) 
+        currPath = url[:url.rfind('/')] + '/'
+        sts, data = self.cm.getPage(url)
+        if sts:
+            try: pagesNum = int(self.cm.ph.getSearchGroups(data, "Strona[^;]+?;([0-9]+?):")[0])-1
+            except: pagesNum = 0 
+            data = self.cm.ph.getDataBeetwenMarkers(data, '</tr></table><table cellpadding', "class='main-footer-top", True)[1]
+            data = data.split('</tr></table>')
+            if len(data): del data[0]
+            if len(data): del data[-1]
+            for item in data:
+                params = dict(cItem)
+                tmp = self.cm.ph.getSearchGroups(item, """<a href=["']([^'^"]+?)["']>([^<]+?)</a>""", 2)
+                if '' != tmp[0] and '' != tmp[1]:                
+                    icon =  self._resolveUrl(self.cm.ph.getSearchGroups(item, """src=['"]([^"^']+?)['"]""")[0], currPath)
+                    desc = self.cleanHtmlStr(item)
+                    params.update({'title':tmp[1], 'url':self._resolveUrl(tmp[0], currPath), 'icon':icon, 'desc':desc})
+                    self.addVideo(params)
+            if pagesNum > page:
+                params = dict(cItem)
+                params.update({'title':'Następna strona', 'page':page+1})
+                self.addDir(params)
+    
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        printDBG("AnimeOdcinki.listSearchResult cItem[%s], searchPattern[%s] searchType[%s]" % (cItem, searchPattern, searchType))
+        url = AnimeOdcinki.SEARCH_URL + urllib.quote_plus(searchPattern)
+        sts, data = self.cm.getPage(url)
+        if not sts: return
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<ol class="search-results node-results">', '</ol>')[1]
+        data = data.split("</li>")
+        if len(data): del data[-1]
+        for item in data:
+            tmp   = self.cm.ph.getSearchGroups(item, '<a href="([^"]+?)"[^>]*?>([^<]+?)<', 2)
+            url   = tmp[0]
+            title = self.cleanHtmlStr(tmp[1])
+            if '' != url and '' != title:
+                desc = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<div class="search-snippet-info">', '</div>')[1] )
+                icon = ''
+                params = {'name':'category', 'title':title, 'url':self._resolveUrl(url), 'icon':icon, 'desc':desc}
+                if re.search('/anime/[^/]+?$', url):
+                    params['category'] = 'episodes_list'
+                    self.addDir(params)
+                else: self.addVideo(params)
+    
+    def getLinksForVideo(self, cItem):
+        printDBG("AnimeOdcinki.getLinksForVideo [%s]" % cItem['url'])
+        if len(cItem.get('url_cache', [])):
+            return cItem['url_cache']
+        urlTab = []
+        url = self._resolveUrl(cItem['url'])
+        if 'anime-odcinki.pl' in url:       
+            sts, data = self.cm.getPage(url)
+            if sts:
+                data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="content">', "<ul")[1]
+                printDBG(data)
+                players = re.compile(""">(http[^<]+?)<""").findall(data)
+                for player in players:
+                    playerUrl = self.cleanHtmlStr( player )
+                    if '' != playerUrl:
+                        tmpTab = self.up.getVideoLinkExt(playerUrl)
+                        urlTab.extend(tmpTab)
+        else: urlTab = self.up.getVideoLinkExt(url)
+        if len(urlTab): cItem['url_cache'] = urlTab
+        return urlTab
+    
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('AnimeOdcinki.handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "AnimeOdcinki.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        searchPattern = self.currItem.get("search_pattern", searchPattern)
+        self.currList = []
+        
+        if None == name:
+            self.listsTab(AnimeOdcinki.MAIN_CAT_TAB, {'name':'category'})
+    #LIST LETTERS
+        elif 'list_letters' == category:
+            self.listsLetters(self.currItem, 'anime_list')
+    #FILMS LETTERS
+        elif 'anime_list' == category:
+            self.listsAnimes(self.currItem, 'episodes_list')
+    #LIST EPISODES
+        elif 'episodes_list' == category:
+            self.listEpisodes(self.currItem)
+    #LIST ITEMS
+        elif 'list_items' == category:
+            self.listItems(self.currItem)
+    #LIST EMITOWANE
+        elif 'list_emiotwane' == category:
+            self.listEmitowane(self.currItem, 'episodes_list')
+    #LIST NEW EPISODES
+        elif 'list_new_episodes' == category:
+            self.listNewEpisodes(self.currItem)
+    #LIST NEW ADDED 
+        elif 'list_new_added' == category:
+            self.listNewAdded(self.currItem)
+    #WYSZUKAJ
+        elif category in ["Wyszukaj", "search_next_page"]:
+            self.listSearchResult(self.currItem, searchPattern, searchType)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "Historia wyszukiwania":
+            self.listsHistory()
+        else:
+            printExc()
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, AnimeOdcinki(), True)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('animeodcinkilogo.png')])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] != 'video':
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+
+        retlist = []
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+        #searchTypesOptions.append(("Items", "items"))
+        #searchTypesOptions.append(("Channel", "channel"))
+    
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if cItem['type'] == 'category':
+                if cItem['title'] == 'Wyszukaj':
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  cItem.get('title', '')
+            description =  clean_html(cItem.get('desc', '')) + clean_html(cItem.get('plot', ''))
+            icon        =  cItem.get('icon', '')
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
+
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimeshinden.py ./IPTVPlayer/hosts/Cartoons/hostanimeshinden.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostanimeshinden.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Cartoons/hostanimeshinden.py	2015-11-11 07:16:27.395280028 +0100
@@ -0,0 +1,322 @@
+# -*- coding: utf-8 -*-
+# Based on (root)/trunk/xbmc-addons/src/plugin.video.polishtv.live/self.HOSTs/ @ 419 - Wersja 636
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSearchHistoryHelper, remove_html_markup, CSelOneLink, GetLogoDir
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from time import sleep
+import re
+from urllib import quote_plus
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+# None
+
+def GetConfigList():
+    optionList = []
+    # None
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Anime-Shinden'
+
+class AnimeShinden(CBaseHostClass):
+    MAINURL = 'http://shinden.pl/'
+    ANIME_LIST_URL = MAINURL+'anime?'
+    TOP_LIST_URL = MAINURL+'anime/top?'
+    MAIN_CAT_TAB = [{ 'category':'list_filters',          'title':'Filtruj'              },
+                    { 'category':'top',                   'title':'Top'                  },
+                    { 'category':'Wyszukaj',              'title':'Wyszukaj'             },
+                    { 'category':'Historia wyszukiwania', 'title':'Historia wyszukiwania'} ]
+    
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'shinden.pl', 'cookie':'shinden.cookie'})
+        self.genresData = {}
+        self.genres = []
+        
+    def _getFullUrl(self, url):
+        if 0 < len(url) and not url.startswith('http'):
+            url =  self.MAINURL + url
+        return url
+        
+    def _fillGenres(self):
+        printDBG('AnimeShinden._fillGenres start')
+        sts, data = self.cm.getPage(AnimeShinden.ANIME_LIST_URL)
+        if not sts: return 
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<section class="search-section">', '</section>', False)[1]
+        
+        markers = self.cm.ph.getDataBeetwenMarkers(data, '<ul ', '</ul>', False)[1]
+        markers = re.compile('id="go([^"]+?)">([^<]+?)<').findall(markers)
+        for item in markers:
+            if 'Tabtag' == item[0]: break
+            filters = []
+            genData = self.cm.ph.getDataBeetwenMarkers(data, 'id="%s">' % item[0], '</ul>', False)[1]
+            if 'genre-item' in genData:
+                genData = genData.split('<li>')
+                if len(genData): del genData[0]
+                for gen in genData:
+                    title  = self.cleanHtmlStr(gen)
+                    filter = self.cm.ph.getSearchGroups(gen, 'data-id[ ]*?=[ ]*?"([0-9]+?)"')[0]
+                    filters.append({'title':title, 'url':'genres=e%%3Bi%s&genres-type=one' % filter})
+            else:
+                genData = re.compile('href="\?([^"]+?)"[^>]*?>([^<]+?)<').findall(genData)
+                for gen in genData: filters.append({'title':gen[1], 'url':gen[0]})
+            if len(filters): 
+                self.genres.append(item[1])
+                self.genresData[item[1]] = filters
+            else: printExc("_fillGenres error for [%s]" % item[1])
+    
+    def listFilters(self, category):
+        if 0 == len(self.genres): self._fillGenres()
+        for item in self.genres:
+            self.addDir( {'name':'category', 'category':category, 'title':item} )
+            
+    def listsFiltersValues(self, cItem, category):
+        printDBG('AnimeShinden.listsFiltersValues')
+        for item in self.genresData.get(cItem['title'], []):
+            params = dict(cItem)
+            params.update( item )
+            params['category'] = category
+            self.addDir( params )
+            
+    def listAnimes(self, cItem, category, baseUrl):
+        printDBG('AnimeShinden.listAnimes')
+        page = cItem.get('page', 1)
+        sts, data = self.cm.getPage(baseUrl + ( 'page=%d&%s' % (page, cItem.get('url', '')) ))
+        if not sts: return
+        tmp = self.cm.ph.getDataBeetwenMarkers(data, '<li class="pagination-next">', '</li>', False)[1]
+        if '<a href="' in tmp: nextPage = True
+        else: nextPage = False
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<table ', '</table>', False)[1]
+        data = data.split('<tr>')
+        if len(data): del data[0]
+        for item in data:
+            item = item.split('</h3>')
+            if 2 > len(item): continue
+            tmp = self.cm.ph.getSearchGroups(item[0], 'href="([^"]+?)"[^>]*?>(.+?)</a>', 2)
+            icon = self._getFullUrl( self.cm.ph.getSearchGroups(item[0], 'src="([^"]+?)"')[0] )
+            params = {'name':'category', 'category':category, 'title':self.cleanHtmlStr(tmp[1]), 'url':tmp[0], 'icon':icon, 'desc':self.cleanHtmlStr(item[1])}
+            self.addDir(params)
+            
+        if nextPage:
+            params = dict(cItem)
+            params.update({'title':_('Następna strona'), 'page':page+1})
+            self.addDir(params)
+            
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        printDBG("AnimeShinden.listSearchResult cItem[%s], searchPattern[%s] searchType[%s]" % (cItem, searchPattern, searchType))
+        url = 'type=contains&search=' + quote_plus(searchPattern)
+        params = dict(cItem)
+        params.update({'category':'list_animes', 'url':url})
+        self.listAnimes(params, 'list_episodes', AnimeShinden.ANIME_LIST_URL)
+            
+    def listItems(self, cItem):
+        printDBG('AnimeShinden.listItems')
+        url = self._getFullUrl( cItem['url'] ) + '/episodes'
+        sts, data = self.cm.getPage(url)
+        if not sts: return 
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<tbody class="list-episode-checkboxes">', '</tbody>', False)[1]
+        data = data.split('</tr>')
+        if len(data): del data[-1]
+        for item in data:
+            params = dict(cItem)
+            url = self._getFullUrl( self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"')[0] )
+            title = self.cleanHtmlStr(item)
+            if 'class="fa fa-fw fa-check"' not in item: title = title.replace('Zobacz', 'niedostępny')
+            else: title = title.replace('Zobacz', 'zbobacz')
+            params.update({'title':title, 'url':url})
+            self.addVideo(params)
+        
+    def getLinksForVideo(self, cItem):
+        printDBG('AnimeShinden.listItems url[%s]' % cItem['url'])
+        urlsTab = []
+        
+        url = self._getFullUrl( cItem['url'] )
+        sts, data = self.cm.getPage(url)
+        if not sts: return urlsTab
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<table class=" data-view-table-big">', ' </table>', False)[1]
+        data = data.split('</thead>')
+        if 2 > len(data): return urlsTab
+        headers =  re.compile('<th>(.+?)</th>').findall(data[0])
+        data = data[1].split('</tr>')
+        if len(data): del data[-1]
+        for item in data:
+            titles = re.compile('<td[^>]*?>(.+?)</td>').findall(item)
+            title = ''
+            if len(headers) > len(titles): num = len(titles)
+            else: num = len(headers)
+            for idx in range(num):
+                title += '%s %s, ' % (headers[idx], titles[idx])
+            if '' != title: title = title[:-2]
+            onlineId = self.cm.ph.getSearchGroups(item, '"online_id":"([0-9]+?)"')[0]
+            urlsTab.append({'name': title, 'url':onlineId, 'need_resolve':1})
+        return urlsTab
+        
+    def getVideoLinks(self, onlineId):
+        printDBG('AnimeShinden.listItems onlineId[%s]' % onlineId)
+        urlsTab = []
+        url = AnimeShinden.MAINURL+'xhr/%s/player_load' % onlineId
+        sts, data = self.cm.getPage(url, {'cookiefile':self.COOKIE_FILE, 'use_cookie': True, 'save_cookie':True})
+        if not sts: return urlsTab
+        try: sleep(int(data)+1)
+        except: printExc()
+        url = AnimeShinden.MAINURL+'xhr/%s/player_show' % onlineId
+        sts, data = self.cm.getPage(url, {'cookiefile':self.COOKIE_FILE, 'use_cookie': True, 'load_cookie':True})
+        if not sts: return linksTab
+        printDBG(data)
+        if '<embed src="http://player.shinden.pl' in data:
+            data = re.compile('<embed [^>]+?>').findall(data)
+            for idx in range(len(data)):
+                urls = re.compile('file=(http[^>]+?&amp;)').findall(data[idx])
+                for url in urls: 
+                    if '/hd.' in url: title = 'hd'
+                    else: title = 'sd'
+                    urlsTab.append({'name': 'Część %d, kopia %s' % (idx+1, title), 'url':url})
+        else:
+            url = self.cm.ph.getSearchGroups(data, 'src="([^"]+?)"')[0]
+            urlsTab = self.up.getVideoLinkExt(url) 
+        return urlsTab
+    
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('AnimeShinden.handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "AnimeShinden.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        searchPattern = self.currItem.get("search_pattern", searchPattern)
+        self.currList = []
+        
+        if None == name:
+            self.listsTab(AnimeShinden.MAIN_CAT_TAB, {'name':'category'})
+        elif  'list_filters' == category: 
+            self.listFilters('list_filter_values')
+        elif 'list_filter_values' == category:
+            self.listsFiltersValues(self.currItem, 'list_animes')
+        elif 'list_animes' == category:
+            self.listAnimes(self.currItem, 'list_episodes', AnimeShinden.ANIME_LIST_URL)
+        elif 'top' == category:
+            self.listAnimes(self.currItem, 'list_episodes', AnimeShinden.TOP_LIST_URL)
+        elif 'list_episodes' == category:
+            self.listItems(self.currItem)
+    #LIST EMITOWANE
+        elif 'list_emiotwane' == category:
+            self.listEmitowane(self.currItem, 'episodes_list')
+    #LIST NEW EPISODES
+        elif 'list_new_episodes' == category:
+            self.listNewEpisodes(self.currItem)
+    #LIST NEW ADDED 
+        elif 'list_new_added' == category:
+            self.listNewAdded(self.currItem)
+    #WYSZUKAJ
+        elif category in ["Wyszukaj"]:
+            self.listSearchResult(self.currItem, searchPattern, searchType)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "Historia wyszukiwania":
+            self.listsHistory()
+        else:
+            printExc()
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, AnimeShinden(), True)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('animeodcinkilogo.png')])
+
+    def getLinksForVideo(self, Index=0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+        
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 1
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        retlist = []
+        urlList = self.host.getVideoLinks(url)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+
+    def converItem(self, cItem):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+    
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else: type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            url = cItem.get('url', '')
+            if '' != url: hostLinks.append(CUrlItem("Link", url, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  clean_html(cItem.get('desc', '')) + clean_html(cItem.get('plot', ''))
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 1,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
+
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostcartoonhd.py ./IPTVPlayer/hosts/Cartoons/hostcartoonhd.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostcartoonhd.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Cartoons/hostcartoonhd.py	2015-11-11 07:16:27.395280028 +0100
@@ -0,0 +1,508 @@
+# -*- coding: utf-8 -*-
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, SetIPTVPlayerLastHostError
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, ArticleContent
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSearchHistoryHelper, remove_html_markup, GetLogoDir, GetCookieDir, byteify
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.tools.iptvtypes import strwithmeta
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import time
+import re
+import urllib
+import base64
+try:    import json
+except: import simplejson as json
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.asynccall import MainSessionWrapper
+from Screens.MessageBox import MessageBox
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.movieshdco_sortby = ConfigSelection(default = "date", choices = [("date", _("Lastest")), ("views", _("Most viewed")), ("duree", _("Longest")), ("rate", _("Top rated")), ("random", _("Tandom"))]) 
+
+def GetConfigList():
+    optionList = []
+    return optionList
+###################################################
+
+
+def gettytul():
+    return 'CartoonHD.mobi'
+
+class CartoonHD(CBaseHostClass):
+    HEADER = {'User-Agent': 'Mozilla/5.0', 'Accept': 'text/html'}
+    AJAX_HEADER = dict(HEADER)
+    AJAX_HEADER.update( {'X-Requested-With': 'XMLHttpRequest'} )
+    
+    MAIN_URL = 'http://www.cartoonhd.mobi/'
+    SEARCH_URL = MAIN_URL + 'ajax/search.php'
+    
+    MAIN_CAT_TAB = [{'category':'new',            'mode':'',            'title': 'New',       'url':'search.php',    'icon':''},
+                    {'category':'movies',         'mode':'movies',      'title': 'Movies',    'url':'search.php',    'icon':''},
+                    {'category':'tv_shows',       'mode':'tv_shows',    'title': 'TV shows',  'url':'search.php',    'icon':''},
+                    {'category':'search',          'title': _('Search'), 'search_item':True},
+                    {'category':'search_history',  'title': _('Search history')} ]
+    
+    SORT_NAV_TAB = [{'sort_by':'favorites',   'title':'Popular'},
+                    {'sort_by':'imdb_rating', 'title':'IMDb rating'},
+                    {'sort_by':'yer',         'title':'Year'},
+                    {'sort_by':'abc',         'title':'ABC'}]
+                    #                    {'sort_by':'trending',    'title':'Trending'}
+ 
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'CartoonHD.tv', 'cookie':'cartoonhdtv.cookie'})
+        self.defaultParams = {'use_cookie': True, 'load_cookie': True, 'save_cookie': True, 'cookiefile': self.COOKIE_FILE}
+        self.cacheFilters = {}
+        self.cacheLinks = {}
+        
+    def _getFullUrl(self, url):
+        if 0 < len(url) and not url.startswith('http'):
+            url =  self.MAIN_URL + url
+        if not self.MAIN_URL.startswith('https://'):
+            url = url.replace('https://', 'http://')
+        return url
+        
+    def cleanHtmlStr(self, data):
+        data = data.replace('&nbsp;', ' ')
+        data = data.replace('&nbsp', ' ')
+        return CBaseHostClass.cleanHtmlStr(data)
+
+    def listsTab(self, tab, cItem, type='dir'):
+        printDBG("CartoonHD.listsTab")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            if type == 'dir':
+                self.addDir(params)
+            else: self.addVideo(params)
+            
+    def fillCategories(self):
+        printDBG("CartoonHD.fillCategories")
+        self.cacheFilters = {}
+        sts, data = self.cm.getPage(self.MAIN_URL)
+        if not sts: return
+        
+        moviesTab = [{'title':'All', 'url':self._getFullUrl('movies')}]
+        tmp = self.cm.ph.getDataBeetwenMarkers(data, '>Movies</a>', '</ul>', False)[1]
+        tmp = re.compile('<a[^>]*?href="([^"]+?)"[^>]*?>([^<]+?)<').findall(tmp)
+        for item in tmp:
+            moviesTab.append({'title':item[1], 'url':self._getFullUrl(item[0])})
+            
+        tvshowsTab = [{'title':'All', 'url':self._getFullUrl('tv-shows')}]
+        tmp = self.cm.ph.getDataBeetwenMarkers(data, 'TV Shows</a>', '</ul>', False)[1]
+        tmp = re.compile('<a[^>]*?href="([^"]+?)"[^>]*?>([^<]+?)<').findall(tmp)
+        for item in tmp:
+            tvshowsTab.append({'title':item[1], 'url':self._getFullUrl(item[0])})
+            
+        newsTab = [{'title':'New Episodes',           'mode':'movies',   'category':'list_items',   'url':self._getFullUrl('new-shows')}]
+        newsTab.append( {'title':'New Movies',        'mode':'movies',   'category':'list_items',   'url':self._getFullUrl('new-movies')} )
+        newsTab.append( {'title':'Box Office Movies', 'mode':'movies',   'category':'list_items',   'url':self._getFullUrl('featuredmovies')} )
+            
+        self.cacheFilters['new']      = newsTab
+        self.cacheFilters['movies']   = moviesTab
+        self.cacheFilters['tv_shows'] = tvshowsTab
+        
+    def listMoviesCategory(self, cItem, nextCategory):
+        printDBG("CartoonHD.listMoviesCategory")
+        if {} == self.cacheFilters:
+            self.fillCategories()
+            
+        cItem = dict(cItem)
+        cItem['category'] = nextCategory
+        self.listsTab(self.cacheFilters.get('movies', []), cItem)
+        
+    def listTVShowsCategory(self, cItem, nextCategory):
+        printDBG("CartoonHD.listTVShowsCategory")
+        if {} == self.cacheFilters:
+            self.fillCategories()
+            
+        cItem = dict(cItem)
+        cItem['category'] = nextCategory
+        self.listsTab(self.cacheFilters.get('tv_shows', []), cItem)
+        
+    def listNewCategory(self, cItem):
+        printDBG("CartoonHD.listNewCategory")
+        if {} == self.cacheFilters:
+            self.fillCategories()
+            
+        cItem = dict(cItem)
+        cItem.pop("category", None)
+        #cItem['category'] = nextCategory
+        self.listsTab(self.cacheFilters.get('new', []), cItem)
+            
+    def listItems(self, cItem, nextCategory=None):
+        printDBG("CartoonHD.listItems")
+        page = cItem.get('page', 1)
+        
+        url = cItem['url'] + '/' + cItem.get('sort_by', '') + '/' + str(page)
+        
+        sts, data = self.cm.getPage(url, {'header':self.AJAX_HEADER})
+        if not sts: return
+        
+        nextPage = self.cm.ph.getDataBeetwenMarkers(data, '<label for="pagenav">', '</form>', False)[1]
+        if '/{0}"'.format(page+1) in nextPage:
+            nextPage = True
+        else: nextPage = False
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="flipBox">', '</main>', False)[1]
+        data = data.split('</section>')
+        if len(data): del data[-1]
+        for item in data:
+            url  = self._getFullUrl( self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"')[0] )
+            icon = self._getFullUrl( self.cm.ph.getSearchGroups(item, 'src="([^"]+?)"')[0] )
+            desc = 'IMDb ' + self.cm.ph.getSearchGroups(item, '>([ 0-9.]+?)<')[0] + ', '
+            desc += self.cm.ph.getDataBeetwenMarkers(item, '<p>', '</p>', False)[1]
+            title  = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<h3>', '</h3>', False)[1] )
+            if url.startswith('http'):
+                params = {'title':title, 'url':url, 'desc':desc, 'icon':icon}
+                if nextCategory == None:
+                    self.addVideo(params)
+                else:
+                    params['category'] = nextCategory
+                    params2 = dict(cItem)
+                    params2.update(params)
+                    self.addDir(params2)
+        if nextPage:
+            params = dict(cItem)
+            params.update({'title':_("Next page"), 'page':page+1})
+            self.addDir(params)
+        
+    def listSeasons(self, cItem, nextCategory):
+        printDBG("CartoonHD.listSeasons")
+
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="tab selected" id="episodes">', '</select>', False)[1]
+        data = re.compile('<option[^>]*?value="([^"]+?)"[^>]*?>([^<]+?)</option>').findall(data)
+        for item in data:
+            params = dict(cItem)
+            url = self._getFullUrl(item[0])
+            params.update({'url':url, 'title':item[1], 'show_title':cItem['title'], 'category':nextCategory})
+            self.addDir(params)
+    
+    def listEpisodes(self, cItem):
+        printDBG("CartoonHD.listEpisodes")
+
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<li class="episode ">', '</ul>', False)[1]
+        data = data.split('<li class="episode ">')
+        for item in data:
+            url   = self._getFullUrl( self.cm.ph.getSearchGroups(item, 'href="([^"#]+?)"')[0] )
+            desc  = self.cm.ph.getDataBeetwenMarkers(item, '<p>', '</p>', False)[1]
+            title = self.cm.ph.getSearchGroups(item, 'title="([^"]+?)"')[0]
+            
+            if url.startswith('http'):
+                params = {'title':title, 'url':url, 'desc':desc}
+                self.addVideo(params)
+
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        printDBG("CartoonHD.listSearchResult cItem[%s], searchPattern[%s] searchType[%s]" % (cItem, searchPattern, searchType))
+    
+        sts, data = self.cm.getPage(self.MAIN_URL, self.defaultParams)
+        if not sts: return
+        
+        tor = self.cm.ph.getSearchGroups(data, "tor='([^']+?)'")[0]
+        
+        q = searchPattern
+        post_data = {'q':q, 'limit':100, 'timestamp':str(time.time()).split('.')[0], 'verifiedCheck':tor}
+        
+        httpParams = dict(self.defaultParams)
+        httpParams['header'] =  {'Referer':self.MAIN_URL, 'User-Agent':self.cm.HOST, 'X-Requested-With':'XMLHttpRequest', 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8'}
+        sts, data = self.cm.getPage(self.SEARCH_URL, httpParams, post_data=post_data)
+        if not sts: return
+        try:
+            data = byteify(json.loads(data))
+            for item in data:
+                desc = item['meta']
+                if 'Movie' in desc:
+                    category = 'video'
+                elif 'TV show' in desc:
+                    category = 'list_seasons'
+                else:
+                    category = None
+                
+                if None != category:
+                    title = item['title']
+                    url   = item['permalink'].replace('\\/', '/')
+                    icon  = item.get('image', '').replace('\\/', '/')
+                    if url.startswith('http'):
+                        params = {'name':'category', 'title':title, 'url':url, 'desc':desc, 'icon':icon, 'category':category}
+                        if category == 'video':
+                            self.addVideo(params)
+                        else:
+                            self.addDir(params)
+        except:
+            printExc()
+    
+    def getLinksForVideo(self, cItem):
+        printDBG("CartoonHD.getLinksForVideo [%s]" % cItem)
+        
+        def gettt():
+            data = str(int(time.time()))
+            b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
+            i       = 0
+            enc     = ""
+            tmp_arr = []
+            mask    = 0x3f
+            while True:
+                o1 = ord(data[i])
+                i += 1
+                if i < len(data):
+                    o2 = ord(data[i])
+                else:
+                    o2 = 0
+                i += 1
+                if i < len(data):
+                    o3 = ord(data[i])
+                else:
+                    o3 = 0
+                i += 1
+                bits = o1 << 16 | o2 << 8 | o3
+                h1   = bits >> 18 & mask
+                h2   = bits >> 12 & mask
+                h3   = bits >> 6 & mask
+                h4   = bits & mask
+                tmp_arr.append( b64[h1] + b64[h2] + b64[h3] + b64[h4] )
+                if i >= len(data):
+                    break
+            enc = ''.join(tmp_arr)
+            r   = len(data) % 3
+            if r > 0:
+                fill = '===' 
+                enc  = enc[0:r-3] + fill[r:]
+            return enc
+            
+        def getCookieItem(name):
+            value = ''
+            try:
+                value = self.cm.getCookieItem(self.COOKIE_FILE, name)
+            except:
+                printExc()
+            return value
+        
+        urlTab = self.cacheLinks.get(cItem['url'],  [])
+        if len(urlTab): return urlTab
+        self.cacheLinks = {}
+        
+        sts, data = self.cm.getPage(cItem['url'], self.defaultParams)
+        if not sts: return []
+        
+        tor  = self.cm.ph.getSearchGroups(data, "tor='([^']+?)'")[0]
+        elid = self.cm.ph.getSearchGroups(data, 'data-movie="([^"]+?)"')[0]
+        if '' == elid: elid = self.cm.ph.getSearchGroups(data, 'elid="([^"]+?)"')[0]
+        if '' == elid: return []
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<select', '</select>', False)[1]
+        hostings = []
+        data = re.compile('<option[^>]*?value="([^"]+?)"[^>]*?>([^<]+?)</option>').findall(data)
+        for item in data:
+            hostings.append({'id':item[0], 'name':item[1]})
+        
+        httpParams = {} #dict(self.defaultParams)
+        httpParams['header'] =  {'Referer':cItem['url'], 'User-Agent':self.cm.HOST, 'X-Requested-With':'XMLHttpRequest', 'Accept':'application/json, text/javascript, */*; q=0.01'}
+        if '/movie/' in cItem['url']:
+            type = 'getMovieEmb'
+        else: type = 'getEpisodeEmb'
+        encElid = gettt()
+        httpParams['header']['Cookie'] = '%s=%s; PHPSESSID=%s; flixy=%s;'% (elid, urllib.quote(encElid), getCookieItem('PHPSESSID'), getCookieItem('flixy'))
+        url = 'ajax/embeds.php'
+        post_data = {'action':type, 'idEl':elid, 'token':tor, 'elid':urllib.quote(encElid)}
+        sts, data = self.cm.getPage(self._getFullUrl(url), httpParams, post_data)
+        if not sts: return []
+        #printDBG('===============================================================')
+        #printDBG(data)
+        #printDBG('===============================================================')
+        #printDBG(hostings)
+        try:
+            data = byteify(json.loads(data))
+            for item in hostings:
+                if item['id'] in data:
+                    url = data[item['id']].replace('\\/', '/')
+                    url = self.cm.ph.getDataBeetwenMarkers(url, 'src="', '"', False, False)[1]
+                    if 'googlevideo.com' in url or 'googleusercontent.com' in url:
+                        need_resolve = 0
+                    elif 1 == self.up.checkHostSupport(url):
+                        need_resolve = 1
+                    else: 
+                        need_resolve = 0
+                    urlTab.append({'name':item['name'], 'url':url, 'need_resolve':need_resolve})
+        except:
+            printExc()
+        self.cacheLinks[cItem['url']] = urlTab
+        return urlTab
+        
+    def getVideoLinks(self, videoUrl):
+        printDBG("CartoonHD.getVideoLinks [%s]" % videoUrl)
+        urlTab = []
+        
+        if videoUrl.startswith('http'):
+            urlTab = self.up.getVideoLinkExt(videoUrl)
+        return urlTab
+        
+    def getFavouriteData(self, cItem):
+        return cItem['url']
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.getLinksForVideo({'url':fav_data})
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        name     = self.currItem.get("name", '')
+        category = self.currItem.get("category", '')
+        mode     = self.currItem.get("mode", '')
+        
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if name == None:
+            self.listsTab(self.MAIN_CAT_TAB, {'name':'category'})
+        elif category == 'new':
+            self.listNewCategory(self.currItem)
+        elif category == 'movies':
+            self.listMoviesCategory(self.currItem, 'list_sortnav')
+        elif category == 'tv_shows':
+            self.listTVShowsCategory(self.currItem, 'list_sortnav')
+            
+        elif category == 'list_sortnav':
+            cItem = dict(self.currItem)
+            cItem['category'] = 'list_items'
+            self.listsTab(self.SORT_NAV_TAB, cItem)
+        elif category == 'list_items':
+            if mode == 'movies':
+                self.listItems(self.currItem)
+            else:
+                self.listItems(self.currItem, 'list_seasons')
+        elif category == 'list_seasons':
+            self.listSeasons(self.currItem, 'list_episodes')
+        elif category == 'list_episodes':
+            self.listEpisodes(self.currItem)
+    #SEARCH
+        elif category in ["search", "search_next_page"]:
+            cItem = dict(self.currItem)
+            cItem.update({'search_item':False, 'name':'category'}) 
+            self.listSearchResult(cItem, searchPattern, searchType)
+    #HISTORIA SEARCH
+        elif category == "search_history":
+            self.listsHistory({'name':'history', 'category': 'search'}, 'desc', _("Type: "))
+        else:
+            printExc()
+        
+        CBaseHostClass.endHandleService(self, index, refresh)
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, CartoonHD(), True, [CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO])
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('cartoonhdlogo.png')])
+    
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+        
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            retlist.append(CUrlItem(item["name"], item["url"], item['need_resolve']))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        retlist = []
+        urlList = self.host.getVideoLinks(url)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    
+    def converItem(self, cItem):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+        #searchTypesOptions.append((_("Movies"),   "movie"))
+        #searchTypesOptions.append((_("TV Shows"), "tv_shows"))
+        
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if 'category' == cItem['type']:
+            if cItem.get('search_item', False):
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+        elif 'more' == cItem['type']:
+            type = CDisplayListItem.TYPE_MORE
+        elif 'audio' == cItem['type']:
+            type = CDisplayListItem.TYPE_AUDIO
+            
+        if type in [CDisplayListItem.TYPE_AUDIO, CDisplayListItem.TYPE_VIDEO]:
+            url = cItem.get('url', '')
+            if '' != url:
+                hostLinks.append(CUrlItem("Link", url, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  cItem.get('desc', '')
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 1,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+    # end converItem
+
+    def getSearchItemInx(self):
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'search':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostkreskoweczki.py ./IPTVPlayer/hosts/Cartoons/hostkreskoweczki.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Cartoons/hostkreskoweczki.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Cartoons/hostkreskoweczki.py	2015-11-11 07:16:27.395280028 +0100
@@ -0,0 +1,263 @@
+# -*- coding: utf-8 -*-
+# Based on (root)/trunk/xbmc-addons/src/plugin.video.polishtv.live/self.HOSTs/ @ 419 - Wersja 636
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, CSearchHistoryHelper, GetLogoDir
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.libs.urlparserhelper import getDirectM3U8Playlist
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import re, urllib
+from Tools.Directories import resolveFilename, SCOPE_PLUGINS, fileExists
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+# None
+
+def GetConfigList():
+    optionList = []
+    # None
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Kreskóweczki'
+
+class Kreskoweczki(CBaseHostClass):
+    MAINURL = 'http://www.kreskoweczki.pl'
+
+    MENU_TAB = {
+        1: "Kreskówki alfabetycznie",
+        2: "Ostatnio uzupełnione",
+        3: "Wyszukaj",
+        4: "Historia Wyszukiwania"
+    }
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'kreskoweczki'})
+
+    def setTable(self):
+        return self.MENU_TAB
+
+    def listsMainMenu(self, table):
+        for num, val in table.items():
+            params = { 'name': 'main-menu','category': val, 'title': val, 'icon': ''}
+            self.addDir(params)
+
+    def listsABCMenu(self, table):
+        for i in range(len(table)):
+            params = { 'name': 'abc-menu','category': table[i], 'title': table[i], 'icon': ''}
+            self.addDir(params)
+
+    def showTitles(self, letter):
+        query_data = {'url': self.MAINURL, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('showTitles EXCEPTION')
+            return
+        matchAll = re.compile('<ul class="menu" id="categories_block">(.+?)</ul>', re.DOTALL).findall(data)
+        if len(matchAll) > 0:
+            match = re.compile('<a href=.(.+?). class=.level0. alt=.(.+?) \(([0-9]+?)\).>').findall(matchAll[1])
+            if len(match) > 0:
+                for i in range(len(match)):
+                    addItem = False
+                    title = match[i][1].strip()
+
+                    if letter == '0 - 9' and (ord(title[0]) < 65 or ord(title[0]) > 91): addItem = True
+                    if (letter == title[0].upper()): addItem = True
+                    if int(match[i][2]) == 0: addItem = False
+                    if (addItem):
+                        params = { 'name': 'episode', 'title': title, 'page': match[i][0], 'icon': ''}
+                        self.addDir(params)
+
+    def showParts(self, url):
+        query_data = {'url': url, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('showParts EXCEPTION')
+            return
+
+        matchAll = re.compile("<div class='list-videos'>(.+?)<br />", re.DOTALL).findall(data)
+        if len(matchAll) > 0:
+            match = re.compile("<a href='(.+?)' title='(.+?)'><img src='(.+?)'.+?<dt class='series'>.+?title='(.+?)'>", re.DOTALL).findall(matchAll[0])
+            if len(match) > 0:
+                for i in range(len(match)):
+                    serial = match[i][3]
+                    title = '%s - %s' % (serial, match[i][1])
+                    link = match[i][0]
+                    params = {'title': title, 'page': link, 'icon': match[i][2]}
+                    self.addVideo(params)
+        match2 = re.compile("class='active'>.+?</a>  <a href='(.+?)'").findall(data)
+        printDBG(str(match2))
+        if len(match2) > 0:
+            params = { 'name': 'nextpage', 'title': 'Następna strona', 'page': match2[0], 'icon': ''}
+            self.addDir(params)
+
+    def getVideoUrl(self, url):
+        videoUrl = ''
+        videosTab = []
+        vid = re.compile("kreskowka/(.+?)/").findall(url)
+        
+        if 0 == len(vid): return []
+        
+        HEADER = {'Referer' : url}
+        query_data = {'url': 'http://www.kreskoweczki.pl/fullscreen/', 'header': HEADER, 'return_data': True}
+        postdata = {'v_id' : vid[0]}
+        try:
+            data = self.cm.getURLRequestData(query_data, postdata)
+        except:
+            printDBG('getVideoUrl EXCEPTION')
+            return videosTab
+        matchAll = re.compile("Loader.skipBanners(.+?)Loader.skipBanners", re.DOTALL).findall(data)
+        printDBG(str(matchAll))
+        if len(matchAll) > 0:
+            match = re.compile('Loader.loadFlashFile."(.+?)"').findall(matchAll[0])
+            if len(match) > 0:
+                videoUrl = match[0]
+            else:
+                match = re.compile('src="(.+?)"').findall(matchAll[0])
+                if len(match) > 0:
+                    videoUrl = match[0]
+                    
+        match = re.search('src="(http[^"]+?)"', videoUrl )
+        if match:
+            videoUrl = match.group(1)
+            
+        match = re.search("/embed/proxy[^.]+?.php", videoUrl)
+        if match:
+            sts,data = self.cm.getPage(videoUrl)
+            if sts:
+                match = re.search('url: "[^?^"]+?\?url=([^"]+?)"', data)
+                if match:
+                    url = match.group(1)
+                    if url.endswith('.m3u8'):
+                        return getDirectM3U8Playlist(url)
+        else: 
+            if videoUrl.startswith('//'):
+                videoUrl = 'http:' + videoUrl
+            return self.up.getVideoLinkExt(videoUrl)
+        return []
+        
+    def getFavouriteData(self, cItem):
+        return cItem['page']
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.getVideoUrl(fav_data)
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        name     = self.currItem.get("name", '')
+        title    = self.currItem.get("title", '')
+        category = self.currItem.get("category", '')
+        page     = self.currItem.get("page", '')
+        icon     = self.currItem.get("icon", '')
+
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| [%s] " % name )
+        self.currList = []
+
+    #MAIN MENU
+        if name == None:
+            self.listsMainMenu(self.MENU_TAB)
+    #KRESKÓWKI ALFABETYCZNIE
+        elif category == self.setTable()[1]:
+            self.listsABCMenu(self.cm.makeABCList())
+        elif name == 'abc-menu':
+            self.showTitles(category)
+        elif name == 'episode' or name == 'nextpage':
+            self.showParts(page)
+    #OSTATNIO UZUPEŁNIONE
+        elif category == self.setTable()[2]:
+            self.showParts(self.MAINURL)
+    #WYSZUKAJ
+        elif category == self.setTable()[3]:
+            text = searchPattern
+            self.showParts(self.MAINURL+"/search/?keywords="+urllib.quote_plus(text))
+    #HISTORIA WYSZUKIWANIA
+        elif category == self.setTable()[4]:
+            self.listsHistory()
+        
+        CBaseHostClass.endHandleService(self, index, refresh)
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Kreskoweczki(), True, [CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO])
+
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [ GetLogoDir('kreskoweczkilogo.png') ])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+
+        urlList = self.host.getVideoUrl(self.host.currList[Index]["page"])
+        for item in urlList:
+            retlist.append(CUrlItem(item["name"], item["url"], 0))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+
+    def converItem(self, cItem):
+        hostList = []        
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            page = cItem.get('page', '')
+            if '' != page:
+                hostLinks.append(CUrlItem("Link", page, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  cItem.get('plot', '')
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                description = description,
+                                type = type,
+                                urlItems = hostLinks,
+                                urlSeparateRequest = 1,
+                                iconimage = icon )
+    # end converItem
+
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                self.host.history.addHistoryItem( pattern )
+                self.searchPattern = pattern
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/German/hostzdfmediathek.py ./IPTVPlayer/hosts/German/hostzdfmediathek.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/German/hostzdfmediathek.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/German/hostzdfmediathek.py	2015-11-05 22:26:57.921660252 +0100
@@ -0,0 +1,513 @@
+﻿# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.urlparserhelper import getDirectM3U8Playlist
+from Plugins.Extensions.IPTVPlayer.libs.urlparser import urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigInteger, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+from datetime import datetime, timedelta
+from binascii import hexlify
+import re
+import urllib
+import time
+import random
+try:    import simplejson as json
+except: import json
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.asynccall import MainSessionWrapper
+from Screens.MessageBox import MessageBox
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.zdfmediathek_iconssize = ConfigSelection(default = "medium", choices = [ ("large", _("large")), ("medium", _("medium")), ("small", _("small")) ])
+config.plugins.iptvplayer.zdfmediathek_prefformat = ConfigSelection(default = "mp4,rtmp,m3u8", choices = [\
+("mp4,rtmp,m3u8", "mp4,rtmp,m3u8"),("mp4,m3u8,rtmp", "mp4,m3u8,rtmp"), \
+("rtmp,mp4,m3u8", "rtmp,mp4,m3u8"),("rtmp,m3u8,mp4", "rtmp,m3u8,mp4"), \
+("m3u8,rtmp,mp4", "m3u8,rtmp,mp4"),("m3u8,mp4,rtmp", "m3u8,mp4,rtmp")])
+config.plugins.iptvplayer.zdfmediathek_prefquality = ConfigSelection(default = "3", choices = [("0", _("low")), ("1", _("medium")), ("2", _("high")), ("3", _("very high")), ("4", _("hd"))])
+config.plugins.iptvplayer.zdfmediathek_prefmoreimportant = ConfigSelection(default = "quality", choices = [("quality", _("quality")), ("format", _("format"))])
+config.plugins.iptvplayer.zdfmediathek_onelinkmode = ConfigYesNo(default=True)
+
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("Icons size"), config.plugins.iptvplayer.zdfmediathek_iconssize))
+    optionList.append(getConfigListEntry(_("Prefered format"), config.plugins.iptvplayer.zdfmediathek_prefformat))
+    optionList.append(getConfigListEntry(_("Prefered quality"), config.plugins.iptvplayer.zdfmediathek_prefquality))
+    optionList.append(getConfigListEntry(_("More important"), config.plugins.iptvplayer.zdfmediathek_prefmoreimportant))
+    optionList.append(getConfigListEntry(_("One link mode"), config.plugins.iptvplayer.zdfmediathek_onelinkmode))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'ZDFmediathek'
+
+class ZDFmediathek(CBaseHostClass):
+    DEFAULT_ICON = 'http://www.zdf.de/ZDFmediathek/img/fallback/236x133.jpg'
+    MAIN_API_URL = 'http://heute-api.live.cellular.de/'
+    RUBRIKEN_API_URL = MAIN_API_URL + 'mediathek/rubriken'
+    SENDUNG_API_URL  = MAIN_API_URL + 'mediathek/sendung'
+    SEARCH_API_URL   = MAIN_API_URL + 'mediathek/suche?search='
+    NEWS_API_URL     = MAIN_API_URL + 'mediathek/nachrichten'
+    NEWS_SHOW_API_URL = MAIN_API_URL + 'mediathek/nachrichtensendungen'
+    THEMEN_API_URL    = MAIN_API_URL + 'mediathek/themen'
+    MISSED_SHOW_API_URL = MAIN_API_URL + 'mediathek/sendungverpasst'
+    A_Z_API_URL      = MAIN_API_URL + 'mediathek/a-z'
+    HOME_API_URL     = MAIN_API_URL + 'mediathek/start'
+    VIDEO_API_URL    = MAIN_API_URL + 'mediathek/video'
+    VIDEO_WEB_URL    = "http://www.zdf.de/ZDFmediathek/xmlservice/web/beitragsDetails?ak=web&id="
+    
+    MAIN_CAT_TAB = [{'category':'startseite',     'title':_('Home page'), 'url': HOME_API_URL},
+                    {'category':'nachrichten',    'title':_('News'), 'url': NEWS_API_URL},
+                    {'category':'sendungverpasst','title':_('Missed the show?')},
+                    {'category':'a_z',            'title':_('Program A-Z')},
+                    {'category':'rubriken',       'title':_('Categories'), 'url': RUBRIKEN_API_URL},
+                    {'category':'themen',         'title':_('Topics'), 'url': NEWS_API_URL},
+                    {'category':'search',         'title':_('Search'), 'search_item':True},
+                    {'category':'search_history', 'title':_('Search history')} ]
+
+    START_CAT_TAB =   [{'key':'live',         'title':_('All programs in the Live Stream')}, 
+                       {'key':'themen',       'title':_("Topics")}, 
+                       {'key':'tipps',        'title':_('Featured')}, 
+                       {'key':'aktuell',      'title':_('Recent')},
+                       {'key':'meistGesehen', 'title':_('Most Popular')}]
+        
+    SENDUNG_CAT_TAB = [{'key':'tipps',        'title':_('Featured')}, 
+                       {'key':'aktuell',      'title':_('Recent')},
+                       {'key':'meistGesehen', 'title':_('Most Popular')}]
+                       
+    A_Z_CAT_TAB     = [{'id':'A/C',        'title':_('ABC')},
+                       {'id':'D/E',        'title':_('DFE')},
+                       {'id':'G/I',        'title':_('GHI')},
+                       {'id':'J/K',        'title':_('JKL')},
+                       {'id':'M/O',        'title':_('MNO')},
+                       {'id':'P/S',        'title':_('PQRS')},
+                       {'id':'T/V',        'title':_('TUV')},
+                       {'id':'W/Z',        'title':_('WXYZ')},
+                       {'id':'0-9/0-9',    'title':_('0-9')}, ]
+                       
+    QUALITY_MAP = {'veryhigh':3, 'high':2, 'med':1, 'low':0 }
+    
+    def __init__(self):
+        printDBG("ZDFmediathek.__init__")
+        CBaseHostClass.__init__(self, {'history':'ZDFmediathek.tv'})     
+    
+    def _cleanHtmlStr(self, str):
+        str = str.replace('<', ' <').replace('\n', ' ').replace('\r', ' ').replace('\t', ' ')
+        return self.cm.ph.removeDoubles(clean_html(str), ' ').strip()
+        
+    def _getStr(self, v, default=''):
+        return clean_html(self._encodeStr(v, default))
+        
+    def _encodeStr(self, v, default=''):
+        if type(v) == type(u''): return v.encode('utf-8')
+        elif type(v) == type(''): return v
+        else: return default
+        
+    def _getNum(self, v, default=0):
+        try: return int(v)
+        except:
+            try: return float(v)
+            except: return default
+            
+    def _getIcon(self, iconsItem):
+        iconssize = config.plugins.iptvplayer.zdfmediathek_iconssize.value
+        iconsTab = []
+        for item in iconsItem.keys():
+            item = iconsItem[item]
+            if "contentblob" in item["url"]:
+                iconsTab.append({'size':item["width"], 'url':item["url"]})
+        idx = len(iconsTab)
+        if idx:
+            iconsTab.sort(key=lambda k: k['size'])
+            if 'large' == iconssize:    idx -= 1
+            elif 'medium' == iconssize: idx /=  2
+            elif 'small' == iconssize:  idx = 0
+            return iconsTab[idx]['url']
+        return ''
+       
+    def listsTab(self, tab, cItem):
+        printDBG("ZDFmediathek.listsMainMenu")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            self.addDir(params)
+            
+    def _listBase(self, cItem, categories, baseUrl, key, addPage=False):
+        if addPage:
+            page = cItem.get('page', 0)
+            url =  baseUrl + '?page=%s' % page
+        else: url = baseUrl
+        sts, data = self.cm.getPage(url)
+        try:
+            data = json.loads(data)
+            for item in data[key]["teaser"]:
+                if  item["type"] in categories:
+                    category = item["type"]
+                    params = dict(cItem)
+                    if category in ["video", "livevideo"]:
+                        desc = str(timedelta(seconds=int(item["length"]))) + ", " + item.get("beschreibung", "")
+                    else:
+                        desc = (_("%s items in category") % self._getStr(item["length"])) + ", " + self._getStr(item.get("beschreibung", ""))
+                    icon = self._getIcon(item["teaserBild"])
+                    params.update({'category':category, 'title':item["titel"],'id':item["id"], 'desc':desc, 'icon':icon, 'url':'', 'beschreibung':self._getStr(item.get("beschreibung", ""))})
+                    params.pop("key", None)
+                    if category in ["video", "livevideo"]:
+                        self.addVideo(params)
+                    else:
+                        self.addDir(params)
+        except: printExc()
+        # add next page when needed
+        if addPage:
+            url = baseUrl + '?page=%s' % (page+1)
+            sts, newData = self.cm.getPage(url)
+            try:
+                newData = json.loads(newData)
+                if  len(newData[key]["teaser"]) and newData[key]["teaser"] != data[key]["teaser"]:
+                    params = dict(cItem)
+                    desc = item.get("beschreibung", "")
+                    params.update({'page':page+1, 'title':_('Next page'), 'desc':desc})
+                    self.addDir(params)
+            except: printExc()
+            
+    def listRubriken(self, cItem, category):
+        printDBG("ZDFmediathek.listRubriken")
+        self._listBase(cItem, [category], cItem['url'], "rubriken")
+
+    def listRubrik(self, cItem, category):
+        printDBG("ZDFmediathek.listRubrik")
+        url = ZDFmediathek.RUBRIKEN_API_URL + ('/%s' % cItem["id"])
+        self._listBase(cItem, [category], url, "aktuell")
+        
+    def listA_Z(self, cItem, category):
+        printDBG("ZDFmediathek.listA_Z")
+        url = ZDFmediathek.A_Z_API_URL + ('/%s' % cItem["id"])
+        self._listBase(cItem, [category], url, "ergebnis")
+        
+    def listNachrichten(self, cItem, category):
+        printDBG("ZDFmediathek.listNachrichten")
+        url = ZDFmediathek.NEWS_API_URL
+        self._listBase(cItem, [category, "sendung"], url, "ganzeSendungen", False)
+        
+    def listThemen(self, cItem, category):
+        printDBG("ZDFmediathek.listThemen")
+        url = ZDFmediathek.THEMEN_API_URL
+        self._listBase(cItem, [category], url, "themen", False)
+        
+    def listSendungverpasst(self, cItem):
+        printDBG("ZDFmediathek.listSendungverpasst")
+        if "date" in cItem:
+            url = ZDFmediathek.MISSED_SHOW_API_URL + '/' + cItem['date']
+            self._listBase(cItem, ["video", "livevideo"], url, "ergebnis", False)
+        else:
+            # convert to timestamp
+            now = int(time.time())
+            for item in range(7):
+                date =  datetime.fromtimestamp(now - item * 24 * 3600).strftime('%Y-%m-%d')
+                params = dict(cItem)
+                params.update({'date':date, 'title':date})
+                self.addDir(params)
+        
+    def listSendung(self, cItem, url, cat_tab=None):
+        printDBG("ZDFmediathek.listSendung")
+        if None == cat_tab: cat_tab = ZDFmediathek.SENDUNG_CAT_TAB
+        if '' != cItem.get("id", ''):
+            url += ('/%s' % cItem["id"])
+        if "key" in cItem:
+            self._listBase(cItem, ["video", "livevideo", "sendung", "thema"], url, cItem['key'], True)
+        else:
+            tmpTab = []
+            page = cItem.get('page', 0)
+            sts, data = self.cm.getPage(url + '?page=%s' % page)
+            try:
+                data = json.loads(data)
+                for item in cat_tab:
+                    if item['key'] in data and len(data[item['key']].get("teaser", [])):
+                        params = dict(cItem)
+                        params.update(item)
+                        params["desc"] = cItem.get("beschreibung", "")
+                        tmpTab.append(params)
+            except: printExc()
+            if 1 == len(tmpTab):
+                cItem['key'] = tmpTab[0]['key']
+                self._listBase(cItem, ["video", "livevideo"], url, cItem['key'], True)
+            else:
+                for item in tmpTab: self.addDir(item)
+
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        printDBG("ZDFmediathek.listSearchResult cItem[%s], searchPattern[%s] searchType[%s]" % (cItem, searchPattern, searchType))
+        searchPattern = urllib.quote_plus(searchPattern)
+        url = ZDFmediathek.SEARCH_API_URL + searchPattern
+        self._listBase(cItem, ["video", "livevideo"], url, "ergebnis", False)
+    
+    def getLinksForVideo(self, cItem):
+        printDBG("ZDFmediathek.getLinksForVideo id[%s]" % cItem['id'])
+        urlTab = []        
+        tmpVideoFormats = {'f4m':[], 'm3u8':[], 'rtmp':[], 'mp4':[]}
+
+        # GET VIDEO URL FROM MOBILE API
+        '''
+        url = ZDFmediathek.VIDEO_API_URL + '/' + cItem['id'] + '?page=0'
+        sts, data = self.cm.getPage(url)
+        try:
+            live = False
+            data = json.loads(data)
+            data = data["video"]
+            if "livevideo" in data['type']: 
+                live = True
+            data = data["formitaeten"]
+            for item in data:
+                if 'm3u8_' in item["type"]:
+                    urlTab.append({'name':item["type"], 'url':item["url"]})
+        except: printExc()
+        '''
+        
+        # GET VIDEO URL FROM WEB API
+        preferedQuality = int(config.plugins.iptvplayer.zdfmediathek_prefquality.value)
+        preferedFormat  = config.plugins.iptvplayer.zdfmediathek_prefformat.value
+        tmp = preferedFormat.split(',')
+        formatMap = {}
+        for i in range(len(tmp)):
+            formatMap[tmp[i]] = i
+        
+        def _rtmpGetUrl(url):
+            retUrl = ''
+            sts, data = self.cm.getPage(url)
+            if sts:
+                retUrl = self.cm.ph.getDataBeetwenMarkers(data, "<default-stream-url>", "</default-stream-url>", False)[1].strip()
+            return retUrl.strip()
+        def _httpGetUrl(url):
+            # simple check if url is valid
+            sts, data = self.cm.getPage(url, {'return_data':False})
+            if sts:
+                data.close()
+                return url
+            else: return ''
+            
+        tmpUrlTab = []
+        url = ZDFmediathek.VIDEO_WEB_URL + cItem['id']
+        sts, data = self.cm.getPage(url)
+        live = False
+        if "<type>livevideo</type>" in data: 
+            live = True
+        try:
+            data = self.cm.ph.getDataBeetwenMarkers(data, "<formitaeten>", "</formitaeten>", False)[1]
+            data = data.split("</formitaet>")
+            del data[-1]
+            for item in data:
+                quality = self.cm.ph.getDataBeetwenMarkers(item, "<quality>", "</quality>", False)[1].strip()
+                url = self.cm.ph.getDataBeetwenMarkers(item, "<url>", "</url>", False)[1].strip()
+                for type in [{'pattern':'http_m3u8_http', 'name':'m3u8'}, {'pattern':'mp4_http', 'name':'mp4'}, {'pattern':'rtmp_zdfmeta_http', 'name':'rtmp', 'get_url':_rtmpGetUrl}]:
+                    if type['pattern'] in item:
+                        qualityVal = ZDFmediathek.QUALITY_MAP.get(quality,10)
+                        qualityPref = abs(qualityVal - preferedQuality)
+                        formatPref  = formatMap.get(type['name'], 10)
+                        tmpUrlTab.append({'url':url, 'quality_name':quality, 'quality':qualityVal, 'quality_pref':qualityPref, 'format_name':type['name'], 'format_pref':formatPref, 'get_url':type.get('get_url', _httpGetUrl)})
+        except: printExc()
+        def _cmpLinks(it1, it2):
+            prefmoreimportantly = config.plugins.iptvplayer.zdfmediathek_prefmoreimportant.value
+            if 'quality' == prefmoreimportantly:
+                if it1['quality_pref'] < it2['quality_pref'] :   return -1
+                elif it1['quality_pref']  > it2['quality_pref'] : return 1
+                else:
+                    if it1['quality'] < it2['quality'] :   return -1
+                    elif it1['quality']  > it2['quality'] : return 1
+                    else:
+                        if it1['format_pref'] < it2['format_pref'] :   return -1
+                        elif it1['format_pref']  > it2['format_pref'] : return 1
+                        else: return 0
+            else:
+                if it1['format_pref'] < it2['format_pref'] :   return -1
+                elif it1['format_pref']  > it2['format_pref'] : return 1
+                else:
+                    if it1['quality_pref'] < it2['quality_pref'] :   return -1
+                    elif it1['quality_pref']  > it2['quality_pref'] : return 1
+                    else:
+                        if it1['quality'] < it2['quality'] :   return -1
+                        elif it1['quality']  > it2['quality'] : return 1
+                        else: return 0
+        tmpUrlTab.sort(_cmpLinks)
+        onelinkmode = config.plugins.iptvplayer.zdfmediathek_onelinkmode.value
+        for item in tmpUrlTab:
+            url = item['url']
+            name = item['quality_name'] + ' ' + item['format_name']
+            if onelinkmode or 'rtmp' == item['format_name']: url = item['get_url'](url)
+            if '' != url:
+                urlTab.append({'name':name, 'url':self.up.decorateUrl(url, {'iptv_livestream':live})})
+                if onelinkmode: break
+        printDBG(tmpUrlTab)
+        return urlTab
+    
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('ZDFmediathek.handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "ZDFmediathek.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        searchPattern = self.currItem.get("search_pattern", searchPattern)
+        self.currList = [] 
+
+        if None == name:
+            self.listsTab(ZDFmediathek.MAIN_CAT_TAB, {'name':'category'})
+    #STARTSEITE
+        elif 'startseite' == category:
+            self.listSendung(self.currItem, ZDFmediathek.HOME_API_URL, ZDFmediathek.START_CAT_TAB)
+    #RUBRIKEN
+        elif 'rubriken' == category:
+            self.listRubriken(self.currItem, 'rubrik')
+    #RUBRIK
+        elif 'rubrik' == category:
+            self.listRubrik(self.currItem, 'sendung')
+    #SENDUNG
+        elif 'sendung' == category:
+            self.listSendung(self.currItem, ZDFmediathek.SENDUNG_API_URL)
+    #NACHRICHTEN
+        elif 'nachrichten' == category:
+            self.listNachrichten(self.currItem, 'nachrichten_sendung')
+    #NARCHRICHTEN SENDUNG
+        elif 'nachrichten_sendung' == category:
+            self.listSendung(self.currItem, ZDFmediathek.NEWS_SHOW_API_URL)
+    #THEMEN
+        elif 'themen' == category:
+            self.listThemen(self.currItem, 'thema')
+    #THEMA
+        elif 'thema' == category:
+            self.listSendung(self.currItem, ZDFmediathek.THEMEN_API_URL)
+    #SENDUNGVERPASS
+        elif 'sendungverpasst' == category:
+            self.listSendungverpasst(self.currItem)
+    #A-Z
+        elif 'a_z' == category:
+            self.listsTab(ZDFmediathek.A_Z_CAT_TAB, {'name':'category', 'category':'list_a_z'})
+    #LIST A-Z
+        elif 'list_a_z' == category:
+            self.listA_Z(self.currItem, 'sendung')
+    #WYSZUKAJ
+        elif category in ["search", "search_next_page"]:
+            cItem = dict(self.currItem)
+            cItem.update({'search_item':False, 'name':'category', 'category':'search_next_page'}) 
+            self.listSearchResult(cItem, searchPattern, searchType)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "search_history":
+            self.listsHistory({'name':'history', 'category': 'search'}, 'desc', _("Type: "))
+        else:
+            printExc()
+        CBaseHostClass.endHandleService(self, index, refresh)
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, ZDFmediathek(), True)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('zdfmediatheklogo.png')])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] not in ['audio', 'video']:
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+
+        retlist = []
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 0
+            name = self.host._getStr( item["name"] )
+            url  = item["url"]
+            retlist.append(CUrlItem(name, url, need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+        #searchTypesOptions.append((_("Games"), "games"))
+        #searchTypesOptions.append((_("Channles"), "streams"))
+    
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if 'category' == cItem['type']:
+                if cItem.get('search_item', False):
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+            elif 'more' == cItem['type']:
+                type = CDisplayListItem.TYPE_MORE
+            elif 'audio' == cItem['type']:
+                type = CDisplayListItem.TYPE_AUDIO
+                
+            if type in [CDisplayListItem.TYPE_AUDIO, CDisplayListItem.TYPE_VIDEO]:
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  self.host._getStr( cItem.get('title', '') )
+            description =  self.host._getStr( cItem.get('desc', '') ).strip()
+            icon        =  self.host._getStr( cItem.get('icon', '') )
+            if '' == icon: icon = ZDFmediathek.DEFAULT_ICON
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
+
+    def getSearchItemInx(self):
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'search':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostipla_blocked_due_privacy_policy.py ./IPTVPlayer/hosts/hostipla_blocked_due_privacy_policy.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostipla_blocked_due_privacy_policy.py	2015-11-05 22:26:57.913660252 +0100
+++ ./IPTVPlayer/hosts/hostipla_blocked_due_privacy_policy.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,377 +0,0 @@
-# -*- coding: utf-8 -*-
-
-####################################################################
-# IPLA privacy policy
-# Pobieranie i udostępnianie danych ze źródła ipla przez 
-# podmioty nieuprawnione grozi sankcjami karnymi na 
-# podstawie obowiązujących przepisów karnych (grzywna, 
-# kara ograniczenia wolności albo kara pozbawienia wolności) 
-# oraz konsekwencjami przewidzianymi w przepisach prawa 
-# cywilnego (odszkodowanie w wysokości zasądzonej przez sąd).
-# Zabronione jest pobieranie danych i udostępniania ich na 
-# urządzeniach lub aplikacjach innych niż przygotowane i 
-# wspierane oficjalnie przez Redefine Sp. z o.o.
-####################################################################
-
-###################################################
-# LOCAL import
-###################################################
-from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
-from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, CFavItem
-from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSelOneLink, GetLogoDir, GetCookieDir, byteify
-from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
-from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
-###################################################
-
-###################################################
-# FOREIGN import
-###################################################
-# from xml.etree import cElementTree - I would not recommend this XML parser or any other from python
-# XML will be parser using regular expressions due to problem with memory leak, if we use
-# cElementTree event if memory is free using clear method and removing instances by del, 
-# the memory using still grows with each parsing, probably due to fragmentation of memory.
-# The XML is devil's invention :)
-    
-from Components.config import config, ConfigYesNo, ConfigSelection, getConfigListEntry
-from time import time
-from os import path as os_path
-import urllib
-import re
-
-try: import json
-except: import simplejson as json
-###################################################
-
-
-###################################################
-# Config options for HOST
-###################################################
-config.plugins.iptvplayer.iplacachexml      = ConfigSelection(default = "12", choices = [("0", "nigdy"), ("6", "przez 6 godzin"), ("12", "przez 12 godzin"),("24", "przez dzień")])
-config.plugins.iptvplayer.iplaDefaultformat = ConfigSelection(default = "400", choices = [("200", "bitrate: 200"),("400", "bitrate: 400"),("900", "bitrate: 900"),("1900", "bitrate: 1900")])
-config.plugins.iptvplayer.iplaUseDF         = ConfigYesNo(default = True)
-
-def GetConfigList():
-    optionList = []
-    optionList.append(getConfigListEntry(_("Używaj danych z pamięci podręcznej:"), config.plugins.iptvplayer.iplacachexml))
-    optionList.append(getConfigListEntry(_("Domyślny format video:"), config.plugins.iptvplayer.iplaDefaultformat))
-    optionList.append(getConfigListEntry(_("Używaj domyślnego format video:"), config.plugins.iptvplayer.iplaUseDF))
-    return optionList
-###################################################
-
-def gettytul():
-    return 'Ipla'
-
-class Ipla(CBaseHostClass):
-    HOST       = 'mipla/23'
-    IDENTITY   = 'ver=600&login=common_user&cuid=-11033141'
-    MAIN_URL   = 'http://getmedia.redefine.pl'
-    CAT_URL    = MAIN_URL + '/r/l_x_35_ipla/categories/list/?' + IDENTITY
-    MOV_URL    = MAIN_URL + '/action/2.0/vod/list/?' + IDENTITY + '&category='
-    SEARCH_URL = MAIN_URL + '/vods/search/?vod_limit=150&' + IDENTITY + '&page=0&keywords='
-    
-    def __init__(self):
-        CBaseHostClass.__init__(self, {'history':'ipla'})
-        self.categoryXMLTree = None
-        self.cacheFilePath   = os_path.join(config.plugins.iptvplayer.SciezkaCache.value, "iplaxml.cache")
-        
-    def getStr(self, v, default=''):
-        if None == v:
-            return default
-        elif type(v) == type(u''):
-            return v.encode('utf-8')
-        elif type(v) == type(''):
-            return v
-
-    def __getAttribs(self, data):
-        re_compile = re.compile('([^= ]+?)="([^"]+?)"')
-        item={}
-        attribs = re_compile.findall(data)
-        for attrib in  attribs:
-            item[attrib[0]] = attrib[1]
-        return item
-    
-    def getVideosList(self, url):
-        printDBG("Ipla.getVideosList url[%s]" % url)
-            
-        sts, videosXMLTree = self.cm.getPage(url, {'host' : Ipla.HOST})
-        if sts:
-            videosXMLTree = self.getStr(videosXMLTree).split('</vod>')
-            del videosXMLTree[-1]
-            re_compile_vod    = re.compile('<vod ([^>]+?)>')
-            re_compile_thumbs = re.compile('<thumb ([^>]+?)>')
-            try:
-                for vod in videosXMLTree:
-                    try:
-                        val = re_compile_vod.search(vod)
-                        if not val: continue
-                        val = self.__getAttribs(val.group(1))
-                        title = val.get('title', '')
-                        plot  = val.get('descr', '')
-                        icon  = val.get('thumbnail', '')
-                        try:
-                            thumbs = re_compile_thumbs.findall(vod)
-                            thumbSizePrev = 9999
-                            for thumb in thumbs:
-                                attrib = self.__getAttribs(thumb)
-                                thumbSize = int(attrib['size'].split('x')[0])
-                                if thumbSizePrev > thumbSize:
-                                    thumbSizePrev = thumbSize
-                                    icon = attrib['url']
-                        except: printExc()
-                        urls = self._getVideoUrls(vod)
-                        params = {'category': 'video', 'title': title, 'plot': plot, 'icon':icon, 'urls': urls, 'fav_item':{'url':url, 'vod_id':val.get('id', '')}}
-                        self.addVideo(params)
-                    except: printExc()
-            except: printExc()
-    # end getVideosList
-    
-    def _getVideoUrls(self, vodData):
-        urls = []
-        re_compile_srcreq = re.compile('<srcreq ([^>]+?)>')
-        max_bitrate = int(config.plugins.iptvplayer.iplaDefaultformat.value)
-        def __getLinkQuality( itemLink ):
-            return int(itemLink['bitrate'])
-        try:
-            links = re_compile_srcreq.findall(vodData)
-            for link in links:
-                attrib = self.__getAttribs(link)
-                drm = attrib['drmtype']
-                if drm == '0':
-                    if config.plugins.iptvplayer.ZablokujWMV.value and attrib['format'] == '0':
-                        continue
-                    name = "Jakość: %s\t format: %s\t  bitrate: %s" % (attrib['quality'], attrib['format'], attrib['bitrate'])
-                    urls.append( {'name':name, 'url':attrib['url'], 'bitrate':attrib['bitrate']} )
-        except: printExc()
-        if config.plugins.iptvplayer.iplaUseDF.value and 1 < len(urls):
-            urls = CSelOneLink(urls, __getLinkQuality, max_bitrate).getOneLink()
-        return urls
-    
-    def __writeCategoryCache(self, data):
-        printDBG("__writeCategoryCache ")
-        try:
-            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
-            data = str({"timestamp" : int(time()), "data":data})
-            with open(self.cacheFilePath, 'w') as f:
-                f.write(str(data))            
-        except:
-            printExc()
-    
-    def __readCategoryCache(self):
-        printDBG("__readCategoryCache ")
-        try:
-            data = None
-            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
-            from ast import literal_eval
-            with open(self.cacheFilePath, 'r') as f:
-                data = f.read()
-            data = literal_eval(data)
-            currTimestamp = int(time())
-            saveTimestamp = data["timestamp"]
-            
-            if (currTimestamp - saveTimestamp) / 3600 < int(config.plugins.iptvplayer.iplacachexml.value):
-                data = data["data"]
-                printDBG("__readCategoryCache data from cache valid")
-            else:
-                data = None
-        except:
-            printExc()
-            data = None
-        return data
-        
-    def getCatXmlTree(self, refresh=False):
-        printDBG("setCatXmlTree refresh[%r]" %  refresh)
-        
-        def _fromUrl():
-            sts,data = self.cm.getPage(Ipla.CAT_URL, {'host' : Ipla.HOST})
-            if not sts: data = ''
-            return data
-            
-        if None == self.categoryXMLTree or refresh:
-            try:
-                bFromCache = True
-                data = None
-                if not refresh:
-                    data = self.__readCategoryCache()
-                if None == data:
-                    bFromCache = False
-                    data = _fromUrl()
-                self.categoryXMLTree = self.__simpleCategoryParser(data)
-                if bFromCache and 100 > len(self.categoryXMLTree):
-                    data = _fromUrl()
-                    self.categoryXMLTree = self.__simpleCategoryParser(data)
-                    bFromCache = False
-                if not bFromCache:
-                    self.__writeCategoryCache(data)
-            except:
-                printExc()
-                self.categoryXMLTree = None
-        return self.categoryXMLTree
-        
-    def __simpleCategoryParser(self, data):
-        printDBG("__simpleCategoryParser start")
-        data = re.compile('<cat ([^>]+?)>').findall(data)
-        printDBG("__simpleCategoryParser step 1 finished")
-        for idx in range(len(data)):
-            data[idx] = self.__getAttribs(data[idx])
-        printDBG("__simpleCategoryParser step 2 finished")
-        return data
-        
-    def getCategories(self, parentCatId, refresh):
-        printDBG( "getCategories parentCatId[%s]" % parentCatId )
-        xmlTree = self.getCatXmlTree(refresh)
-        if xmlTree:
-            try:
-                #cats = xmlTree.findall("cat")
-                cats = xmlTree
-                listVideo = False
-                numOfSubCat = 0
-                for cat in cats:
-                    #val = cat.attrib
-                    val = cat
-                    try:
-                        listVideo = True
-                        pid = self.getStr(val.get('pid', ''), '')
-                        catId = self.getStr(val.get('id', ''), '')
-                        if '' in [pid, catId]:
-                            continue
-                        if pid == parentCatId:
-                            numOfSubCat += 1
-                            title = self.getStr(val.get('title', ''), '')
-                            plot  = self.getStr(val.get('descr', ''), '')
-                            icon  = self.getStr(val.get('thumbnail', ''), '')
-                            #check if this is only link to diffrent category
-                            try:
-                                link = self.getStr(val.get('action', ''), '')
-                                linkMarker = "ipla://cmd-cmd=gotocat&catid="
-                                if linkMarker  in link:
-                                    # if this is only linkt to another category, update category id
-                                    catId = link.replace(linkMarker, "")
-                            except: pass
-                            params = {'category': 'category', 'title': title, 'plot': plot, 'icon':icon, 'catId': catId, 'pCatId': pid}
-                            self.addDir(params)
-                        #printDBG("||||||||||||||||: %s" %pid)
-                    except:
-                        printDBG( "getCategories except" )
-                        printExc()
-                if listVideo and numOfSubCat < 2:
-                    self.getVideosList(Ipla.MOV_URL + parentCatId)
-            except: printExc()
-        return
-        
-    def listsMainMenu(self, refresh=False):
-        printDBG('listsMainMenu')
-        self.getCategories('0', refresh)
-        self.addDir( {'category': 'Wyszukaj',  'title': 'Wyszukaj'} )
-        self.addDir( {'category': 'search_history',   'title': 'Historia wyszukiwania'} )
-        
-    def getFavouriteData(self, cItem):
-        return json.dumps(cItem['fav_item'])
-        
-    def getLinksForFavourite(self, fav_data):
-        links = []
-        try: 
-            favItem = byteify( json.loads(fav_data) )
-            printDBG(favItem)
-            sts, data = self.cm.getPage(favItem['url'], {'host' : Ipla.HOST})
-            if sts:
-                sts, data = self.cm.ph.getDataBeetwenReMarkers(data, re.compile('<vod[^>]+?id="%s"[^>]*?>'% favItem['vod_id']), re.compile('</vod>' ), False)
-                if sts: links = self._getVideoUrls(data)
-        except: printExc()
-        return links
-
-    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
-        printDBG('handleService start')
-        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
-
-        if 0 == refresh: refresh = False
-        else: refresh = True
-
-        title      = self.currItem.get("title", '')
-        category   = self.currItem.get("category", None)
-        catId      = self.currItem.get("catId", '')
-        pCatId     = self.currItem.get("pCatId", '')
-        icon       = self.currItem.get("icon", '')
-        url        = self.currItem.get("url", '')
-        plot       = self.currItem.get("plot", '')
-        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| category[%r] " % (category) )
-        self.currList = []
-        
-    #MAIN MENU
-        if category == None:
-            self.listsMainMenu(refresh)
-    #GET SUB CATEGORY
-        elif category == 'category':
-            self.getCategories(catId, refresh)
-    #WYSZUKAJ
-        elif category == 'Wyszukaj':
-            pattern = urllib.quote_plus(searchPattern)
-            self.getVideosList(Ipla.SEARCH_URL + pattern)
-    #HISTORIA WYSZUKIWANIA
-        elif category == "search_history":
-            self.listsHistory()
-
-class IPTVHost(CHostBase):
-
-    def __init__(self):
-        CHostBase.__init__(self, Ipla(), True, [CDisplayListItem.TYPE_VIDEO]) # with search history, can generate favorite item
-
-    def getLogoPath(self):
-        return RetHost(RetHost.OK, value = [GetLogoDir('iplalogo.png')])
-    
-    def converItem(self, cItem):
-        searchTypesOptions = [] # ustawione alfabetycznie
-        hostLinks = []
-        type = CDisplayListItem.TYPE_UNKNOWN
-        possibleTypesOfSearch = None
-
-        if cItem['type'] == 'category':
-            if cItem['title'] == 'Wyszukaj':
-                type = CDisplayListItem.TYPE_SEARCH
-                possibleTypesOfSearch = searchTypesOptions
-            else:
-                type = CDisplayListItem.TYPE_CATEGORY
-        elif cItem['type'] == 'video':
-            type = CDisplayListItem.TYPE_VIDEO
-            urls = cItem.get('urls', [])
-            for urlItem in urls:
-                hostLinks.append(CUrlItem(urlItem['name'], urlItem['url'], 0))
-            
-        title       =  clean_html( cItem.get('title', '') )
-        description =  clean_html( cItem.get('plot', '') )
-        icon        =  cItem.get('icon', '')
-        hostItem = CDisplayListItem(name = title,
-                                    description = description,
-                                    type = type,
-                                    urlItems = hostLinks,
-                                    urlSeparateRequest = 0,
-                                    iconimage = icon,
-                                    possibleTypesOfSearch = possibleTypesOfSearch)
-        return hostItem
-    
-    def getSearchItemInx(self):
-        # Find 'Wyszukaj' item
-        try:
-            list = self.host.getCurrList()
-            for i in range( len(list) ):
-                if list[i]['category'] == 'Wyszukaj':
-                    return i
-        except:
-            printDBG('getSearchItemInx EXCEPTION')
-            return -1
-
-    def setSearchPattern(self):
-        try:
-            list = self.host.getCurrList()
-            if 'history' == list[self.currIndex].get('name'):
-                pattern = list[self.currIndex]['title']
-                search_type = None
-                self.host.history.addHistoryItem( pattern, search_type)
-                self.searchPattern = pattern
-                self.searchType = search_type
-        except:
-            printDBG('setSearchPattern EXCEPTION')
-            self.searchPattern = ''
-            self.searchType = ''
-        return
-
-
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostipla.py ./IPTVPlayer/hosts/hostipla.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostipla.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/hostipla.py	2015-11-05 22:26:57.913660252 +0100
@@ -0,0 +1,377 @@
+# -*- coding: utf-8 -*-
+
+####################################################################
+# IPLA privacy policy
+# Pobieranie i udostępnianie danych ze źródła ipla przez 
+# podmioty nieuprawnione grozi sankcjami karnymi na 
+# podstawie obowiązujących przepisów karnych (grzywna, 
+# kara ograniczenia wolności albo kara pozbawienia wolności) 
+# oraz konsekwencjami przewidzianymi w przepisach prawa 
+# cywilnego (odszkodowanie w wysokości zasądzonej przez sąd).
+# Zabronione jest pobieranie danych i udostępniania ich na 
+# urządzeniach lub aplikacjach innych niż przygotowane i 
+# wspierane oficjalnie przez Redefine Sp. z o.o.
+####################################################################
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, CFavItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSelOneLink, GetLogoDir, GetCookieDir, byteify
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+# from xml.etree import cElementTree - I would not recommend this XML parser or any other from python
+# XML will be parser using regular expressions due to problem with memory leak, if we use
+# cElementTree event if memory is free using clear method and removing instances by del, 
+# the memory using still grows with each parsing, probably due to fragmentation of memory.
+# The XML is devil's invention :)
+    
+from Components.config import config, ConfigYesNo, ConfigSelection, getConfigListEntry
+from time import time
+from os import path as os_path
+import urllib
+import re
+
+try: import json
+except: import simplejson as json
+###################################################
+
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.iplacachexml      = ConfigSelection(default = "12", choices = [("0", "nigdy"), ("6", "przez 6 godzin"), ("12", "przez 12 godzin"),("24", "przez dzień")])
+config.plugins.iptvplayer.iplaDefaultformat = ConfigSelection(default = "400", choices = [("200", "bitrate: 200"),("400", "bitrate: 400"),("900", "bitrate: 900"),("1900", "bitrate: 1900")])
+config.plugins.iptvplayer.iplaUseDF         = ConfigYesNo(default = True)
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("Używaj danych z pamięci podręcznej:"), config.plugins.iptvplayer.iplacachexml))
+    optionList.append(getConfigListEntry(_("Domyślny format video:"), config.plugins.iptvplayer.iplaDefaultformat))
+    optionList.append(getConfigListEntry(_("Używaj domyślnego format video:"), config.plugins.iptvplayer.iplaUseDF))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Ipla'
+
+class Ipla(CBaseHostClass):
+    HOST       = 'mipla/23'
+    IDENTITY   = 'ver=600&login=common_user&cuid=-11033141'
+    MAIN_URL   = 'http://getmedia.redefine.pl'
+    CAT_URL    = MAIN_URL + '/r/l_x_35_ipla/categories/list/?' + IDENTITY
+    MOV_URL    = MAIN_URL + '/action/2.0/vod/list/?' + IDENTITY + '&category='
+    SEARCH_URL = MAIN_URL + '/vods/search/?vod_limit=150&' + IDENTITY + '&page=0&keywords='
+    
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'ipla'})
+        self.categoryXMLTree = None
+        self.cacheFilePath   = os_path.join(config.plugins.iptvplayer.SciezkaCache.value, "iplaxml.cache")
+        
+    def getStr(self, v, default=''):
+        if None == v:
+            return default
+        elif type(v) == type(u''):
+            return v.encode('utf-8')
+        elif type(v) == type(''):
+            return v
+
+    def __getAttribs(self, data):
+        re_compile = re.compile('([^= ]+?)="([^"]+?)"')
+        item={}
+        attribs = re_compile.findall(data)
+        for attrib in  attribs:
+            item[attrib[0]] = attrib[1]
+        return item
+    
+    def getVideosList(self, url):
+        printDBG("Ipla.getVideosList url[%s]" % url)
+            
+        sts, videosXMLTree = self.cm.getPage(url, {'host' : Ipla.HOST})
+        if sts:
+            videosXMLTree = self.getStr(videosXMLTree).split('</vod>')
+            del videosXMLTree[-1]
+            re_compile_vod    = re.compile('<vod ([^>]+?)>')
+            re_compile_thumbs = re.compile('<thumb ([^>]+?)>')
+            try:
+                for vod in videosXMLTree:
+                    try:
+                        val = re_compile_vod.search(vod)
+                        if not val: continue
+                        val = self.__getAttribs(val.group(1))
+                        title = val.get('title', '')
+                        plot  = val.get('descr', '')
+                        icon  = val.get('thumbnail', '')
+                        try:
+                            thumbs = re_compile_thumbs.findall(vod)
+                            thumbSizePrev = 9999
+                            for thumb in thumbs:
+                                attrib = self.__getAttribs(thumb)
+                                thumbSize = int(attrib['size'].split('x')[0])
+                                if thumbSizePrev > thumbSize:
+                                    thumbSizePrev = thumbSize
+                                    icon = attrib['url']
+                        except: printExc()
+                        urls = self._getVideoUrls(vod)
+                        params = {'category': 'video', 'title': title, 'plot': plot, 'icon':icon, 'urls': urls, 'fav_item':{'url':url, 'vod_id':val.get('id', '')}}
+                        self.addVideo(params)
+                    except: printExc()
+            except: printExc()
+    # end getVideosList
+    
+    def _getVideoUrls(self, vodData):
+        urls = []
+        re_compile_srcreq = re.compile('<srcreq ([^>]+?)>')
+        max_bitrate = int(config.plugins.iptvplayer.iplaDefaultformat.value)
+        def __getLinkQuality( itemLink ):
+            return int(itemLink['bitrate'])
+        try:
+            links = re_compile_srcreq.findall(vodData)
+            for link in links:
+                attrib = self.__getAttribs(link)
+                drm = attrib['drmtype']
+                if drm == '0':
+                    if config.plugins.iptvplayer.ZablokujWMV.value and attrib['format'] == '0':
+                        continue
+                    name = "Jakość: %s\t format: %s\t  bitrate: %s" % (attrib['quality'], attrib['format'], attrib['bitrate'])
+                    urls.append( {'name':name, 'url':attrib['url'], 'bitrate':attrib['bitrate']} )
+        except: printExc()
+        if config.plugins.iptvplayer.iplaUseDF.value and 1 < len(urls):
+            urls = CSelOneLink(urls, __getLinkQuality, max_bitrate).getOneLink()
+        return urls
+    
+    def __writeCategoryCache(self, data):
+        printDBG("__writeCategoryCache ")
+        try:
+            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
+            data = str({"timestamp" : int(time()), "data":data})
+            with open(self.cacheFilePath, 'w') as f:
+                f.write(str(data))            
+        except:
+            printExc()
+    
+    def __readCategoryCache(self):
+        printDBG("__readCategoryCache ")
+        try:
+            data = None
+            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
+            from ast import literal_eval
+            with open(self.cacheFilePath, 'r') as f:
+                data = f.read()
+            data = literal_eval(data)
+            currTimestamp = int(time())
+            saveTimestamp = data["timestamp"]
+            
+            if (currTimestamp - saveTimestamp) / 3600 < int(config.plugins.iptvplayer.iplacachexml.value):
+                data = data["data"]
+                printDBG("__readCategoryCache data from cache valid")
+            else:
+                data = None
+        except:
+            printExc()
+            data = None
+        return data
+        
+    def getCatXmlTree(self, refresh=False):
+        printDBG("setCatXmlTree refresh[%r]" %  refresh)
+        
+        def _fromUrl():
+            sts,data = self.cm.getPage(Ipla.CAT_URL, {'host' : Ipla.HOST})
+            if not sts: data = ''
+            return data
+            
+        if None == self.categoryXMLTree or refresh:
+            try:
+                bFromCache = True
+                data = None
+                if not refresh:
+                    data = self.__readCategoryCache()
+                if None == data:
+                    bFromCache = False
+                    data = _fromUrl()
+                self.categoryXMLTree = self.__simpleCategoryParser(data)
+                if bFromCache and 100 > len(self.categoryXMLTree):
+                    data = _fromUrl()
+                    self.categoryXMLTree = self.__simpleCategoryParser(data)
+                    bFromCache = False
+                if not bFromCache:
+                    self.__writeCategoryCache(data)
+            except:
+                printExc()
+                self.categoryXMLTree = None
+        return self.categoryXMLTree
+        
+    def __simpleCategoryParser(self, data):
+        printDBG("__simpleCategoryParser start")
+        data = re.compile('<cat ([^>]+?)>').findall(data)
+        printDBG("__simpleCategoryParser step 1 finished")
+        for idx in range(len(data)):
+            data[idx] = self.__getAttribs(data[idx])
+        printDBG("__simpleCategoryParser step 2 finished")
+        return data
+        
+    def getCategories(self, parentCatId, refresh):
+        printDBG( "getCategories parentCatId[%s]" % parentCatId )
+        xmlTree = self.getCatXmlTree(refresh)
+        if xmlTree:
+            try:
+                #cats = xmlTree.findall("cat")
+                cats = xmlTree
+                listVideo = False
+                numOfSubCat = 0
+                for cat in cats:
+                    #val = cat.attrib
+                    val = cat
+                    try:
+                        listVideo = True
+                        pid = self.getStr(val.get('pid', ''), '')
+                        catId = self.getStr(val.get('id', ''), '')
+                        if '' in [pid, catId]:
+                            continue
+                        if pid == parentCatId:
+                            numOfSubCat += 1
+                            title = self.getStr(val.get('title', ''), '')
+                            plot  = self.getStr(val.get('descr', ''), '')
+                            icon  = self.getStr(val.get('thumbnail', ''), '')
+                            #check if this is only link to diffrent category
+                            try:
+                                link = self.getStr(val.get('action', ''), '')
+                                linkMarker = "ipla://cmd-cmd=gotocat&catid="
+                                if linkMarker  in link:
+                                    # if this is only linkt to another category, update category id
+                                    catId = link.replace(linkMarker, "")
+                            except: pass
+                            params = {'category': 'category', 'title': title, 'plot': plot, 'icon':icon, 'catId': catId, 'pCatId': pid}
+                            self.addDir(params)
+                        #printDBG("||||||||||||||||: %s" %pid)
+                    except:
+                        printDBG( "getCategories except" )
+                        printExc()
+                if listVideo and numOfSubCat < 2:
+                    self.getVideosList(Ipla.MOV_URL + parentCatId)
+            except: printExc()
+        return
+        
+    def listsMainMenu(self, refresh=False):
+        printDBG('listsMainMenu')
+        self.getCategories('0', refresh)
+        self.addDir( {'category': 'Wyszukaj',  'title': 'Wyszukaj'} )
+        self.addDir( {'category': 'search_history',   'title': 'Historia wyszukiwania'} )
+        
+    def getFavouriteData(self, cItem):
+        return json.dumps(cItem['fav_item'])
+        
+    def getLinksForFavourite(self, fav_data):
+        links = []
+        try: 
+            favItem = byteify( json.loads(fav_data) )
+            printDBG(favItem)
+            sts, data = self.cm.getPage(favItem['url'], {'host' : Ipla.HOST})
+            if sts:
+                sts, data = self.cm.ph.getDataBeetwenReMarkers(data, re.compile('<vod[^>]+?id="%s"[^>]*?>'% favItem['vod_id']), re.compile('</vod>' ), False)
+                if sts: links = self._getVideoUrls(data)
+        except: printExc()
+        return links
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        if 0 == refresh: refresh = False
+        else: refresh = True
+
+        title      = self.currItem.get("title", '')
+        category   = self.currItem.get("category", None)
+        catId      = self.currItem.get("catId", '')
+        pCatId     = self.currItem.get("pCatId", '')
+        icon       = self.currItem.get("icon", '')
+        url        = self.currItem.get("url", '')
+        plot       = self.currItem.get("plot", '')
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| category[%r] " % (category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if category == None:
+            self.listsMainMenu(refresh)
+    #GET SUB CATEGORY
+        elif category == 'category':
+            self.getCategories(catId, refresh)
+    #WYSZUKAJ
+        elif category == 'Wyszukaj':
+            pattern = urllib.quote_plus(searchPattern)
+            self.getVideosList(Ipla.SEARCH_URL + pattern)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "search_history":
+            self.listsHistory()
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Ipla(), True, [CDisplayListItem.TYPE_VIDEO]) # with search history, can generate favorite item
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('iplalogo.png')])
+    
+    def converItem(self, cItem):
+        searchTypesOptions = [] # ustawione alfabetycznie
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            urls = cItem.get('urls', [])
+            for urlItem in urls:
+                hostLinks.append(CUrlItem(urlItem['name'], urlItem['url'], 0))
+            
+        title       =  clean_html( cItem.get('title', '') )
+        description =  clean_html( cItem.get('plot', '') )
+        icon        =  cItem.get('icon', '')
+        hostItem = CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 0,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+        return hostItem
+    
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex].get('name'):
+                pattern = list[self.currIndex]['title']
+                search_type = None
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
+
+
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostXXX.py ./IPTVPlayer/hosts/hostXXX.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/hostXXX.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/hostXXX.py	2015-11-25 11:59:23.302458999 +0100
@@ -0,0 +1,1831 @@
+# -*- coding: utf-8 -*-
+ 
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, CSelOneLink
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+
+###################################################
+# FOREIGN import
+###################################################
+import re, urllib, urllib2, base64, math 
+try:
+    import simplejson
+except:
+    import json as simplejson   
+from Tools.Directories import resolveFilename, SCOPE_PLUGINS
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry, ConfigPIN
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+def GetConfigList():
+    optionList = []
+    return optionList
+###################################################
+
+###################################################
+# Title of HOST
+###################################################
+def gettytul():
+    return 'XXX'
+
+class IPTVHost(IHost):
+    LOGO_NAME = 'XXXlogo.png'
+    PATH_TO_LOGO = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/icons/logos/' + LOGO_NAME )
+
+    def __init__(self):
+        printDBG( "init begin" )
+        self.host = Host()
+        self.prevIndex = []
+        self.currList = []
+        self.prevList = []
+        printDBG( "init end" )
+        
+    def isProtectedByPinCode(self):
+        return True
+    
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [self.PATH_TO_LOGO])
+
+    def getInitList(self):
+        printDBG( "getInitList begin" )
+        self.prevIndex = []
+        self.currList = self.host.getInitList()
+        self.host.setCurrList(self.currList)
+        self.prevList = []
+        printDBG( "getInitList end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        printDBG( "getListForItem begin" )
+        self.prevIndex.append(Index)
+        self.prevList.append(self.currList)
+        self.currList = self.host.getListForItem(Index, refresh, selItem)
+        #self.currList = [ self.prevList[-1][Index] ]
+        printDBG( "getListForItem end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getPrevList(self, refresh = 0):
+        printDBG( "getPrevList begin" )
+        if(len(self.prevList) > 0):
+            self.prevIndex.pop()
+            self.currList = self.prevList.pop()
+            self.host.setCurrList(self.currList)
+            printDBG( "getPrevList end OK" )
+            return RetHost(RetHost.OK, value = self.currList)
+        else:
+            printDBG( "getPrevList end ERROR" )
+            return RetHost(RetHost.ERROR, value = [])
+
+    def getCurrentList(self, refresh = 0):
+        printDBG( "getCurrentList begin" )
+        #if refresh == 1
+        #self.prevIndex[-1] #ostatni element prevIndex
+        #self.prevList[-1]  #ostatni element prevList
+        #tu pobranie listy dla dla elementu self.prevIndex[-1] z listy self.prevList[-1]  
+        printDBG( "getCurrentList end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getLinksForVideo(self, Index = 0, item = None):
+        return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+        
+    def getResolvedURL(self, url):
+        printDBG( "getResolvedURL begin" )
+        if url != None and url != '':        
+            ret = self.host.getResolvedURL(url)
+            if ret != None and ret != '':        
+               printDBG( "getResolvedURL ret: "+ret)
+               list = []
+               list.append(ret)
+               printDBG( "getResolvedURL end OK" )
+               return RetHost(RetHost.OK, value = list)
+            else:
+               printDBG( "getResolvedURL end" )
+               return RetHost(RetHost.NOT_IMPLEMENTED, value = [])                
+        else:
+            printDBG( "getResolvedURL end" )
+            return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+
+    def getSearchResults(self, pattern, searchType = None):
+        return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+
+    ###################################################
+    # Additional functions on class IPTVHost
+    ###################################################
+
+class Host:
+    XXXversion = "18.0.0.0"
+    XXXremote  = "0.0.0.0"
+    currList = []
+    MAIN_URL = ''
+    
+    def __init__(self):
+        printDBG( 'Host __init__ begin' )
+        self.cm = pCommon.common()
+        self.currList = []
+        _url = 'https://gitlab.com/iptv-host-xxx/iptv-host-xxx/blob/master/IPTVPlayer/hosts/hostXXX.py'
+        query_data = { 'url': _url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+        try:
+           data = self.cm.getURLRequestData(query_data)
+           #printDBG( 'Host init data: '+data )
+           r=re.search( r'XXXversion.*?&quot;(.*?)&quot;',data)
+           if r:
+              printDBG( 'r' )
+              self.XXXremote=r.group(1)
+        except:
+           printDBG( 'Host init query error' )
+        printDBG( 'Host __init__ end' )
+        
+    def setCurrList(self, list):
+        printDBG( 'Host setCurrList begin' )
+        self.currList = list
+        printDBG( 'Host setCurrList end' )
+        return 
+
+    def getInitList(self):
+        printDBG( 'Host getInitList begin' )
+        #self.currList = self.MAIN_MENU
+        self.currList = self.listsItems(-1, '', 'main-menu')
+        printDBG( 'Host getInitList end' )
+        return self.currList
+
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        printDBG( 'Host getListForItem begin' )
+        valTab = []
+        if len(self.currList[Index].urlItems) == 0:
+           return valTab
+        valTab = self.listsItems(Index, self.currList[Index].urlItems[0], self.currList[Index].urlSeparateRequest)
+        self.currList = valTab
+        printDBG( 'Host getListForItem end' )
+        return self.currList
+
+    def listsItems(self, Index, url, name = ''):
+        printDBG( 'Host listsItems begin' )
+        printDBG( 'Host listsItems url: '+url )
+        valTab = []
+        if name == 'main-menu':
+           printDBG( 'Host listsItems begin name='+name )
+           #if self.XXXversion <> self.XXXremote and self.XXXremote <> "0.0.0.0":
+              #valTab.append(CDisplayListItem('---UPDATE---','UPDATE MENU',        CDisplayListItem.TYPE_CATEGORY, [''],                                     'UPDATE',  '', None)) 
+           valTab.append(CDisplayListItem('4TUBE',          'www.4tube.com',      CDisplayListItem.TYPE_CATEGORY, ['http://www.4tube.com/tags'],            '4tube',   'http://i.4tube.com/free-porn.png', None)) 
+           valTab.append(CDisplayListItem('EPORNER',        'www.eporner.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.eporner.com/categories/'],   'eporner', 'http://static.eporner.com/new/logo.png', None)) 
+           #valTab.append(CDisplayListItem('TUBE8 mobile',   'm.tube8.com',        CDisplayListItem.TYPE_CATEGORY, ['http://m.tube8.com'],                   'tube8',   'http://cdn1.static.tube8.phncdn.com/images/t8logo.png', None)) 
+           valTab.append(CDisplayListItem('TUBE8',          'www.tube8.com',      CDisplayListItem.TYPE_CATEGORY, ['http://www.tube8.com/categories.html'], 'fulltube8',   'http://cdn1.static.tube8.phncdn.com/images/t8logo.png', None)) 
+           #valTab.append(CDisplayListItem('YOUPORN mobile', 'mobile.youporn.com', CDisplayListItem.TYPE_CATEGORY, ['http://mobile.youporn.com'],            'youporn',               'http://cdn1.static.youporn.phncdn.com/cb/bundles/youpornwebfront/images/l_youporn_black.png', None)) 
+           valTab.append(CDisplayListItem('YOUPORN',        'wwww.youporn.com',   CDisplayListItem.TYPE_CATEGORY, ['http://www.youporn.com/categories/alphabetical/'],'fullyouporn', 'http://cdn1.static.youporn.phncdn.com/cb/bundles/youpornwebfront/images/l_youporn_black.png', None)) 
+           #valTab.append(CDisplayListItem('PORNHUB mobile', 'm.pornhub.com',      CDisplayListItem.TYPE_CATEGORY, ['http://m.pornhub.com'],                 'pornhub', 'http://cdn1.static.pornhub.phncdn.com/images/pornhub_logo.png', None)) 
+           valTab.append(CDisplayListItem('PORNHUB',        'www.pornhub.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.pornhub.com/categories'],    'fullpornhub', 'http://cdn1.static.pornhub.phncdn.com/images/pornhub_logo.png', None)) 
+           valTab.append(CDisplayListItem('HDPORN',         'www.hdporn.net',     CDisplayListItem.TYPE_CATEGORY, ['http://www.hdporn.net/channels/'],      'hdporn',  'http://www.hdporn.net/gfx/logo.gif', None)) 
+           valTab.append(CDisplayListItem('REDTUBE',        'www.redtube.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.redtube.com/channels'],      'redtube', 'http://img02.redtubefiles.com/_thumbs/design/logo/redtube_260x52_black.png', None)) 
+           valTab.append(CDisplayListItem('XHAMSTER',       'xhamster.com',       CDisplayListItem.TYPE_CATEGORY, ['http://xhamster.com/channels.php'],     'xhamster','http://eu-st.xhamster.com/images/tpl2/logo.png', None)) 
+           valTab.append(CDisplayListItem('HENTAIGASM',     'hentaigasm.com',     CDisplayListItem.TYPE_CATEGORY, ['http://hentaigasm.com'],                'hentaigasm','http://hentaigasm.com/wp-content/themes/detube/images/logo.png', None)) 
+           valTab.append(CDisplayListItem('XVIDEOS',        'www.xvideos.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.xvideos.com'],               'xvideos', 'http://img100.xvideos.com/videos/thumbs/xvideos.gif', None)) 
+           valTab.append(CDisplayListItem('XNXX',           'www.xnxx.com',       CDisplayListItem.TYPE_CATEGORY, ['http://www.xnxx.com'],                  'xnxx',    'http://img100.xvideos.com/xnxx.com/pics/xnxx.gif', None)) 
+           valTab.append(CDisplayListItem('PORNWAY',        'www.pornway.com',     CDisplayListItem.TYPE_CATEGORY, ['http://www.pornway.com'],  'pornusy', 'http://www.pornway.com/porno.png', None)) 
+           valTab.append(CDisplayListItem('BEEG',           'beeg.com',           CDisplayListItem.TYPE_CATEGORY, ['http://beeg.com/api/v1/index/main/0/mobile'],                      'beeg',    'http://staticloads.com/img/logo/logo.png', None))
+           valTab.append(CDisplayListItem('PORNRABBIT',     'www.pornrabbit.com', CDisplayListItem.TYPE_CATEGORY, ['http://www.pornrabbit.com/page/categories/'],'pornrabbit','http://cdn1.static.pornrabbit.com/pornrabbit/img/logo.png', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.append(CDisplayListItem('SHOWUP   - live cams',       'showup.tv',          CDisplayListItem.TYPE_CATEGORY, ['http://showup.tv'],                     'showup',  'http://3.bp.blogspot.com/-E6FltqaarDQ/UXbA35XtARI/AAAAAAAAAPY/5-eNrAt8Nyg/s1600/show.jpg', None)) 
+           #valTab.append(CDisplayListItem('ZBIORNIK - live cams',       'zbiornik.com',       CDisplayListItem.TYPE_CATEGORY, ['http://zbiornik.com/live/'],            'zbiornik','http://static.zbiornik.com/images/zbiornikBig.png', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fulltube8' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.tube8.com' 
+           parser = 'http://www.tube8.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('categoriesFooterFontSize(.*?)</ul>', data, re.S)
+           if not parse: return []
+           phCats = re.findall("<a href='(.*?)'.*?>(.*?)<", parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fulltube8-clips', '', None)) 
+           phCats = re.findall('<a href="(.*?)".*?>(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fulltube8-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem('--- Featured videos ---', 'Featured videos', CDisplayListItem.TYPE_CATEGORY, ['http://www.tube8.com'], 'fulltube8-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Hits ---', 'Hits',               CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hits/'],      'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Hot ---', 'Hot',                 CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hot/'],       'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],      'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/new/'],       'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fulltube8-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="thumb-wrapper float-left".*?src="(.*?)".*?href="(.*?)".*?title="(.*?)".*?<strong>(.*?)</strong>', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle, phTime ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phTime: ' +phTime )                  
+                  valTab.append(CDisplayListItem(phTitle,'['+phTime+']'+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('id="pagination_next" href="(.*?)">NEXT<', data, re.S)
+           if match:
+              phUrl = match[-1]
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.xnxx.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('ALL SEX VIDEOS:(.*?)<a href="http://www.xnxx.com/tags/">More', data, re.S)
+           if not parse: return valTab
+           phCats = re.findall('<a href="(.*?)">(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'xnxx-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem('--- Tags alfabetical ---',  'Tags',         CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/tags/'],      'xnxx-tagsalfa', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Hits ---', 'Hits',               CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hits/'],      'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Hot ---', 'Hot',                 CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hot/'],       'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],      'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/new/'],       'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx-tagsalfa' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<td align=left nowrap><a href="(.*?)">(.*?)</a>(.*?)<', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phCount) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phCount: '+phCount )
+                  valTab.append(CDisplayListItem(phTitle+': '+phCount,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           if not data: return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           try: phMovies = re.findall('<li><div align="center">.*?href="(.*?)".*?src="(.*?)".*?title="(.*?)".*?#5C99FE">(.*?)<', data, re.S)
+           except:
+              printDBG( 'Host listsItems phmovies error' )
+              return valTab           
+           #printDBG( 'Host listsItems phmovies ' )
+           if phMovies:
+              for (phUrl, phImage, phTitle, phTime ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phTime: ' +phTime )                  
+                  phTitle = decodeHtml(phTitle)
+                  valTab.append(CDisplayListItem(phTitle,phTime+'\n'+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<a class="nP" href="(.*?)">Next<', data, re.S)
+           if match:
+              phUrl = match[-1]
+              if phUrl[0] <> '/'[0]:
+                 phUrl = '/'+phUrl
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'zbiornik' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://zbiornik.com' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'zbiornik.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://zbiornik.com/#ENTER', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           #printDBG( 'Host listsItems data cookie: '+data )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           ph1 = re.search('var streams=(.*?)}];', data, re.S)
+           if ph1: ph1 = ph1.group(1)+'}]'
+           result = simplejson.loads(ph1)
+           if result:
+              for item in result:
+                  printDBG( 'Host listsItems nick: '+item["nick"] )
+                  printDBG( 'Host listsItems broadcasturl: '+item["broadcasturl"] )
+                  printDBG( 'Host listsItems topic: '+item["topic"] )
+                  printDBG( 'Host listsItems goalDsc: '+item["goalDsc"] )
+                  phImage = 'http://cm2.zbiornik.com/cams/'+str(item["broadcasturl"])+'-224.jpg'
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  streamUrl = 'rtmp://'+str(item["server"])[0]+''+str(item["server"])[1:]+'/videochat playpath='+str(item["broadcasturl"])+' swfUrl=http://zbiornik.com/wowza.swf?v42 pageUrl=http://zbiornik.com/live/'
+                  printDBG( 'Host listsItems streamUrl: '+streamUrl )
+                  valTab.append(CDisplayListItem(str(item["nick"]),str(item["topic"])+' ; '+str(item["goalDsc"]),CDisplayListItem.TYPE_VIDEO, [CUrlItem('', streamUrl, 0)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'showup' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://showup.tv' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'showup.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://showup.tv/site/accept_rules/yes?ref=http://showup.tv/', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="stream-meta".*?data-original="(.*?)".*?href="(.*?)".*?class="stream-name">(.*?)<.*?class="stream-desc">(.*?)<', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle, phDesc ) in phMovies:
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phDesc: '+phDesc )
+                  phImage = self.MAIN_URL+'/'+phImage
+                  valTab.append(CDisplayListItem(phTitle,phDesc,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xvideos' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.xvideos.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('id="categories"(.*?)</div>', data, re.S)
+           phCats = re.findall('<a href="(.*?)">(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xvideos-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.insert(0,CDisplayListItem('--- Pornstars ---',   'Pornstars',   CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/pornstars'], 'xvideos-pornstars', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],     'xvideos-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],              'xvideos-clips', '', None)) 
+
+           #valTab.append(CDisplayListItem('Best Videos', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/channels'],  'xvideos-clips', '', None)) 
+           #valTab.append(CDisplayListItem('Best Videos', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'], 'xvideos-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xvideos-pornstars' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="thumbProfile".*?href="(.*?)".*?img src="(.*?)".*?href=".*?">(.*?)<', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '  +phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xvideos-clips', phImage, None)) 
+        if 'xvideos-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="thumb".*?img src="(.*?)".*?href="(.*?)" title="(.*?)"', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle ) in phMovies:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  phTitle = decodeHtml(phTitle)
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<li><a class="nP" href="(.*?)"', data, re.S)
+           if match:
+              phUrl = match[-1]
+              if phUrl[0] <> '/'[0]:
+                 phUrl = '/'+phUrl
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hentaigasm' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://hentaigasm.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('Genres(.*?)</div></div>', data, re.S)
+           if not parse: return valTab
+           phCats = re.findall("<a href='(.*?)'.*?>(.*?)<", parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'hentaigasm-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- New ---", "New",        CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL], 'hentaigasm-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hentaigasm-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="thumb">.*?title="(.*?)" href="(.*?)".*?<img src="(.*?)"', data, re.S)
+           if phMovies:
+              for (phTitle, phUrl, phImage) in phMovies:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  #phImage.replace(' ','%20')
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.search("<div class='wp-pagenavi'>(.*?)</div>", data, re.S)
+           if match: match = re.findall("href='(.*?)'", match.group(1), re.S)
+           if match:
+                  phUrl = match[-1]
+                  #printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullyouporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.youporn.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           #phCats = re.findall('class="cat_pic">.*?<a\shref="/category(.*?)".*?<img\ssrc="(.*?)"\salt="(.*?)"><span\sclass="cat_overlay', data, re.S)
+           phCats = re.findall('<li\sclass=\'.*?\'><a\shref="/category/(.*?)">(.*?)</a', data, re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  #printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  phUrl = self.MAIN_URL+"/category/" + phUrl
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fullyouporn-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.insert(0,CDisplayListItem("--- Channels ---",           "Channels",           CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/channels/most_subscribed/alltime/"], 'fullyouporn-channels', '',None))
+           #valTab.insert(0,CDisplayListItem("Popular by Country", "Popular by Country", CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/categories/"],                       'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Discussed ---",     "Most Discussed",     CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_discussed/"],                   'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Favorited ---",     "Most Favorited",     CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_favorited/"],                   'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Viewed ---",        "Most Viewed",        CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_viewed/"],                      'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Top Rated ---",          "Top Rated",          CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/top_rated/"],                        'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- New ---",                "New",                CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/"],                                  'fullyouporn-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullyouporn-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('class=\'row video-row\'>(.*?)class=\'footer', data, re.S)
+           if not parse:
+              parse = re.search('class=\'title-bar(.*?)class=\'footer', data, re.S) 
+           phMovies = re.findall('class=\'video-box.*?<a\shref="(.*?)".*?<img\ssrc=".*?"\salt=\'(.*?)\'.*?data-(thumbnail|echo)="(.*?)".*?class=\'video-box-percentage\sup\'>(.*?)</span>.*?class="video-box-duration">(.*?)</span>', parse.group(1), re.S)
+           if phMovies:
+              for (phUrl, phTitle, phdummy, phImage, phViews, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  phUrl = phUrl.replace("&amp;","&")
+                  valTab.append(CDisplayListItem(decodeHtml(phTitle),'['+phRuntime+'] ['+phViews+'] '+decodeHtml(phTitle),CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<nav id="pagination">.*?</nav>', data, re.S)
+           if match:
+              #printDBG( 'Host listsItems page match: '+match[0] )
+              match = re.findall('href="(.*?)"', match[0], re.S)
+           if match:
+                  phUrl = match[-1]
+                  #printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'redtube' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.redtube.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="video">.*?<a href="(.*?)" title="(.*?)">.*?data-src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'redtube-clips', phImage, None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Most Favored ---", "Most Favored", CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/mostfavored?period=alltime"], 'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Viewed ---",  "Most Viewed",  CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/mostviewed?period=alltime"],  'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---",    "Top Rated",    CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/top?period=alltime"],         'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Newest ---",       "Newest",       CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/"],                           'redtube-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'redtube-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="video-duration".*?>(.*?)<.*?data-src="(.*?)".*?<a href="(.*?)" title="(.*?)".*?<span class="video-views">(.*?)<', data, re.S)
+           if phMovies:
+              for (phRuntime, phImage, phUrl, phTitle, phViews) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] ['+phViews+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<link rel="next" href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xhamster' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://xhamster.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('id="letter_A">(.*?)id="footer">', data, re.S)
+           phCats = re.findall('href="(.*?)">(.*?)<div.*?</a>', parse.group(1), re.S|re.I)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  phTitle = phTitle.strip(' ')
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'xhamster-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- New ---",       "New",       CDisplayListItem.TYPE_CATEGORY,["http://xhamster.com/"], 'xhamster-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xhamster-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           if re.search('vDate', data, re.S):
+              parse = re.search('<div\sclass=\'vDate(.*)</html>', data, re.S)
+           else:
+              parse = re.search('<html>(.*)</html>', data, re.S)
+           phMovies = re.findall('class=\'video\'><a\shref=\'(.*?/movies/.*?)\'.*?class=\'hRotator\'\s><img\ssrc=\'(.*?)\'.*?alt="(.*?)".*?start2.*?<b>(.*?)</b>', parse.group(1), re.S)
+           if phMovies:
+              for (phUrl, phImage, phTitle, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall("<div class='pager'>.*?>Next<", data, re.S)
+           if match:
+              match = re.findall("href='(.*?)'", match[0], re.S)
+           if match:
+                  phUrl = match[-1]
+                  printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'eporner' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.eporner.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="categoriesbox" id=".*?"><a href="(.*?)" title="(.*?)"><img src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  phTitle = phTitle.replace(' movies', '')
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'eporner-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- HD ---",        "HD",        CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/hd/"], 'eporner-clips', '','/hd/'))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---", "Top Rated", CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/top_rated/"], 'eporner-clips', '','/top_rated/'))
+           valTab.insert(0,CDisplayListItem("--- Popular ---",   "Popular",   CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/weekly_top/"], 'eporner-clips', '','/weekly_top/'))
+           valTab.insert(0,CDisplayListItem("--- On Air ---",    "On Air",    CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/currently/"], 'eporner-clips', '','/currently/'))
+           valTab.insert(0,CDisplayListItem("--- New ---",       "New",       CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/"], 'eporner-clips', '',''))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'eporner-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="mbtit".*?><a href="(.*?)" title="(.*?)".*?src="(.*?)".*?"mbtim">(.*?)</div>', data, re.S)
+           if phMovies:
+                 for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<center> <div class="numlist2">.*?</center>', data, re.S)
+           if match:
+              printDBG( 'Host listsItems page match: '+match[0] )
+              match = re.findall("<a href='(.*?)' title='(.*?)'", match[0], re.S)
+           if match:
+              for (phUrl, phTitle) in match:
+                  printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  printDBG( 'Host listsItems page phTitle: '+phTitle )
+                  if phTitle == 'Next page':
+                     valTab.append(CDisplayListItem(phTitle, 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullpornhub' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornhub.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<div\sclass="category-wrapper">.*?<a\shref="(/video\?c=.*?)".*?<img\ssrc="(.*?)".*?alt="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'fullpornhub-clips', phImage, None)) 
+                  valTab.sort()
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- HD ---",         "HD",          CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?c=38"], 'fullpornhub-clips', 'http://cdn1a.static.pornhub.phncdn.com/images/categories/38.jpg',None))
+           valTab.insert(0,CDisplayListItem("--- Longest ---",    "Longest",     CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=lg"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---",  "Top Rated",   CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=tr"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Viewed ---","Most Viewed", CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=mv"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Recent ---","Most Recent", CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=mr"], 'fullpornhub-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullpornhub-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div\sclass="wrap">.*?<a\shref="(.*?)".*?\stitle="(.*?)".*?data-mediumthumb="(.*?)".*?<var\sclass="duration">(.*?)</var>.*?<span\sclass="views"><var>(.*?)<.*?<var\sclass="added">(.*?)<', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime, phViews, phAdded) in phMovies:
+                  phUrl = self.MAIN_URL+phUrl
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  printDBG( 'Host listsItems phAdded: '+phAdded )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] [ Views: '+phViews+'] [Added: '+phAdded+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<li class="page_next"><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0].replace('&amp;','&')], name, '', None))        
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.4tube.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('All categories(.*?)</div></div>', data, re.S)
+           if not parse: return []
+           phCats = re.findall('<li><a href="(.*?)" title=".*?">(.*?)<span>', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  phTitle = phTitle.strip()
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  phTitle = phTitle.title()
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'4tube-clips', '', None)) 
+           #valTab.sort()
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Channels ---","Channels",   CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/channels"]  ,         '4tube-channels', '',None))
+           valTab.insert(0,CDisplayListItem("--- Pornstars ---","Pornstars", CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/pornstars"],          '4tube-pornstars','',None))
+           valTab.insert(0,CDisplayListItem("--- Most viewed ---","Most viewed",     CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos?sort=views&time=month"],             '4tube-clips',    '',None))
+           valTab.insert(0,CDisplayListItem("--- Highest Rated ---","Highest Rated", CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos?sort=rating&time=month"],             '4tube-clips',    '',None))
+           valTab.insert(0,CDisplayListItem("--- Lastest ---","Lastest",     CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos"],             '4tube-clips',    '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-channels' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<a class="thumb-link" href="(.*?)" title="(.*?)".*?<i class="icon icon-video"></i>(.*?)<.*?<img data-original="(.*?)"',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phVid, phImage ) in phMovies:           
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phVid: '+phVid )
+                  valTab.append(CDisplayListItem(phTitle,'[Video: '+phVid+'] '+phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl], '4tube-clips', phImage, None)) 
+           match = re.findall('<ul class="pagination">.*?</a></li><li><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-pornstars' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<a class="thumb-link" href="(.*?)" title="(.*?)".*?<i class="icon icon-video"></i>(.*?)<.*?<img data-original="(.*?)"',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phVid, phImage ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phVid: '+phVid )
+                  valTab.append(CDisplayListItem(phTitle,'[Video: '+phVid+'] '+phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl], '4tube-clips', phImage, None)) 
+           match = re.findall('<ul class="pagination">.*?</a></li><li><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="col thumb_video".*?href="(.*?)".*?title="(.*?)".*?<img data-master="(.*?)".*?class="duration-top">(.*?)<',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,phRuntime+' '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<a class="page " href="(.*?)"', data, re.S)
+           if match:
+              for (phPageUrl) in match: 
+                  printDBG( 'Host listsItems phPageUrl: '  +phPageUrl )
+                  valTab.append(CDisplayListItem('Page', phPageUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phPageUrl], name, '', None))                
+           match = re.findall('<a class="last" href="(.*?)" title="Last page">', data, re.S)
+           if match:
+              for (phPageUrl) in match: 
+                  printDBG( 'Host listsItems phPageUrl: '  +phPageUrl )
+                  valTab.append(CDisplayListItem('Last Page', phPageUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phPageUrl], name, '', None))                
+           match = re.findall('<link rel="next" href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hdporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.hdporn.net'
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="content">.*?href="(.*?)".*?src="(.*?)".*?alt="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'hdporn-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---","Top Rated",           CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+"/top-rated/"]  , 'hdporn-clips','',phUrl))
+           valTab.insert(0,CDisplayListItem("--- Most Popular ---","Most Popular",     CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+"/most-viewed/"], 'hdporn-clips','',phUrl))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hdporn-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           printDBG( 'Host listsItems cat-url: '+catUrl )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="content.*?<a href="(.*?)" title="(.*?)".*?src="(.*?)".*?TIME:  (.*?)</div>', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<div id="pagination">.*?</div>', data, re.S)
+           if not match: return valTab
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           #printDBG( 'Host listsItems match: '+match[0])
+           match = re.findall("</a><a href='(.*?)'>", match[0], re.S)
+           if not match: return valTab
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           #printDBG( 'Host listsItems match: '+match[0])
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+catUrl+match[0]], 'hdporn-clips', '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://m.tube8.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'tube8-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'tube8-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<div class="scene_box">.+?background: url(.+?) no-repeat.+?style="margin: 0;".+?<a href="(.+?)" class="bold".+?[\t]*(.+?)<span style=.+?<p>(.+?)</p>.+?<div style="float: right;" class="bold"><span>(.+?)</span>.+?<div class="clear"></div>', re.DOTALL).findall(data)
+           if len(match) == 0:
+              match = re.compile('<div class="scene_box">.+?background: url(.+?) no-repeat.+?style="margin: 0;".+?<a href="(.+?)" class="bold".+?[\t]*(.+?)</a>.+?<p>(.+?)</p>.+?<div style="float: right;" class="bold"><span>(.+?)</span>.+?<div class="clear"></div>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2], '['+match[i][4]+'] ['+match[i][3]+'] '+match[i][2], CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'tube8-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'tube8-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://mobile.youporn.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'youporn-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'youporn-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile(   '<div class="video_box".+?background: url(.+?) no-repeat.+?<h2 class="h5"><a href="(.+?)">\n(.+?)          .+?<span>Length:.+?[\t]*(.+?)[\t]*</p>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2].replace('<br />',' '), '['+match[i][3]+'] '+match[i][2].replace('<br />',' '), CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'youporn-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'youporn-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://m.pornhub.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'pornhub-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'pornhub-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<div class="video_box".+?background: url(.+?) no-repeat.+?<h2 class="h5"><a href="(.+?)" >(.+?)</a></h2>.+?<span>Length:.+?[\t]*(.+?)[\t]*</p>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2].replace('<br />',' '), '['+match[i][3]+'] '+match[i][2].replace('<br />',' '), CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'pornhub-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'pornhub-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           valTab.append(CDisplayListItem(self.XXXversion+' - Local version',   'Local  XXXversion', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           valTab.append(CDisplayListItem(self.XXXremote+ ' - Remote version',  'Remote XXXversion', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           valTab.append(CDisplayListItem('ZMIANY W WERSJI',                    'ZMIANY W WERSJI',   CDisplayListItem.TYPE_CATEGORY, ['https://gitlab.com/iptv-host-xxx/iptv-host-xxx/commits/master.atom'], 'UPDATE-ZMIANY', '', None)) 
+           valTab.append(CDisplayListItem('Update Now',                         'Update Now',        CDisplayListItem.TYPE_CATEGORY, [''], 'UPDATE-NOW',    '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE-ZMIANY' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try:
+              data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall("<entry>.*?<title>(.*?)</title>.*?<updated>(.*?)</updated>.*?<name>(.*?)</name>", data, re.S)
+           if phCats:
+              for (phTitle, phUpdated, phName ) in phCats:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUpdated: '+phUpdated )
+                  printDBG( 'Host listsItems phName: '+phName )
+                  valTab.append(CDisplayListItem(phUpdated+' ' +phName,phTitle,CDisplayListItem.TYPE_CATEGORY, [''],'', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE-NOW' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           import os
+           _url = 'https://gitlab.com/iptv-host-xxx/iptv-host-xxx/repository/archive.tar.gz?ref=master'              
+           output = open('/tmp/iptv-host-xxx.tar.gz','wb')
+           query_data = { 'url': _url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              output.write(self.cm.getURLRequestData(query_data))
+              output.close()
+              os.system('sync')
+           except:
+              if os.path.exists('/tmp/iptv-host-xxx.tar.gz'):
+                 os.remove('/tmp/iptv-host-xxx.tar.gz')
+              printDBG( 'Błąd pobierania master.tar.gz' )
+              valTab.append(CDisplayListItem('ERROR - Blad pobierania: '+_url,   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab           
+           try: 
+              os.system('cd /tmp; tar -xzf iptv-host-xxx.tar.gz; sync')
+           except:
+              printDBG( 'Błąd rozpakowania iptv-host-xxx.tar.gz' )
+              os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+              os.system('rm -rf /tmp/iptv-host-xxx*')
+              valTab.append(CDisplayListItem('ERROR - Blad rozpakowania /tmp/iptv-host-xxx.tar.gz',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab
+           #if not os.path.exists('/tmp/iptv-host-xxx*/IPTVPlayer'):
+           #   printDBG( 'Niepoprawny format pliku /tmp/iptv-host-xxx.tar.gz' )
+           #   os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+           #   os.system('rm -rf /tmp/iptv-host-xxx*')
+           #   valTab.append(CDisplayListItem('ERROR - Niepoprawny format pliku /tmp/iptv-host-xxx.tar.gz',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           #   return valTab           
+           try:
+              os.system('cp -rf /tmp/iptv-host-xxx*/IPTVPlayer/* /usr/lib/enigma2/python/Plugins/Extensions/IPTVPlayer/')
+              os.system('sync')
+           except:
+              printDBG( 'blad kopiowania' )
+              os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+              os.system('rm -rf /tmp/iptv-host-xxx*')
+              valTab.append(CDisplayListItem('ERROR - blad kopiowania',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab
+               
+           valTab.append(CDisplayListItem('Update End. Please manual restart enigma2',   'Restart', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+           os.system('rm -rf /tmp/iptv-host-xxx*')
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'pornusy' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornway.com' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'pornusy.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://showup.tv/site/accept_rules/yes?ref=http://showup.tv/', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return valTab
+           phMovies = re.findall('<li class="video".*?<a href="(.*?)" title="(.*?)".*?data-src="(.*?)"', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage ) in phMovies:
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall("link rel='next' href='(.*?)'", data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Page: '+match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'youporn-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'youporn-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'beeg' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://beeg.com/api/v1/index/main/0/mobile' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           self.tags = 'popular'
+           self.page = 1
+           parse = re.search('"%s":\[(.*?)\]' % self.tags, data, re.S)
+           if parse:
+              phCats = re.findall('"(.*?)"', parse.group(1), re.S)
+              if phCats:
+                 for phTitle in phCats:
+                     phUrl = 'http://beeg.com/api/v1/index/tag/$PAGE$/mobile?tag=%s' % phTitle
+                     phUrl = phUrl.replace('$PAGE$', '%s' % str(self.page-1))
+                     printDBG( 'Host listsItems phUrl: '  +phUrl )
+                     printDBG( 'Host listsItems phTitle: '+phTitle )
+                     valTab.append(CDisplayListItem(phTitle,phUrl,CDisplayListItem.TYPE_CATEGORY, [phUrl],'beeg-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'beeg-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phVideos = re.findall('\{"title":"(.*?)","id":"(.*?)",(.*?),"ps_name"', data, re.S)
+           if phVideos:
+              for (phTitle, phVideoId, phUrl) in phVideos:
+                 bestUrl = re.findall(':"(.*?)"', phUrl)
+                 if bestUrl:
+                    phUrl = 'http:%s' % bestUrl[-1]
+                 phUrl = phUrl.replace('{DATA_MARKERS}','data=pc.DE')
+                 phImage = 'http://img.beeg.com/236x177/%s.jpg' % phVideoId
+                 printDBG( 'Host listsItems phUrl: '  +phUrl )
+                 printDBG( 'Host listsItems phTitle: '+phTitle )
+                 printDBG( 'Host listsItems phImage: '+phImage )
+                 valTab.append(CDisplayListItem(phTitle,phUrl,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 0)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'pornrabbit' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornrabbit.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<div class="cat">.*?href="(.*?)".*?<h2>(.*?)<small>(.*?)<.*?img src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle,phTitle2,phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle+phTitle2,phUrl,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'pornrabbit-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Most Recent ---", "Most Recent", CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+'/videos/'], 'pornrabbit-clips', '','/videos/'))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornrabbit-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           x = 0
+           Movies = re.findall('class="video">.*?<a href="(.*?)" title="(.*?)".*?<img.*?src="(.*?)".*?views: <b>(.*?)</b>.*?runtime: <b>(.*?)</b>', data, re.S)
+           if Movies:
+              for (Url, Title, Image, Views, Runtime) in Movies:
+                  valTab.append(CDisplayListItem(decodeHtml(Title),'['+Runtime+'] ['+Views+' views]',CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+Url, 1)], 0, Image, None)) 
+                  x = x + 1
+           match = re.findall(r'&nbsp;<a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', self.MAIN_URL+catUrl+match[0].replace(r'../',''), CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+catUrl+match[0].replace(r'../','')], name, '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        return valTab
+
+    def getParser(self, url):
+        printDBG( 'Host getParser begin' )
+        printDBG( 'Host getParser mainurl: '+self.MAIN_URL )
+        printDBG( 'Host getParser url    : '+url )
+        if self.MAIN_URL == 'http://www.pornrabbit.com':    return self.MAIN_URL
+        if self.MAIN_URL == 'http://beeg.com':              return self.MAIN_URL
+        if url.startswith('http://www.pornway.com'):         return 'http://www.pornway.com'
+        if url.startswith('http://www.tube8.com/embed/'):   return 'http://www.tube8.com/embed/'
+        if url.startswith('http://www.tube8.com'):          return 'http://www.tube8.com'
+        if self.MAIN_URL == 'http://www.tube8.com':         return self.MAIN_URL
+        if url.startswith('http://embed.redtube.com'):      return 'http://embed.redtube.com'
+        if url.startswith('http://www.redtube.com'):        return 'http://www.redtube.com'
+        if self.MAIN_URL == 'http://www.redtube.com':       return self.MAIN_URL
+        if url.startswith('http://www.youporn.com/embed/'): return 'http://www.youporn.com/embed/'
+        if url.startswith('http://www.youporn.com'):        return 'http://www.youporn.com'
+        if self.MAIN_URL == 'http://www.youporn.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://showup.tv':             return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.xnxx.com':          return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.xvideos.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://hentaigasm.com':        return self.MAIN_URL
+        if self.MAIN_URL == 'http://xhamster.com':          return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.eporner.com':       return self.MAIN_URL
+        if url.startswith('http://www.pornhub.com/embed/'): return 'http://www.pornhub.com/embed/'
+        if url.startswith('http://www.pornhub.com'):        return 'http://www.pornhub.com'
+        if self.MAIN_URL == 'http://www.pornhub.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.4tube.com':         return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.hdporn.net':        return self.MAIN_URL
+        if self.MAIN_URL == 'http://m.tube8.com':           return self.MAIN_URL
+        if self.MAIN_URL == 'http://mobile.youporn.com':    return self.MAIN_URL
+        if self.MAIN_URL == 'http://m.pornhub.com':         return self.MAIN_URL
+        if url.startswith('http://www.xnxx.com'):           return 'http://www.xnxx.com'
+        if url.startswith('http://www.xvideos.com'):        return 'http://www.xvideos.com'
+        if url.startswith('http://hentaigasm.com'):         return 'http://hentaigasm.com'
+        if url.startswith('http://xhamster.com'):          return 'http://xhamster.com'
+        if url.startswith('http://www.eporner.com'):       return 'http://www.eporner.com'
+        if url.startswith('http://www.4tube.com'):         return 'http://www.4tube.com'
+        if url.startswith('http://www.hdporn.net'):        return 'http://www.hdporn.net'
+        if url.startswith('http://m.tube8.com'):           return 'http://m.tube8.com'
+        if url.startswith('http://mobile.youporn.com'):    return 'http://mobile.youporn.com'
+        if url.startswith('http://m.pornhub.com'):         return 'http://m.pornhub.com'
+        return ''
+
+    def getResolvedURL(self, url):
+        printDBG( 'Host getResolvedURL begin' )
+        printDBG( 'Host getResolvedURL url: '+url )
+        videoUrl = ''
+        parser = self.getParser(url)
+        printDBG( 'Host getResolvedURL parser: '+parser )
+        if parser == '': return ''
+
+        if parser == 'http://www.pornway.com':
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'pornusy.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return ''
+           #printDBG( 'Host getResolvedURL data: '+data )
+           parse = re.search('<iframe src="(.*?)"', data, re.S)
+           if parse:
+              if parse.group(1).startswith('http://www.pornway.com'):
+                 printDBG( 'Host getResolvedURL pornway.com: zapetlony parser: '+parse.group(1) )
+                 return ''
+              return self.getResolvedURL(parse.group(1))
+           else: return ''
+
+        if parser == 'http://showup.tv':
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'showup.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return ''
+           #printDBG( 'Host getResolvedURL data: '+data )
+           parse = re.search("var streamID = '(.*?)'.*?var srvE = '(.*?)'", data, re.S)
+           if parse:
+              printDBG( 'Host gr1: '+ parse.group(1))
+              printDBG( 'Host gr2: '+ parse.group(2))
+              videoUrl = parse.group(2)+' playpath='+parse.group(1)+' swfUrl=http://showup.tv/flash/suStreamer.swf?cache=20&autoReconnect=1&id='+parse.group(1)+'&swfObjectID=video&sender=false&token=&address='+parse.group(2)[7:-9]+'@liveedge live=1 pageUrl='+url+ ' conn=S:OK --live'
+              #videoUrl = parse.group(2)+' playpath='+parse.group(1)+' swfUrl=http://showup.tv/flash/suStreamer.swf?cache=10&id='+parse.group(1)+'&swfObjectID=video&sender=false&token=&address='+parse.group(2)[7:-9]+'@liveedge live=1 pageUrl='+url
+              printDBG( 'Host videoUrl: '+ videoUrl)
+              return videoUrl
+           return ''
+        
+        if parser == 'http://www.tube8.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r""))
+        
+        if parser == 'http://www.youporn.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r"watch/"))
+
+        if parser == 'http://www.pornhub.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r"view_video.php?viewkey="))
+
+        query_data = {'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        try:
+           data = self.cm.getURLRequestData(query_data)
+           #printDBG( 'Host getResolvedURL data: '+data )
+        except:
+           printDBG( 'Host getResolvedURL query error' )
+           return videoUrl
+
+        if parser == 'http://www.pornrabbit.com':
+           videoPage = re.findall("file: '(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://beeg.com':
+           videoPage = re.findall("'file': '(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://www.tube8.com':
+           match = re.findall('"quality_\d+p":"(http.*?)"', data)
+           if not match: match = re.compile('"quality_720p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_480p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_240p":"([^"]+)"').findall(data)
+           if not match: return ''
+           fetchurl = urllib2.unquote(match[0])
+           fetchurl = fetchurl.replace(r"\/",r"/")
+           printDBG( 'Host getResolvedURL fetchurl: '+fetchurl )
+           return fetchurl 
+
+        if parser == 'http://www.xnxx.com':
+           videoUrl = re.search('flv_url=(.*?)&', data, re.S)
+           if videoUrl: return decodeUrl(videoUrl.group(1))
+           return ''
+
+        if parser == 'http://www.xvideos.com':
+           videoUrl = re.search('flv_url=(.*?)&', data, re.S)
+           if videoUrl: return decodeUrl(videoUrl.group(1))
+           return ''
+
+        if parser == 'http://hentaigasm.com':
+           videoUrl = re.search('<div id="player_1111"></div>.*?file: "(.*?)"', data, re.S)
+           if videoUrl: return videoUrl.group(1)
+           return ''
+
+        if parser == 'http://www.youporn.com':
+           match = re.findall(r'encryptedQuality720URL\s=\s\'([a-zA-Z0-9+/]+={0,2})\',', data)
+           if match:
+              fetchurl = urllib2.unquote(match[0])
+              printDBG( 'Host getResolvedURL fetchurl: '+fetchurl )
+              match = re.compile("video_title = '(.*?)'").findall(data)
+              if match:
+                 title = urllib.unquote_plus(match[0])
+                 #title = '%s_720p' % title
+                 printDBG( 'Host getResolvedURL title: '+title )
+                 printDBG( 'Host getResolvedURL decrypt begin ' )
+                 phStream = decrypt(fetchurl, title, 32)
+                 if phStream: 
+                    printDBG( 'Host getResolvedURL decrypted url: '+phStream )
+                    return phStream
+           videoPage = re.findall("\d\d\d:\s'(http.*?)'", data, re.S)
+           if videoPage:
+              videos = videoPage[-1] 
+              videos = urllib.unquote(videos)
+              videos = videos.replace('&amp;','&')
+              printDBG( 'Host getResolvedURL normal url: '+videos )
+              return videos
+           return ''
+
+        if parser == 'http://embed.redtube.com':
+           videoPage = re.findall("<source src='(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://www.redtube.com':
+           videoPage = re.findall('<source\ssrc="(.*?)"\stype="video/mp4">', data, re.S)
+           if videoPage:
+              videos = '%s' % (videoPage[0])
+              videos = urllib.unquote(videos)
+              videos = videos.replace(r"\/",r"/")
+              return videos
+           return ''
+
+        if parser == 'http://xhamster.com':
+           xhFile = re.findall('"file":"(.*?)"', data)
+           if xhFile: return xhFile[0].replace(r"\/",r"/")
+           else: return ''
+        
+        if parser == 'http://www.eporner.com':
+           videoPage = re.findall("mediaspace --> <script>.*?getScript.*?'(.*?)'", data, re.S)
+           if not videoPage: return ''
+           xml = parser+videoPage[0]
+           printDBG( 'Host getResolvedURL xml: '+xml )
+           try:    data = self.cm.getURLRequestData({'url': xml, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True})
+           except: 
+                   printDBG( 'Host getResolvedURL query error xml' )
+                   return videoUrl
+           videoPage = re.findall('file: ?"(.*?)"', data, re.S)
+           if videoPage: return videoPage[0]
+           return ''
+
+        if parser == 'http://www.pornhub.com/embed/':
+           match = re.findall("container.*?src.*?'(.*?)'", data, re.S)
+           if match: return match[0]
+           return ''
+        
+        if parser == 'http://www.pornhub.com':
+           match = re.compile('"video_url":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_720p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_480p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_240p":"([^"]+)"').findall(data)
+           if not match: match = re.compile("quality_720p = '(.*?)'").findall(data)
+           if not match: match = re.compile("quality_480p = '(.*?)'").findall(data)
+           if not match: match = re.compile("quality_240p = '(.*?)'").findall(data)
+           if not match: 
+                         printDBG( 'Host getResolvedURL not match' )  
+                         return ''
+           return match[0]   
+
+        if parser == 'http://www.4tube.com':
+           #printDBG( 'Host getResolvedURL data: '+data )
+           videoID = re.findall('data-id="(\d+)".*?data-quality="(\d+)"', data, re.S)
+           if videoID:
+              res = ''
+              for x in videoID:
+                  res += x[1] + "+"
+              res.strip('+')
+              posturl = "%s/%s/desktop/%s" % (parser.replace('www','tkn'), videoID[-1][0], res)
+              printDBG( 'Host getResolvedURL posturl: '+posturl )
+              try:
+                 data = self.cm.getURLRequestData({'url': posturl, 'header': {'Origin':'http://www.4tube.com'},'use_host': False, 'use_cookie': False, 'use_post': True, 'return_data': True},{})
+              except:
+                 printDBG( 'Host getResolvedURL query error posturl' )
+                 return ''
+              #printDBG( 'Host getResolvedURL posturl data: '+data )
+              videoUrl = re.findall('token":"(.*?)"', data, re.S)
+              if videoUrl: return videoUrl[-1]                 
+              else: return ''
+           else: return ''
+        
+        if parser == 'http://www.hdporn.net':
+           match = re.findall('source src="(.*?)"', data, re.S)
+           if match: return match[0]
+           else: return ''
+
+        if parser == 'http://m.tube8.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        if parser == 'http://mobile.youporn.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        if parser == 'http://m.pornhub.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        printDBG( 'Host getResolvedURL end' )
+        return videoUrl
+
+
+############################################
+# functions for host
+############################################
+def decodeUrl(text):
+    text = text.replace('%20',' ')
+    text = text.replace('%21','!')
+    text = text.replace('%22','"')
+    text = text.replace('%23','&')
+    text = text.replace('%24','$')
+    text = text.replace('%25','%')
+    text = text.replace('%26','&')
+    text = text.replace('%2F','/')
+    text = text.replace('%3A',':')
+    text = text.replace('%3B',';')
+    text = text.replace('%3D','=')
+    text = text.replace('%3F','?')
+    text = text.replace('%40','@')
+    return text
+
+def decodeHtml(text):
+    text = text.replace('&auml;','ä')
+    text = text.replace('\u00e4','ä')
+    text = text.replace('&#228;','ä')
+ 
+    text = text.replace('&Auml;','Ä')
+    text = text.replace('\u00c4','Ä')
+    text = text.replace('&#196;','Ä')
+        
+    text = text.replace('&ouml;','ö')
+    text = text.replace('\u00f6','ö')
+    text = text.replace('&#246;','ö')
+        
+    text = text.replace('&ouml;','Ö')
+    text = text.replace('\u00d6','Ö')
+    text = text.replace('&#214;','Ö')
+        
+    text = text.replace('&uuml;','ü')
+    text = text.replace('\u00fc','ü')
+    text = text.replace('&#252;','ü')
+        
+    text = text.replace('&Uuml;','Ü')
+    text = text.replace('\u00dc','Ü')
+    text = text.replace('&#220;','Ü')
+        
+    text = text.replace('&szlig;','ß')
+    text = text.replace('\u00df','ß')
+    text = text.replace('&#223;','ß')
+        
+    text = text.replace('&amp;','&')
+    text = text.replace('&quot;','\"')
+    
+    text = text.replace('&amp;','&')
+    text = text.replace('&quot;','\"')
+    text = text.replace('&gt;','>')
+    text = text.replace('&apos;',"'")
+    text = text.replace('&acute;','\'')
+    text = text.replace('&ndash;','-')
+    text = text.replace('&bdquo;','"')
+    text = text.replace('&rdquo;','"')
+    text = text.replace('&ldquo;','"')
+    text = text.replace('&lsquo;','\'')
+    text = text.replace('&rsquo;','\'')
+    text = text.replace('&#034;','\'')
+    text = text.replace('&#038;','&')
+    text = text.replace('&#039;','\'')
+    text = text.replace('&#160;',' ')
+    text = text.replace('\u00a0',' ')
+    text = text.replace('&#174;','')
+    text = text.replace('&#225;','a')
+    text = text.replace('&#233;','e')
+    text = text.replace('&#243;','o')
+    text = text.replace('&#8211;',"-")
+    text = text.replace('\u2013',"-")
+    text = text.replace('&#8216;',"'")
+    text = text.replace('&#8217;',"'")
+    text = text.replace('&#8220;',"'")
+    text = text.replace('&#8221;','"')
+    text = text.replace('&#8222;',',')
+    
+    text = text.replace('&#8230;','...')
+    text = text.replace('\u2026','...')
+    return text
+
+############################################
+# functions for fullpornhub
+############################################
+def decrypt(ciphertext, password, nBits):
+    printDBG( 'decrypt begin ' )
+    blockSize = 16
+    if not nBits in (128, 192, 256): return ""
+    ciphertext = base64.b64decode(ciphertext)
+#    password = password.encode("utf-8")
+
+    nBytes = nBits//8
+    pwBytes = [0] * nBytes
+    for i in range(nBytes): pwBytes[i] = 0 if i>=len(password) else ord(password[i])
+    key = Cipher(pwBytes, KeyExpansion(pwBytes))
+    key += key[:nBytes-16]
+
+    counterBlock = [0] * blockSize
+    ctrTxt = ciphertext[:8]
+    for i in range(8): counterBlock[i] = ord(ctrTxt[i])
+
+    keySchedule = KeyExpansion(key)
+
+    nBlocks = int( math.ceil( float(len(ciphertext)-8) / float(blockSize) ) )
+    ct = [0] * nBlocks
+    for b in range(nBlocks):
+        ct[b] = ciphertext[8+b*blockSize : 8+b*blockSize+blockSize]
+    ciphertext = ct
+
+    plaintxt = [0] * len(ciphertext)
+
+    for b in range(nBlocks):
+        for c in range(4): counterBlock[15-c] = urs(b, c*8) & 0xff
+        for c in range(4): counterBlock[15-c-4] = urs( int( float(b+1)/0x100000000-1 ), c*8) & 0xff
+
+        cipherCntr = Cipher(counterBlock, keySchedule)
+
+        plaintxtByte = [0] * len(ciphertext[b])
+        for i in range(len(ciphertext[b])):
+            plaintxtByte[i] = cipherCntr[i] ^ ord(ciphertext[b][i])
+            plaintxtByte[i] = chr(plaintxtByte[i])
+        plaintxt[b] = "".join(plaintxtByte)
+
+    plaintext = "".join(plaintxt)
+ #   plaintext = plaintext.decode("utf-8")
+    return plaintext
+
+Sbox = [
+    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
+    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
+    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
+    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
+    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
+    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
+    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
+    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
+    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
+    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
+    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
+    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
+    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
+    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
+    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
+    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
+]
+
+Rcon = [
+    [0x00, 0x00, 0x00, 0x00],
+    [0x01, 0x00, 0x00, 0x00],
+    [0x02, 0x00, 0x00, 0x00],
+    [0x04, 0x00, 0x00, 0x00],
+    [0x08, 0x00, 0x00, 0x00],
+    [0x10, 0x00, 0x00, 0x00],
+    [0x20, 0x00, 0x00, 0x00],
+    [0x40, 0x00, 0x00, 0x00],
+    [0x80, 0x00, 0x00, 0x00],
+    [0x1b, 0x00, 0x00, 0x00],
+    [0x36, 0x00, 0x00, 0x00]
+]
+
+def Cipher(input, w):
+    printDBG( 'cipher begin ' )
+    Nb = 4
+    Nr = len(w)/Nb - 1
+
+    state = [ [0] * Nb, [0] * Nb, [0] * Nb, [0] * Nb ]
+    for i in range(0, 4*Nb): state[i%4][i//4] = input[i]
+
+    state = AddRoundKey(state, w, 0, Nb)
+
+    for round in range(1, Nr):
+        state = SubBytes(state, Nb)
+        state = ShiftRows(state, Nb)
+        state = MixColumns(state, Nb)
+        state = AddRoundKey(state, w, round, Nb)
+
+    state = SubBytes(state, Nb)
+    state = ShiftRows(state, Nb)
+    state = AddRoundKey(state, w, Nr, Nb)
+
+    output = [0] * 4*Nb
+    for i in range(4*Nb): output[i] = state[i%4][i//4]
+    return output
+
+def SubBytes(s, Nb):
+    printDBG( 'subbytes begin ' )
+    for r in range(4):
+        for c in range(Nb):
+            s[r][c] = Sbox[s[r][c]]
+    return s
+
+def ShiftRows(s, Nb):
+    printDBG( 'shiftrows begin ' )
+    t = [0] * 4
+    for r in range (1,4):
+        for c in range(4): t[c] = s[r][(c+r)%Nb]
+        for c in range(4): s[r][c] = t[c]
+    return s
+
+def MixColumns(s, Nb):
+    printDBG( 'mixcolumns begin ' )
+    for c in range(4):
+        a = [0] * 4
+        b = [0] * 4
+        for i in range(4):
+            a[i] = s[i][c]
+            b[i] = s[i][c]<<1 ^ 0x011b if s[i][c]&0x80 else s[i][c]<<1
+        s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]
+        s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]
+        s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]
+        s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]
+    return s
+
+def AddRoundKey(state, w, rnd, Nb):
+    printDBG( 'addroundkey begin ' )
+    for r in range(4):
+        for c in range(Nb):
+            state[r][c] ^= w[rnd*4+c][r]
+    return state
+
+def KeyExpansion(key):
+    printDBG( 'keyexpansion begin ' )
+    Nb = 4
+    Nk = len(key)/4
+    Nr = Nk + 6
+
+    w = [0] * Nb*(Nr+1)
+    temp = [0] * 4
+
+    for i in range(Nk):
+        r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]]
+        w[i] = r
+
+    for i in range(Nk, Nb*(Nr+1)):
+        w[i] = [0] * 4
+        for t in range(4): temp[t] = w[i-1][t]
+        if i%Nk == 0:
+            temp = SubWord(RotWord(temp))
+            for t in range(4): temp[t] ^= Rcon[i/Nk][t]
+        elif Nk>6 and i%Nk == 4:
+            temp = SubWord(temp)
+        for t in range(4): w[i][t] = w[i-Nk][t] ^ temp[t]
+    return w
+
+def SubWord(w):
+    printDBG( 'subword begin ' )
+    for i in range(4): w[i] = Sbox[w[i]]
+    return w
+
+def RotWord(w):
+    printDBG( 'rotword begin ' )
+    tmp = w[0]
+    for i in range(3): w[i] = w[i+1]
+    w[3] = tmp
+    return w
+
+def encrypt(plaintext, password, nBits):
+    printDBG( 'encrypt begin ' )
+    blockSize = 16
+    if not nBits in (128, 192, 256): return ""
+#    plaintext = plaintext.encode("utf-8")
+#    password  = password.encode("utf-8")
+    nBytes = nBits//8
+    pwBytes = [0] * nBytes
+    for i in range(nBytes): pwBytes[i] = 0 if i>=len(password) else ord(password[i])
+    key = Cipher(pwBytes, KeyExpansion(pwBytes))
+    key += key[:nBytes-16]
+
+    counterBlock = [0] * blockSize
+    now = datetime.datetime.now()
+    nonce = time.mktime( now.timetuple() )*1000 + now.microsecond//1000
+    nonceSec = int(nonce // 1000)
+    nonceMs  = int(nonce % 1000)
+
+    for i in range(4): counterBlock[i] = urs(nonceSec, i*8) & 0xff
+    for i in range(4): counterBlock[i+4] = nonceMs & 0xff
+
+    ctrTxt = ""
+    for i in range(8): ctrTxt += chr(counterBlock[i])
+
+    keySchedule = KeyExpansion(key)
+
+    blockCount = int(math.ceil(float(len(plaintext))/float(blockSize)))
+    ciphertxt = [0] * blockCount
+
+    for b in range(blockCount):
+        for c in range(4): counterBlock[15-c] = urs(b, c*8) & 0xff
+        for c in range(4): counterBlock[15-c-4] = urs(b/0x100000000, c*8)
+
+        cipherCntr = Cipher(counterBlock, keySchedule)
+
+        blockLength = blockSize if b<blockCount-1 else (len(plaintext)-1)%blockSize+1
+        cipherChar = [0] * blockLength
+
+        for i in range(blockLength):
+            cipherChar[i] = cipherCntr[i] ^ ord(plaintext[b*blockSize+i])
+            cipherChar[i] = chr( cipherChar[i] )
+        ciphertxt[b] = ''.join(cipherChar)
+
+    ciphertext = ctrTxt + ''.join(ciphertxt)
+    ciphertext = base64.b64encode(ciphertext)
+
+    return ciphertext
+
+def urs(a, b):
+    printDBG( 'urs begin ' )
+    a &= 0xffffffff
+    b &= 0x1f
+    if a&0x80000000 and b>0:
+        a = (a>>1) & 0x7fffffff
+        a = a >> (b-1)
+    else:
+        a = (a >> b)
+    return a 
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostcdapl.py ./IPTVPlayer/hosts/Polish/hostcdapl.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostcdapl.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostcdapl.py	2015-11-11 07:16:27.395280028 +0100
@@ -0,0 +1,248 @@
+﻿# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+import re
+import urllib
+import time
+import random
+try:    import simplejson as json
+except: import json
+
+
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.cda_searchsort = ConfigSelection(default = "best", choices = [("best", _("Najtrafniejsze")), ("date", _("Najnowsze")), ("rate", _("Najlepiej oceniane")), ("alf", _("Alfabetycznie"))])
+
+def GetConfigList():
+    optionList = []
+    optionList.append( getConfigListEntry( _("Sortuj wyniki wyszukiwania po:"), config.plugins.iptvplayer.cda_searchsort ) )
+    return optionList
+###################################################
+
+def gettytul():
+    return 'cda.pl'
+
+class cda(CBaseHostClass):
+    MAINURL  = 'http://www.cda.pl/'
+    SEARCH_URL = MAINURL + 'video/show/%s/p%d?s=%s'
+    CATEGORIES_TAB = [{'url' : '',       'title' : '--Wszystkie--'}, 
+                      {'url' : '/kat26', 'title' : 'Krótkie filmy i animacje'}, 
+                      {'url' : '/kat24', 'title' : 'Filmy Extremalne'}, 
+                      {'url' : '/kat27', 'title' : 'Motoryzacja, wypadki'}, 
+                      {'url' : '/kat28', 'title' : 'Muzyka'}, 
+                      {'url' : '/kat29', 'title' : 'Prosto z Polski'}, 
+                      {'url' : '/kat30', 'title' : 'Rozrywka'}, 
+                      {'url' : '/kat31', 'title' : 'Sport'}, 
+                      {'url' : '/kat32', 'title' : 'Śmieszne filmy'}, 
+                      {'url' : '/kat33', 'title' : 'Różności'}, 
+                      {'url' : '/kat34', 'title' : 'Życie studenckie'} ] 
+    
+    def __init__(self):
+        printDBG("cda.__init__")
+        CBaseHostClass.__init__(self, {'history':'cda.pl'})
+    
+    def listsMainMenu(self):
+        printDBG("cda.listsMainMenu")
+        self.addDir({'name':'category', 'title':'Główna',                'category':'categories', 'url' : 'video'})
+        self.addDir({'name':'category', 'title':'Poczekalnia',           'category':'categories', 'url' : 'video/poczekalnia'})
+        self.addDir({'name':'category', 'title':'Wyszukaj',              'category':'Wyszukaj'})
+        self.addDir({'name':'category', 'title':'Historia wyszukiwania', 'category':'Historia wyszukiwania'})
+        
+    def listCategories(self, cItem):
+        printDBG("cda.listCategories cItem[%s]" % cItem)
+        for item in cda.CATEGORIES_TAB:
+            item = dict(item)
+            item['name']     = cItem['name']
+            item['category'] = 'category'
+            item['url']      = cItem['url'] + item['url']
+            self.addDir(item)
+            
+    def listCategory(self, cItem):
+        printDBG("cda.listCategory cItem[%s]" % cItem)
+        page = cItem.get('page', 1)
+        url = cda.MAINURL + cItem['url'] + ('/p%d' % page)
+        self.listItems(cItem, url, page)
+        
+    def listSearchResult(self, cItem, searchPattern):
+        printDBG("cda.listSearchResult cItem[%s], searchPattern[%s]" % (cItem, searchPattern))
+        searchsort = config.plugins.iptvplayer.cda_searchsort.value
+        page = cItem.get('page', 1)
+        url  = cda.SEARCH_URL % (urllib.quote_plus(searchPattern), page, searchsort)
+        tmpItem = dict(cItem)
+        tmpItem.update({'category' : 'search_next_page', 'search_pattern':searchPattern})
+        self.listItems(tmpItem, url, page, True)
+        
+    def listItems(self, cItem, url, page, search=False):
+        sts, data = self.cm.getPage(url)
+        if sts:
+            if 'Następna strona' in data:
+                nextPage = True
+            else:
+                nextPage = False
+            if search:
+                data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="thumbElem video', '<div class="clear"></div>', False)[1]
+                data = data.split('<div class="thumbElem video')
+            elif 'poczekalnia' in url:
+                data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="videoInfo">', '<div class="bottom" id="dolny_pasek">', False)[1]
+                data = data.split('<div class="videoInfo">')                
+            else:
+                data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="rowElem">', '<div class="clear"></div>', False)[1]
+                data = data.split('</label>')
+                
+            for item in data:
+                desc1   = self.cleanHtmlStr( self.cm.ph.getDataBeetwenReMarkers(item, re.compile('''<span class=["']timeElem[^>]*?>'''), re.compile('</span>'), False)[1] )
+                desc2  = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<label  title="', '"', False)[1] )
+                if '' == desc2: desc2   = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<img  title="', '"', False)[1] )
+                desc = desc1 + ' | ' + desc2
+                
+                title  = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<div class="text">', '</div>', False)[1] )
+                if '' == title: title  = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, '<span style="color: #B82D2D; font-size: 14px">', '</a>', False)[1] )
+                if '' == title: title  = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, 'alt="', '"', False)[1] )
+                url    = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, 'href="', '"', False)[1] )
+                icon   = self.cleanHtmlStr( self.cm.ph.getDataBeetwenMarkers(item, 'src="', '"', False)[1] )
+                if url.startswith('/video'):
+                    url = self.MAINURL + url
+                    self.addVideo({'title':title, 'url':url, 'icon':icon, 'desc':desc})
+                
+            if nextPage:
+                nextPage = dict(cItem)
+                nextPage.update({'title':'Następna strona', 'page':page+1})
+                self.addDir(nextPage)
+        
+    def getLinksForVideo(self, cItem):
+        printDBG("cda.getLinksForVideo [%s]" % cItem['url'])
+        return self.up.getVideoLinkExt(cItem['url'])
+        
+    def getFavouriteData(self, cItem):
+        return cItem['url']
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.up.getVideoLinkExt(fav_data)
+    
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('cda.handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "cda.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        searchPattern = self.currItem.get("search_pattern", searchPattern)
+        self.currList = []
+        
+        if None == name:
+            self.listsMainMenu()
+    #KATEGORIE
+        if 'categories' == category:
+            self.listCategories(self.currItem)
+    #KATEGORIA
+        if 'category' == category:
+            self.listCategory(self.currItem)
+    #WYSZUKAJ
+        elif category in ["Wyszukaj", "search_next_page"]:
+            self.listSearchResult(self.currItem, searchPattern)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "Historia wyszukiwania":
+            self.listsHistory()
+        
+        CBaseHostClass.endHandleService(self, index, refresh)
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, cda(), True, [CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO])
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('cdapllogo.png')])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+
+    def converItem(self, cItem):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+    
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            url = cItem.get('url', '')
+            if '' != url:
+                hostLinks.append(CUrlItem("Link", url, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  clean_html(cItem.get('desc', ''))
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 1,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+    # end converItem
+
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostipla.py ./IPTVPlayer/hosts/Polish/hostipla.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostipla.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostipla.py	2015-11-05 22:26:57.913660252 +0100
@@ -0,0 +1,377 @@
+# -*- coding: utf-8 -*-
+
+####################################################################
+# IPLA privacy policy
+# Pobieranie i udostępnianie danych ze źródła ipla przez 
+# podmioty nieuprawnione grozi sankcjami karnymi na 
+# podstawie obowiązujących przepisów karnych (grzywna, 
+# kara ograniczenia wolności albo kara pozbawienia wolności) 
+# oraz konsekwencjami przewidzianymi w przepisach prawa 
+# cywilnego (odszkodowanie w wysokości zasądzonej przez sąd).
+# Zabronione jest pobieranie danych i udostępniania ich na 
+# urządzeniach lub aplikacjach innych niż przygotowane i 
+# wspierane oficjalnie przez Redefine Sp. z o.o.
+####################################################################
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, CFavItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSelOneLink, GetLogoDir, GetCookieDir, byteify
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+# from xml.etree import cElementTree - I would not recommend this XML parser or any other from python
+# XML will be parser using regular expressions due to problem with memory leak, if we use
+# cElementTree event if memory is free using clear method and removing instances by del, 
+# the memory using still grows with each parsing, probably due to fragmentation of memory.
+# The XML is devil's invention :)
+    
+from Components.config import config, ConfigYesNo, ConfigSelection, getConfigListEntry
+from time import time
+from os import path as os_path
+import urllib
+import re
+
+try: import json
+except: import simplejson as json
+###################################################
+
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.iplacachexml      = ConfigSelection(default = "12", choices = [("0", "nigdy"), ("6", "przez 6 godzin"), ("12", "przez 12 godzin"),("24", "przez dzień")])
+config.plugins.iptvplayer.iplaDefaultformat = ConfigSelection(default = "400", choices = [("200", "bitrate: 200"),("400", "bitrate: 400"),("900", "bitrate: 900"),("1900", "bitrate: 1900")])
+config.plugins.iptvplayer.iplaUseDF         = ConfigYesNo(default = True)
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("Używaj danych z pamięci podręcznej:"), config.plugins.iptvplayer.iplacachexml))
+    optionList.append(getConfigListEntry(_("Domyślny format video:"), config.plugins.iptvplayer.iplaDefaultformat))
+    optionList.append(getConfigListEntry(_("Używaj domyślnego format video:"), config.plugins.iptvplayer.iplaUseDF))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Ipla'
+
+class Ipla(CBaseHostClass):
+    HOST       = 'mipla/23'
+    IDENTITY   = 'ver=600&login=common_user&cuid=-11033141'
+    MAIN_URL   = 'http://getmedia.redefine.pl'
+    CAT_URL    = MAIN_URL + '/r/l_x_35_ipla/categories/list/?' + IDENTITY
+    MOV_URL    = MAIN_URL + '/action/2.0/vod/list/?' + IDENTITY + '&category='
+    SEARCH_URL = MAIN_URL + '/vods/search/?vod_limit=150&' + IDENTITY + '&page=0&keywords='
+    
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'ipla'})
+        self.categoryXMLTree = None
+        self.cacheFilePath   = os_path.join(config.plugins.iptvplayer.SciezkaCache.value, "iplaxml.cache")
+        
+    def getStr(self, v, default=''):
+        if None == v:
+            return default
+        elif type(v) == type(u''):
+            return v.encode('utf-8')
+        elif type(v) == type(''):
+            return v
+
+    def __getAttribs(self, data):
+        re_compile = re.compile('([^= ]+?)="([^"]+?)"')
+        item={}
+        attribs = re_compile.findall(data)
+        for attrib in  attribs:
+            item[attrib[0]] = attrib[1]
+        return item
+    
+    def getVideosList(self, url):
+        printDBG("Ipla.getVideosList url[%s]" % url)
+            
+        sts, videosXMLTree = self.cm.getPage(url, {'host' : Ipla.HOST})
+        if sts:
+            videosXMLTree = self.getStr(videosXMLTree).split('</vod>')
+            del videosXMLTree[-1]
+            re_compile_vod    = re.compile('<vod ([^>]+?)>')
+            re_compile_thumbs = re.compile('<thumb ([^>]+?)>')
+            try:
+                for vod in videosXMLTree:
+                    try:
+                        val = re_compile_vod.search(vod)
+                        if not val: continue
+                        val = self.__getAttribs(val.group(1))
+                        title = val.get('title', '')
+                        plot  = val.get('descr', '')
+                        icon  = val.get('thumbnail', '')
+                        try:
+                            thumbs = re_compile_thumbs.findall(vod)
+                            thumbSizePrev = 9999
+                            for thumb in thumbs:
+                                attrib = self.__getAttribs(thumb)
+                                thumbSize = int(attrib['size'].split('x')[0])
+                                if thumbSizePrev > thumbSize:
+                                    thumbSizePrev = thumbSize
+                                    icon = attrib['url']
+                        except: printExc()
+                        urls = self._getVideoUrls(vod)
+                        params = {'category': 'video', 'title': title, 'plot': plot, 'icon':icon, 'urls': urls, 'fav_item':{'url':url, 'vod_id':val.get('id', '')}}
+                        self.addVideo(params)
+                    except: printExc()
+            except: printExc()
+    # end getVideosList
+    
+    def _getVideoUrls(self, vodData):
+        urls = []
+        re_compile_srcreq = re.compile('<srcreq ([^>]+?)>')
+        max_bitrate = int(config.plugins.iptvplayer.iplaDefaultformat.value)
+        def __getLinkQuality( itemLink ):
+            return int(itemLink['bitrate'])
+        try:
+            links = re_compile_srcreq.findall(vodData)
+            for link in links:
+                attrib = self.__getAttribs(link)
+                drm = attrib['drmtype']
+                if drm == '0':
+                    if config.plugins.iptvplayer.ZablokujWMV.value and attrib['format'] == '0':
+                        continue
+                    name = "Jakość: %s\t format: %s\t  bitrate: %s" % (attrib['quality'], attrib['format'], attrib['bitrate'])
+                    urls.append( {'name':name, 'url':attrib['url'], 'bitrate':attrib['bitrate']} )
+        except: printExc()
+        if config.plugins.iptvplayer.iplaUseDF.value and 1 < len(urls):
+            urls = CSelOneLink(urls, __getLinkQuality, max_bitrate).getOneLink()
+        return urls
+    
+    def __writeCategoryCache(self, data):
+        printDBG("__writeCategoryCache ")
+        try:
+            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
+            data = str({"timestamp" : int(time()), "data":data})
+            with open(self.cacheFilePath, 'w') as f:
+                f.write(str(data))            
+        except:
+            printExc()
+    
+    def __readCategoryCache(self):
+        printDBG("__readCategoryCache ")
+        try:
+            data = None
+            if "0" == config.plugins.iptvplayer.iplacachexml.value: return
+            from ast import literal_eval
+            with open(self.cacheFilePath, 'r') as f:
+                data = f.read()
+            data = literal_eval(data)
+            currTimestamp = int(time())
+            saveTimestamp = data["timestamp"]
+            
+            if (currTimestamp - saveTimestamp) / 3600 < int(config.plugins.iptvplayer.iplacachexml.value):
+                data = data["data"]
+                printDBG("__readCategoryCache data from cache valid")
+            else:
+                data = None
+        except:
+            printExc()
+            data = None
+        return data
+        
+    def getCatXmlTree(self, refresh=False):
+        printDBG("setCatXmlTree refresh[%r]" %  refresh)
+        
+        def _fromUrl():
+            sts,data = self.cm.getPage(Ipla.CAT_URL, {'host' : Ipla.HOST})
+            if not sts: data = ''
+            return data
+            
+        if None == self.categoryXMLTree or refresh:
+            try:
+                bFromCache = True
+                data = None
+                if not refresh:
+                    data = self.__readCategoryCache()
+                if None == data:
+                    bFromCache = False
+                    data = _fromUrl()
+                self.categoryXMLTree = self.__simpleCategoryParser(data)
+                if bFromCache and 100 > len(self.categoryXMLTree):
+                    data = _fromUrl()
+                    self.categoryXMLTree = self.__simpleCategoryParser(data)
+                    bFromCache = False
+                if not bFromCache:
+                    self.__writeCategoryCache(data)
+            except:
+                printExc()
+                self.categoryXMLTree = None
+        return self.categoryXMLTree
+        
+    def __simpleCategoryParser(self, data):
+        printDBG("__simpleCategoryParser start")
+        data = re.compile('<cat ([^>]+?)>').findall(data)
+        printDBG("__simpleCategoryParser step 1 finished")
+        for idx in range(len(data)):
+            data[idx] = self.__getAttribs(data[idx])
+        printDBG("__simpleCategoryParser step 2 finished")
+        return data
+        
+    def getCategories(self, parentCatId, refresh):
+        printDBG( "getCategories parentCatId[%s]" % parentCatId )
+        xmlTree = self.getCatXmlTree(refresh)
+        if xmlTree:
+            try:
+                #cats = xmlTree.findall("cat")
+                cats = xmlTree
+                listVideo = False
+                numOfSubCat = 0
+                for cat in cats:
+                    #val = cat.attrib
+                    val = cat
+                    try:
+                        listVideo = True
+                        pid = self.getStr(val.get('pid', ''), '')
+                        catId = self.getStr(val.get('id', ''), '')
+                        if '' in [pid, catId]:
+                            continue
+                        if pid == parentCatId:
+                            numOfSubCat += 1
+                            title = self.getStr(val.get('title', ''), '')
+                            plot  = self.getStr(val.get('descr', ''), '')
+                            icon  = self.getStr(val.get('thumbnail', ''), '')
+                            #check if this is only link to diffrent category
+                            try:
+                                link = self.getStr(val.get('action', ''), '')
+                                linkMarker = "ipla://cmd-cmd=gotocat&catid="
+                                if linkMarker  in link:
+                                    # if this is only linkt to another category, update category id
+                                    catId = link.replace(linkMarker, "")
+                            except: pass
+                            params = {'category': 'category', 'title': title, 'plot': plot, 'icon':icon, 'catId': catId, 'pCatId': pid}
+                            self.addDir(params)
+                        #printDBG("||||||||||||||||: %s" %pid)
+                    except:
+                        printDBG( "getCategories except" )
+                        printExc()
+                if listVideo and numOfSubCat < 2:
+                    self.getVideosList(Ipla.MOV_URL + parentCatId)
+            except: printExc()
+        return
+        
+    def listsMainMenu(self, refresh=False):
+        printDBG('listsMainMenu')
+        self.getCategories('0', refresh)
+        self.addDir( {'category': 'Wyszukaj',  'title': 'Wyszukaj'} )
+        self.addDir( {'category': 'search_history',   'title': 'Historia wyszukiwania'} )
+        
+    def getFavouriteData(self, cItem):
+        return json.dumps(cItem['fav_item'])
+        
+    def getLinksForFavourite(self, fav_data):
+        links = []
+        try: 
+            favItem = byteify( json.loads(fav_data) )
+            printDBG(favItem)
+            sts, data = self.cm.getPage(favItem['url'], {'host' : Ipla.HOST})
+            if sts:
+                sts, data = self.cm.ph.getDataBeetwenReMarkers(data, re.compile('<vod[^>]+?id="%s"[^>]*?>'% favItem['vod_id']), re.compile('</vod>' ), False)
+                if sts: links = self._getVideoUrls(data)
+        except: printExc()
+        return links
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        if 0 == refresh: refresh = False
+        else: refresh = True
+
+        title      = self.currItem.get("title", '')
+        category   = self.currItem.get("category", None)
+        catId      = self.currItem.get("catId", '')
+        pCatId     = self.currItem.get("pCatId", '')
+        icon       = self.currItem.get("icon", '')
+        url        = self.currItem.get("url", '')
+        plot       = self.currItem.get("plot", '')
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| category[%r] " % (category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if category == None:
+            self.listsMainMenu(refresh)
+    #GET SUB CATEGORY
+        elif category == 'category':
+            self.getCategories(catId, refresh)
+    #WYSZUKAJ
+        elif category == 'Wyszukaj':
+            pattern = urllib.quote_plus(searchPattern)
+            self.getVideosList(Ipla.SEARCH_URL + pattern)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "search_history":
+            self.listsHistory()
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Ipla(), True, [CDisplayListItem.TYPE_VIDEO]) # with search history, can generate favorite item
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('iplalogo.png')])
+    
+    def converItem(self, cItem):
+        searchTypesOptions = [] # ustawione alfabetycznie
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            urls = cItem.get('urls', [])
+            for urlItem in urls:
+                hostLinks.append(CUrlItem(urlItem['name'], urlItem['url'], 0))
+            
+        title       =  clean_html( cItem.get('title', '') )
+        description =  clean_html( cItem.get('plot', '') )
+        icon        =  cItem.get('icon', '')
+        hostItem = CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 0,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+        return hostItem
+    
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex].get('name'):
+                pattern = list[self.currIndex]['title']
+                search_type = None
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
+
+
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostiplex.py ./IPTVPlayer/hosts/Polish/hostiplex.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostiplex.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostiplex.py	2015-11-05 22:26:57.913660252 +0100
@@ -0,0 +1,296 @@
+# -*- coding: utf-8 -*-
+# Based on information provided by @jatrn: http://sd-xbmc.org/pl/content/iplexpl-zrodlo-apki-z-samsunga-smart-tv
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.libs.crypto.cipher import blowfish
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+from datetime import timedelta
+import re
+import urllib
+import time
+import binascii
+import base64
+import codecs
+try:    import simplejson as json
+except: import json
+
+from os import urandom as os_urandom
+try:
+    from hashlib import sha1
+except ImportError:
+    import sha
+    sha1 = sha.new
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.iplex_proxy = ConfigYesNo(default = False)
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry("Iplex korzystaj z proxy?", config.plugins.iptvplayer.iplex_proxy))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Iplex'
+
+class Iplex(CBaseHostClass):
+    USER_AGENT = 'Mozilla/5.0 (SmartHub; SMART-TV; U; Linux/SmartTV; Maple2012) AppleWebKit/534.7 (KHTML, like Gecko) SmartTV Safari/534.7'
+    
+    def __init__(self):
+        printDBG("Iplex.__init__")
+        CBaseHostClass.__init__(self, {'proxyURL': config.plugins.iptvplayer.proxyurl.value, 'useProxy': config.plugins.iptvplayer.iplex_proxy.value})        
+        self.cm.HEADER = {'User-Agent': Iplex.USER_AGENT, 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
+        
+    def _getJItemStr(self, item, key, default=''):
+        v = item.get(key, None)
+        if None == v:
+            return default
+        return clean_html(u'%s' % v).encode('utf-8')
+        
+    def _getJItemNum(self, item, key, default=0):
+        v = item.get(key, None)
+        if None != v:
+            try:
+                NumberTypes = (int, long, float, complex)
+            except NameError:
+                NumberTypes = (int, long, float)
+                
+            if isinstance(v, NumberTypes):
+                return v
+        return default
+        
+        
+    def _decodeUrl(self, url, key='-S75dbb-QB?<nE_['):
+        '''
+        Author: http://sd-xbmc.org/, @jatrn
+        '''
+        ret = ''
+        #-------- decoding -----------
+        match = re.search('(http:\/\/.*)\/(\d{1,5}|pre_adv|post_adv)\/(.*)\.mp4', url)
+
+        #check if valid url
+        if match:
+            url_path = match.group(1) + '/' + match.group(2) + '/'
+            s1 = codecs.encode(match.group(3), 'rot_13') 
+            s2 = base64.b64decode(s1)
+            s3 = ''
+            cipher = blowfish.Blowfish(key)
+            for index in range(0, len(s2)/16):
+                chunk = s2[index*16:index*16+16]
+                s3 += cipher.decrypt(chunk.decode("hex"))
+            s4 = s3.replace("$","")
+            ret = url_path + s4 + '.mp4'
+        return ret
+        
+    def listsCategories(self, url):
+        printDBG("Iplex.listsCategories url[%s]" % url)
+        
+        sts, data = self.cm.getPage(url)
+        if not sts:
+            printExc()
+            return
+        
+        try:
+            data = json.loads(data)
+            if 'series' in data:
+                sts, data = self.cm.getPage(data['series'])
+                if not sts:
+                    printExc()
+                    return
+                data = json.loads(data)
+            for item in data['feeds']:
+                if item.get('license', '') in ['FREE', '']: #'PAID'
+                    type  = self._getJItemStr(item, 'type')
+                    if 'account' == type: continue
+                    url   = self._getJItemStr(item, 'url')
+                    title = self._getJItemStr(item, 'caption')
+                    if '' == title: title = self._getJItemStr(item, 'title')
+                    icon  = self._getJItemStr(item, 'img')   
+                    desc  = '' 
+                    duration = self._getJItemNum(item, 'duration', -1)
+                    rating   = self._getJItemStr(item, 'rating', 'brak oceny')
+                    if 0 < duration:             desc += str(timedelta(minutes=duration)) + '|'
+                    if 'brak oceny' != rating:   desc += rating + '|'
+                    
+                    params = { 'url'      : url,
+                               'title'    : title,
+                               'desc'     : desc,
+                               'icon'     : icon,
+                               'category' : type,
+                             }
+                    if 'movie_card' == type:
+                        self.addVideo(params)
+                    else:
+                        self.addDir(params)
+        except: 
+            printExc()
+    
+    def resolveLink(self, url):
+        printDBG("Iplex.resolveLink url[%s]" % url)
+        sts, data = self.cm.getPage(url)
+        if not sts:
+            return
+        try:
+            data = json.loads(data)
+            url = self._decodeUrl(self._getJItemStr(data['movie'], 'url'))
+            if type(url) == type(u''):
+                url = url.encode('utf-8')
+            return url
+        except:
+            printExc()
+        return ''
+
+    def getLinks(self, url):
+        printDBG("Iplex.getLinks url[%r]" % url )
+        videoUrls = []
+        sts, data = self.cm.getPage(url)
+        if sts:
+            try:
+                data = json.loads(data)
+                printDBG(data)
+                VER_TABLE = [{'type':'lector', 'name':'Lektor'}, {'type':'subtitles', 'name':'Napisy'}]
+                for item in VER_TABLE:
+                    if item['type'] in data:
+                        videoUrls.append({'name': item['name'], 'url':self._getJItemStr(data, item['type'])})
+            except:
+                printExc()
+        return videoUrls
+        
+    def getDescription(self, url):
+        printDBG("Iplex.getDescription url[%r]" % url )
+        content = {}
+        sts, data = self.cm.getPage(url)
+        if sts:
+            try:
+                data = json.loads(data)
+                printDBG(data)
+                content = { 'title': self._getJItemStr(data, 'title'),
+                            'desc' : self._getJItemStr(data, 'description'),
+                            'icon' : self._getJItemStr(data, 'img'),
+                          }
+                if 10 < len(content['desc']):
+                    return content
+            except:
+                printExc()
+        return content
+        
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('Iplex..handleService start')
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        
+        name     = self.currItem.get("name", '')
+        category = self.currItem.get("category", '')
+        url      = self.currItem.get("url", 'http://samsung.iplex.pl/tv/main.menu?api=v4')
+        printDBG( "Iplex.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+        self.listsCategories(url)
+
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Iplex(), False)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('iplexlogo.png')])
+        
+    def getArticleContent(self, Index = 0):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getArticleContent - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+            
+        content = self.host.getDescription(self.host.currList[Index]['url'])
+        title  = content.get('title', '')
+        text   = content.get('desc' '')
+        images = [ {'title':'', 'author': '', 'url': content.get('icon', '')} ]
+        
+        return RetHost(RetHost.OK, value = [ArticleContent(title = title, text = text, images =  images)])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] != 'video':
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+
+        retlist = []
+        urlList = self.host.getLinks(self.host.currList[Index]['url'])
+        for item in urlList:
+            need_resolve = 1
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        url = self.host.resolveLink(url)
+        urlTab = []
+        if isinstance(url, basestring) and url.startswith('http'):
+            urlTab.append(url)
+        return RetHost(RetHost.OK, value = urlTab)
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = []
+        
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if cItem['type'] == 'category':
+                if cItem['title'] == 'Wyszukaj':
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  cItem.get('title', '')
+            description =  clean_html(cItem.get('desc', ''))
+            icon        =  cItem.get('icon', '')
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostonetvod.py ./IPTVPlayer/hosts/Polish/hostonetvod.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostonetvod.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostonetvod.py	2015-11-05 22:26:57.917660252 +0100
@@ -0,0 +1,463 @@
+# -*- coding: utf-8 -*-
+# Based on (root)/trunk/xbmc-addons/src/plugin.video.polishtv.live/ @ 419 - Wersja 626
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+import Plugins.Extensions.IPTVPlayer.libs.crypto
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSelOneLink, GetLogoDir
+###################################################
+# FOREIGN import
+###################################################
+import time, urllib, urllib2, re, math, random
+try:   import json
+except:import simplejson as json
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.onetvodDefaultformat = ConfigSelection(default = "450", choices = [("0", "bitrate: najgorszy"), ("200", "bitrate: 200p"), ("450", "bitrate: 450p"),("900", "bitrate: 900"),("1800", "bitrate: 1800"), ("9999", "bitrate: najlepszy")])
+config.plugins.iptvplayer.onetvodUseDF = ConfigYesNo(default = False)
+config.plugins.iptvplayer.proxyOnet = ConfigYesNo(default = False)
+
+def GetConfigList():
+    optionList = []
+    optionList.append( getConfigListEntry( "Domyślny format video:", config.plugins.iptvplayer.onetvodDefaultformat ) )
+    optionList.append( getConfigListEntry( "Używaj domyślnego format video:", config.plugins.iptvplayer.onetvodUseDF ) )
+    optionList.append(getConfigListEntry( "Korzystaj z proxy?", config.plugins.iptvplayer.proxyOnet))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'ONET VOD player'
+
+class CListItem:
+    TYPE_CATEGORY = "CATEGORY"
+    TYPE_VIDEO = "VIDEO"
+    def __init__(self,
+                name = 'None',
+                title = '',
+                category = 'None',
+                url = '',
+                iconimage = ''):
+        self.name = name
+        self.title = title
+        self.category = category
+        self.url = url
+        self.iconimage = iconimage
+ 
+# CListItem
+
+class vodonet:
+  MODULE_URL = {'content' : 'http://content.external.cms.onetapi.pl/l',
+                'video'   : 'http://video.external.cms.onetapi.pl/l'}
+                
+  HEADER = {'X-Onet-App': 'vod.android.mobile-apps.onetapi.pl', 'Content-Type': 'application/json-rpc', 'User-Agent': 'Dalvik/1.6.0 (Linux; U; Android 4.1.1; Core 10.1 3G Build/JRO03H)', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip'}
+
+  SERVICE_MENU_TABLE = { 1: "Polecamy",
+                2: "Filmy",
+                3: "Seriale",
+                4: "TV",
+                5: "Dokumenty",
+                6: "Bajki",}
+
+  FORMAT = 'mp4'
+
+  def __init__(self):
+    porxyUrl = config.plugins.iptvplayer.proxyurl.value
+    useProxy = config.plugins.iptvplayer.proxyOnet.value
+    self.cm = pCommon.common(porxyUrl, useProxy)
+    self.api = API()
+    
+    # SULGE
+    self.currList = []
+    
+  def getCurrList(self):
+    return self.currList
+    
+  def setCurrList(self, list):
+    self.currList = list
+    return 
+    
+  def setTable(self):
+    return vodonet.SERVICE_MENU_TABLE
+    
+    
+  def getMenuTable(self):
+    nTab = []
+    for num, val in vodonet.SERVICE_MENU_TABLE.items():
+      nTab.append(val)
+    return nTab
+
+    
+  def listsAddDirMenu(self, table, name, category):
+    for i in range(len(table)):
+      try:
+        if table[i][3] != '':
+          iconImage = self.api.getPoster(table[i][3])
+        else: iconImage = ''
+      except:
+        iconImage = ''
+      
+      if name == 'None':
+        self.add('main-menu', table[i], category, '', '', True, False)
+   
+      if name == 'main-menu':
+        if category == self.setTable()[3] or category == self.setTable()[4]:
+          self.add('sub-menu', table[i][0].encode('UTF-8'),  str(table[i][1]), iconImage, str(table[i][2]), True, False)
+        else:
+          self.add('sub-menu', table[i][0].title().encode('UTF-8'), category, iconImage, '', True, False)
+      
+      if name == 'series':
+        if category == 'None': self.add('series', table[i][0], str(table[i][1]), iconImage, str(table[i][2]), True, False)  
+      
+      if name == 'playSeries':
+        self.add('playSelectedMovie', table[i][0].title().encode('UTF-8') + ', odcinek ' + str(table[i][2]), table[i][1], iconImage, '', True, False)      
+      if name == 'movie':
+        self.add('playSelectedMovie', table[i][0].title().encode('UTF-8'), table[i][1], iconImage, '', True, False)      
+    
+
+  def add(self, name, title, category, iconimage, url, folder = True, isPlayable = True):
+    if '' == category:
+        category = 'None'
+    item = CListItem(name = name,
+                    title = title,
+                    category = category,
+                    url = url,
+                    iconimage = iconimage)
+                    
+    self.currList.append(item)
+
+
+  def listsSeasons(self, seriesId, seasons):
+    strTab = []
+    valTab = []
+    for i in range(int(seasons)):
+      strTab.append('Sezon ' + str(i+1))
+      strTab.append(i+1)
+      strTab.append(int(seriesId))
+      strTab.append('')
+      valTab.append(strTab)
+      strTab = []
+    return valTab
+
+ 
+  def listsItems(self, node, childs, alt_childs = []):
+    valTab = []
+    for items in node:
+      strTab = []
+      if childs[0] in items:
+        for i in childs:
+          if i != '' and i in items: strTab.append(items[i])
+          else:
+            strTab.append('')
+      elif 0 < len(alt_childs):
+         for i in alt_childs:
+           if i != '': strTab.append(items[i])
+           else: strTab.append('')
+      if 0 < len(strTab):
+          if 'poster' in items: strTab.append(items['poster']['imageId'])
+          else:
+            try: strTab.append(items['leadMedia']['imageId'])
+            except: strTab.append('')
+          valTab.append(strTab)
+    return valTab
+
+
+  def getVideoUrl(self, tab, videoFormat, videoQuality):
+    indexTab = []
+    url =''
+    for i in range(len(tab)):
+        if tab[i][0] == videoFormat: indexTab.append(i)  
+    if videoQuality == 'Niska': url = tab[indexTab[0]][1]
+    if videoQuality == 'Wysoka': url = tab[indexTab[-1]][1]
+    if videoQuality == 'Średnia':
+        length = len(indexTab)
+        i = int(math.ceil(float((indexTab[length/2] + indexTab[-(length+1)/2]))/2))
+        url = tab[i][1]
+    return url
+
+  def handleService(self, index, refresh = 0):
+
+    if 0 == refresh:
+        if len(self.currList) <= index:
+            printDBG( "vodonet handleService wrond index: %s, len(self.currList): %d" % (index, len(self.currList)) )
+            return
+    
+        if -1 == index:         
+            self.name = 'None'
+            self.title = ''
+            self.category = 'None'
+            self.url = ''
+
+            printDBG( "vodonet handleService for first category" )
+        else:
+            item = self.currList[index]
+            self.name = item.name
+            self.title = item.title
+            self.category = item.category
+            self.url = item.url
+            
+            printDBG( "vodonet |||||||||||||||||||||||||||||||||||| name: %s, category: %s" % (item.name,self.category) )
+        self.currList = []
+       
+    #MAINMENU
+    if self.name == 'None':
+      self.listsAddDirMenu(self.getMenuTable(), 'None', 'None')
+      
+    #POLECAMY
+    if self.name == 'main-menu' and self.title == self.setTable()[1]:
+      data = self.api.getAPIData('content', self.api.makeListQuery({"context":"onet/vod", "method":"guideListsByType", "sort":"DEFAULT", "type":"mobile-sg-polecane", "guidelistView":"listitem"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'][0]['contentLeads'], ['title','ckmId','videoId']), 'movie', 'None')
+      except: printExc()      
+
+    #BAJKI
+    if self.name == 'main-menu' and self.title == self.setTable()[6]:    
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/bajki", "method":"search", "sort":"DATE_DESC", "noSeriesGroup":"True"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['title','ckmId','videoId']), 'movie', 'None')
+      except: printExc()   
+    #SERIALE
+    if self.name == 'main-menu' and self.title == self.setTable()[3]:  
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"search", "sort":"DATE_DESC", "channel":"seriale"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['seriesTitle','season','seriesId']), self.name, self.setTable()[3]) # sometimes in returnet data seriesTitle is missing
+      except: printExc()
+    #SERIALE
+    if self.name == 'main-menu' and self.title == self.setTable()[4]:  
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"search", "sort":"DATE_DESC", "channel":"tv"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['seriesTitle','season','seriesId']), self.name, self.setTable()[4])
+      except: printExc()   
+      
+    #KATEGORIE FILMOWE
+    if self.name == 'main-menu' and self.title == self.setTable()[2]:
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"aggregates", "sort":"TITLE_ASC", "channel":"filmy", "names":"genres"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'][0]['items'], ['name','','']), self.name, self.setTable()[2])
+      except: printExc()
+    #DOKUMENTY (moze zwracac items jako film lub jako serial)
+    if self.name == 'main-menu' and self.title == self.setTable()[5]:
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"search", "sort":"POPULARITY_DESC", "channel":"dokumenty"}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['seriesTitle','ckmId','seriesId'], ['title','ckmId','videoId']), 'movie', 'None')
+      except: printExc()
+      
+    #sub-menu
+    #filmy w kategoriach
+    if self.name == 'sub-menu' and self.category == self.setTable()[2]:
+      printDBG( "filmy w kategoriach" )
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"search", "sort":"POPULARITY_DESC", "channel":"filmy", "genre":self.title}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['title','ckmId','videoId']), 'movie', 'None')
+      except: printExc()
+      
+    #sezony w serialu
+    if self.name == 'sub-menu' and self.cm.isNumeric(self.category):
+      printDBG( "sezony w serialu" )
+      self.listsAddDirMenu(self.listsSeasons(self.url, self.category), 'series','None')
+
+    #serial bez sezonu
+    if self.name == 'sub-menu' and self.category == 'None':
+      printDBG( "sezony w serialu" )
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"episodes", "sort":"DATE_DESC", "seriesId":int(self.url)}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['title','ckmId','episode']), 'playSeries', 'None')     
+      except: printExc()
+      
+    #odcinki w sezonie
+    if self.name == 'series':
+      printDBG( "odcinki w sezonie" )
+      data = self.api.getAPIData('video', self.api.makeListQuery({"context":"onet/vod", "method":"episodes", "sort":"DATE_DESC", "seriesId":int(self.url), "season":int(self.category)}))
+      try: self.listsAddDirMenu(self.listsItems(data['result']['data'], ['title','ckmId','episode']), 'playSeries', 'None')
+      except: printExc()
+        
+    printDBG("vodonet.handleService NO_ENTRY")
+
+class API:
+  def __init__(self):
+    porxyUrl = config.plugins.iptvplayer.proxyurl.value
+    useProxy = config.plugins.iptvplayer.proxyOnet.value
+    self.cm = pCommon.common(porxyUrl, useProxy)
+
+  def getVideoTab(self, ckmId):
+    #MD5('gastlich') = d2dd64302895d26784c706717a1996b0
+    #contentUrl = 'http://vod.pl/' + ckmId + ',d2dd64302895d26784c706717a1996b0.html?dv=aplikacja_androidVOD%2Ffilmy&back=onetvod%3A%2F%2Fback'     
+    tm = str(int(time.time() * 1000))
+    jQ = str(random.randrange(562674473039806,962674473039806))
+    authKey = '22D4B3BC014A3C200BCA14CDFF3AC018'
+    contentUrl = 'http://qi.ckm.onetapi.pl/?callback=jQuery183040'+ jQ + '_' + tm + '&body%5Bid%5D=' + authKey + '&body%5Bjsonrpc%5D=2.0&body%5Bmethod%5D=get_asset_detail&body%5Bparams%5D%5BID_Publikacji%5D=' + ckmId + '&body%5Bparams%5D%5BService%5D=vod.onet.pl&content-type=application%2Fjsonp&x-onet-app=player.front.onetapi.pl&_=' + tm
+    valTab = []
+    query_data = {'url': contentUrl, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+    try: 
+        data = self.cm.getURLRequestData(query_data)
+        #extract json
+        result = json.loads(data[data.find("(")+1:-2])
+        strTab = []
+        for items in result['result']['0']['formats']['wideo']:
+            for i in range(len(result['result']['0']['formats']['wideo'][items])):
+                strTab.append(items)
+                strTab.append(result['result']['0']['formats']['wideo'][items][i]['url'].encode('UTF-8'))
+                if result['result']['0']['formats']['wideo'][items][i]['video_bitrate']:
+                    strTab.append(int(float(result['result']['0']['formats']['wideo'][items][i]['video_bitrate'])))
+                else:
+                    strTab.append(0)
+                valTab.append(strTab)
+                strTab = []
+    except: 
+        printExc()
+    return valTab
+    
+  def getPoster(self, h):
+    posterUrl = 'http://m.ocdn.eu/_m/' + h + ',10,1.jpg'
+    return posterUrl
+
+  def getAPIData(self, module, post_data):
+    query_data = {'url': vodonet.MODULE_URL[module], 'use_host': False, 'use_header': True, 'header': vodonet.HEADER, 'use_cookie': False, 'use_post': True, 'raw_post_data': True, 'return_data': True}
+    result = {}
+    try:
+        data = self.cm.getURLRequestData(query_data, post_data)
+        result = json.loads(data)
+        #printDBG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
+        #printDBG(data)
+        #printDBG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
+    except: printExc()
+    return result
+
+  def makeListQuery(self, p):
+    args =   {"device":"mobile", "withoutDRM":"True", "payment":["-svod","-ppv"]}
+    params = {"context":"", "method":"", "sort":"", "range":[0,10000], "args":args}
+    dict =   {"id":"query_cmsQuery", "jsonrpc":"2.0", "method":"cmsQuery", "params":params}
+    for key in p.keys():
+        if any(key in s for s in ['context','method','sort']): 
+            dict['params'][key] = p[key]
+        else:
+            dict['params']['args'][key] = p[key]
+    return json.dumps(dict)
+
+  def makeVideoDetailsQuery(self, p):
+    args =   {"device":"mobile", "withoutDRM":"True", "payment":["-svod","-ppv"]}
+    params = {"id":0, "context":"", "object":"Video", "WithoutDRM":"True", "args":args}
+    dict =   {"id":"query_cmsGet", "jsonrpc":"2.0", "method":"cmsGet", "params":params}
+    for key in p.keys():
+        dict['params'][key] = p[key]
+    return json.dumps(dict)
+
+def _getLinkQuality( itemLink ):
+    return int(itemLink[2])
+
+class IPTVHost(IHost):
+
+    def __init__(self):
+        self.onet = None
+        self.currIndex = -1
+        self.listOfprevList = [] 
+    
+    # return firs available list of item category or video or link
+    def getInitList(self):
+        self.onet = vodonet()
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        
+        self.onet.handleService(self.currIndex)
+        convList = self.convertList(self.onet.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return List of item from current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible 
+    # server instead of cache 
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        self.listOfprevList.append(self.onet.getCurrList())
+        
+        self.currIndex = Index
+        self.onet.handleService(Index)
+        convList = self.convertList(self.onet.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return prev requested List of item 
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getPrevList(self, refresh = 0):
+        if(len(self.listOfprevList) > 0):
+            onetList = self.listOfprevList.pop()
+            self.onet.setCurrList(onetList)
+            convList = self.convertList(onetList)
+            return RetHost(RetHost.OK, value = convList)
+        else:
+            return RetHost(RetHost.ERROR, value = [])
+        
+    # return current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getCurrentList(self, refresh = 0):
+        if refresh == 1:
+            self.onet.handleService(self.currIndex, refresh)
+        convList = self.convertList(self.onet.getCurrList())
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return list of links for VIDEO with given Index
+    # for given Index
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.onet.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+            
+        if self.onet.currList[Index].name != 'playSelectedMovie':
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+            
+        retlist = []
+        videoID = self.onet.currList[Index].category
+        
+        tab = self.onet.api.getVideoTab(self.onet.currList[Index].category)
+        if config.plugins.iptvplayer.onetvodUseDF.value:
+            maxRes = int(config.plugins.iptvplayer.onetvodDefaultformat.value) * 1.1
+            tab = CSelOneLink( tab, _getLinkQuality, maxRes ).getOneLink()
+
+        for item in tab:
+            if item[0] == vodonet.FORMAT:
+                nameLink = "type: %s \t bitrate: %s" % (item[0], item[2])
+                url = item[1]
+                retlist.append(CUrlItem(nameLink.encode('utf-8'), url.encode('utf-8'), 0))
+            
+        return RetHost(RetHost.OK, value = retlist)
+        
+    # return resolved url
+    # for given url
+    def getResolvedURL(self, url):
+        if url != None and url != '':
+            ret = self.onet.resolveUrl(url)
+            list = []
+            list.append(ret)
+            return RetHost(RetHost.OK, value = list)
+        else:
+            return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+            
+    # return full path to player logo
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [GetLogoDir('onetvodlogo.png')])
+
+    def convertList(self, onetList):
+        hostList = []
+        
+        for onetItem in onetList:
+            hostLinks = []
+                
+            type = CDisplayListItem.TYPE_UNKNOWN
+            if onetItem.name != 'playSelectedMovie':
+                type = CDisplayListItem.TYPE_CATEGORY
+            else:
+                type = CDisplayListItem.TYPE_VIDEO
+ 
+            hostItem = CDisplayListItem(name = onetItem.title, \
+                                        description = '', \
+                                        type = type, \
+                                        urlItems = hostLinks, \
+                                        urlSeparateRequest = 1, \
+                                        iconimage = onetItem.iconimage)
+            hostList.append(hostItem)
+        return hostList
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostspryciarze.py ./IPTVPlayer/hosts/Polish/hostspryciarze.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostspryciarze.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostspryciarze.py	2015-11-11 07:16:45.118414000 +0100
@@ -0,0 +1,548 @@
+# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, GetLogoDir,GetCookieDir, byteify
+
+###################################################
+# FOREIGN import
+###################################################
+import re
+import copy
+try:    import json 
+except: import simplejson as json
+
+###################################################
+def gettytul():
+    return 'Spryciarze'
+    
+class Spryciarze():
+    MAIN_URL = 'http://www.spryciarze.pl/'
+    MAIN_CATEGORIES_URL = MAIN_URL + 'kategorie/'
+    VIDEO_URL = MAIN_URL + 'player/player/xml_connect.php?code='
+    
+    NUM_PER_PAGE = 12
+    SEARCH_RES_PER_PAGE = 30
+    
+    def __init__(self):
+        self.COOKIEFILE = GetCookieDir('spryciarze.cookie')
+        self.cm = pCommon.common()
+        self.up = urlparser.urlparser()
+        self.catTree = []
+        self.currList = []
+        
+    def getCurrList(self):
+        return self.currList
+
+    def setCurrList(self, list):
+        self.currList = list
+        return 
+
+    def getMainCategory(self):
+        printDBG('Spryciarze.getMainCategory')
+        
+        self.catTree = []
+        self.currList = []
+        
+        query_data = {'url': self.MAIN_CATEGORIES_URL, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('Spryciarze.getMainCategory getURLRequestData except')
+            return
+           
+        # clear punks
+        printDBG('Before clear')
+        pos = data.find('<div class="content_prawo">')
+        if pos > -1:
+            data = data[:pos]
+        printDBG('After clear')
+        
+        catTab = data.split('<div class="box_kategorie_item_head">')
+        # free memory
+        data = ''
+        if len(catTab) > 0 :
+            del catTab[0]
+            
+        printDBG('catTab len %d' % len(catTab))
+        
+        for i in range(len(catTab)):
+            subTab = catTab[i].split('<div class="box_kategorie_item_lista">')
+            # Free memory
+            catTab[i] = ''
+            
+            if 2 == len(subTab):
+                # Get Main category data
+                pattern = '<div class="box_kategorie_item_head_ico (.+?)"></div>.+?<a href="(.+?)" class="box_kategorie_item_head_tytul">(.+?)</a>.+?<div class="box_kategorie_item_head_ilosc">\(([0-9]+?)\)</div>.+?<div class="box_kategorie_item_head_bottom">'
+                match = re.compile(pattern, re.DOTALL).findall(subTab[0])
+                
+                if len(match) == 1:
+                    catItem = {'type': 'main', 'url': match[0][1], 'name': match[0][2], 'ilosc': match[0][3], 'subCatList': []}
+                    self.currList.append(catItem)
+
+                else:
+                    printDBG('getMainCategory ignore wrong data for category')
+            else:
+                printDBG('getMainCategory ignore wrong data for category: 2 != len(subTab)')
+                
+        catItem = {'type': 'search', 'name': 'Wyszukaj', 'subCatList': []}
+        self.currList.append(catItem)
+        
+        return
+    # end getMainCategory
+    
+    def getSubCategory(self, index):
+        printDBG('Spryciarze.getSubCategory')
+        
+        item = self.currList[index]
+        
+        self.catTree = []
+        self.currList = []
+        
+        query_data = {'url': item['url'], 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('Spryciarze.getMainCategory getURLRequestData except')
+            return
+            
+        # clear punks
+        printDBG('Before clear')
+        pos = data.find('<div class="content_prawo">')
+        if pos > -1:
+            data = data[:pos]
+        printDBG('After clear')
+        
+        catTab = data.split('<div class="box_kategorie_item_head">')
+        # free memory
+        data = ''
+        if len(catTab) > 0 :
+            del catTab[0]
+            
+        printDBG('catTab len %d' % len(catTab))
+        
+        for i in range(len(catTab)):
+            subTab = catTab[i].split('<div class="box_kategorie_item_lista">')
+            # Free memory
+            catTab[i] = ''
+            
+            if 2 == len(subTab):
+                # Get Main category data
+                pattern = '<div class="box_kategorie_item_head_ico (.+?)"></div>.+?<a href="(.+?)" class="box_kategorie_item_head_tytul">(.+?)</a>.+?<div class="box_kategorie_item_head_ilosc">\(([0-9]+?)\)</div>.+?<div class="box_kategorie_item_head_bottom">'
+                match = re.compile(pattern, re.DOTALL).findall(subTab[0])
+                
+                if len(match) == 1:
+                    catItem = {'type': 'sub', 'url': match[0][1], 'name': match[0][2], 'ilosc': match[0][3], 'subCatList': []}
+                    
+                    #Get sub-categories data
+                    pattern = '<a href="(.+?)"[^>]*?>(.+?)<span> \(([0-9]+?)\)</span></a>'
+                    match = re.compile(pattern, re.DOTALL).findall(subTab[1])
+
+                    for j in range(len(match)):
+                        subItem = {'type': 'subSub', 'url': match[j][0], 'name': match[j][1], 'ilosc': match[j][2]}                        
+                        catItem['subCatList'].append(subItem)
+                        
+                    if(len(catItem['subCatList'])):
+                        self.catTree.append(catItem)
+                    else:
+                        printDBG('getMainCategory main category ingnored because it does not have sub categories')
+                    
+                else:
+                    printDBG('getMainCategory ignore wrong data for category')
+            else:
+                printDBG('getMainCategory ignore wrong data for category: 2 != len(subTab)')
+                
+        self.currList = self.catTree
+        
+        if 1 == len(self.currList):
+            self.getSubSubCategory(0)
+        
+        return
+    # end getSubCategory
+    
+    def getSubSubCategory(self, index):
+        printDBG('Spryciarze.getSubSubCategory')
+        self.currList = self.catTree[index]['subCatList']
+        
+        if 1 == len(self.currList):
+            self.getItemsForCat(0)
+        
+        return
+    # end getSubCategory
+    
+    def getItemsForCat(self, index):
+        printDBG('Spryciarze.getItemsForCat')
+        try:
+            item = self.currList[index]
+            self.currList = []
+            itemNum = int(item['ilosc'])
+            
+            pageNum = itemNum / self.NUM_PER_PAGE
+            
+            if itemNum % self.NUM_PER_PAGE > 0:
+                pageNum += 1
+            
+            for i in range(pageNum):
+                tmpItem = copy.deepcopy(item)
+                tmpItem['type'] = 'subSubPage'
+                tmpItem['url'] += '/page:%d' % (i + 1)
+                tmpItem['name'] = 'Strona %d' % (i + 1)
+                tmpItem.pop("ilosc", None)
+                self.currList.append(tmpItem)
+                
+            if 1 == len(self.currList):
+                self.getVideoList2(item['url'])
+                
+        except:
+            printDBG('Spryciarze.getItemsForCat except')
+        
+        return
+    # end getSubCategory
+    
+    def getSearchResut(self, pattern):
+        printDBG('Spryciarze.getSearchResut')
+        self.currList = []
+        
+        SEARCH_URL = self.MAIN_URL + 'szukaj/' + pattern + '/page:1/sort:score?sq=' + pattern
+        
+        query_data = {'url': SEARCH_URL, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('getVideoList getURLRequestData except')
+            return
+        
+        match = re.compile('<h3>Wideoporadniki \(([0-9]+?)\)</h3>').findall(data)
+        if 0 == len(match): return
+        
+        itemNum = int(match[0])
+        pageNum = itemNum / self.SEARCH_RES_PER_PAGE
+        
+        if itemNum % self.SEARCH_RES_PER_PAGE > 0:
+            pageNum += 1
+        
+        for i in range(pageNum):
+            tmpItem = {}
+            tmpItem['type'] = 'subSubPage'
+            tmpItem['url'] =  self.MAIN_URL + 'szukaj/' + pattern + ( '/page:%d' % (i+1) ) + '/sort:score?sq=' + pattern
+            tmpItem['name'] = 'Strona %d' % (i + 1)
+            
+            if (i+1) < pageNum:
+                tmpItem['opis'] = 'Wyniki wyszukiwania od %d do %d' % ( i * self.SEARCH_RES_PER_PAGE + 1, (i + 1) * self.SEARCH_RES_PER_PAGE )
+            else:
+                tmpItem['opis'] = 'Wyniki wyszukiwania od %d do %d' % ( i * self.SEARCH_RES_PER_PAGE + 1, itemNum )
+                
+            self.currList.append(tmpItem)
+            
+        if 1 == len(self.currList):
+            self.getVideoList2(self.currList[0]['url'])
+            
+        
+    
+    def getVideoList2(self, url):
+        printDBG('Spryciarze.getVideoList')
+        self.currList = []
+        
+        if None == url or 0 == len(url):
+            return
+        
+        query_data = {'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            printDBG('getVideoList getURLRequestData except')
+            return
+        
+        # clear punks
+        pos = data.find('<div class="content_prawo">')
+        if pos > -1:
+            data = data[pos:]
+        tab = data.split('<div class="box_film">')
+        data = '' # free memory
+        if len(tab) > 0 :
+            del tab[0]
+            
+        printDBG('getVideoList tab_len %d' % len(tab))
+        
+        searchItems = [ {'keys': ['url'], 'req': False, 'pattern': '<a href="([^"]+?)" class="film_minicont">'},
+                        {'keys': ['ico'], 'req': False, 'pattern': '<span class="film_mini"><img src="([^"]+?)"'},
+                        {'keys': ['odslony'], 'req': False, 'pattern': '<span><span class="film_odslony"></span>.+?: <span>([0-9]+?)</span></span>'},
+                        {'keys': ['odslony'], 'req': False, 'pattern': '<span><span class="film_odslony"></span>.+?: <span>([0-9]+?)</span></span>'},
+                        {'keys': ['data', 'godzina'], 'req': False, 'pattern': '<span><span class="film_data"></span>dodane: <span>([0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]) ([0-9][0-9]:[0-9][0-9])</span></span>'},
+                        {'keys': ['opis'], 'req': False, 'pattern': '<p class="film_opis">([^<]+?)</p>'},
+                        {'keys': ['url', 'name'], 'req': True, 'pattern': '<a href="([^"]+?)" class="film_tytul">([^<]+?)</a>'},
+                       ]
+        
+        for i in range(len(tab)):
+            videoItem = {}
+            videoItem['type'] = 'video'
+            
+            ignore = False
+            for it in searchItems:
+                match = re.compile(it['pattern'], re.DOTALL).findall(tab[i])
+                
+                if 1 != len(match):
+                    printDBG('Brak ' + it['keys'][0])
+                    if it['req']:
+                        ignore = True
+                        break
+                    else:
+                        continue
+                else:
+                    printDBG('Znaleziono ' + it['keys'][0])
+                        
+                keyNums = len(it['keys'])
+                if( keyNums > 1 ):
+                    for j in range(keyNums):
+                        videoItem[it['keys'][j]] = match[0][j]
+                else:
+                    videoItem[it['keys'][0]] = match[0]
+            
+            # Clear checked part to free memory
+            tab[i] = ''
+            if False == ignore:
+                self.currList.append(videoItem)
+
+        printDBG('Spryciarze.getVideoList len(self.currList): %d' % len(self.currList))
+        return
+    # end getVideoList
+    
+    def getVideoLinks(self, url):
+        printDBG('Spryciarze.getVideoLink: ' + url)
+        
+        linkstTab = []
+        if None == url or 0 == len(url):
+            return linkstTab
+        
+        post_data = None
+        tries = 2
+        while tries > 0:
+            tries -= 1
+            # get videoID
+            sts, data = self.cm.getPage(url, {'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': self.COOKIEFILE}, post_data)
+            if not sts: return []
+            
+            sts, block = self.cm.ph.getDataBeetwenMarkers(data, '<div class="film_blokada">', '</form>', False)
+            if sts:
+                url = self.cm.ph.getSearchGroups(block, 'action="(http[^"]+?)"')[0]
+                val_s = self.cm.ph.getSearchGroups(block, 'name="s"[^>]*?value="([^"]+?)"')[0]
+                post_data = {}
+                post_data['s'] = val_s
+                post_data['yes'] = ''
+                continue
+            
+            player = self.cm.ph.getSearchGroups(data, 'src="(http://player.spryciarze.pl[^"]+?)"')[0]
+            sts, player = self.cm.getPage(player, {'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': self.COOKIEFILE})
+            if not sts: break
+            player = self.cm.ph.getSearchGroups(player, 'var data[^=]*?=[^\{]*?(\{[^;]+?);')[0]
+            try:
+                printDBG(player)
+                player = byteify(json.loads(player))
+                player = player['mediaFiles']
+                for item in player:
+                    if 'mp4' in item['type']:
+                        linkstTab.append({'name':'Native player', 'url':item['src']})
+            except:
+                printExc()
+            if len(linkstTab):
+                break
+        return linkstTab
+    # end getVideoLink
+    
+    def handleService(self, index, refresh = 0, searchPattern = ''):
+    
+        if 0 == refresh:
+            if len(self.currList) <= index:
+                printDBG( "Spryciarze.handleService wrong index: %s, len(self.currList): %d" % (index, len(self.currList)) )
+                return
+        
+            if -1 == index:
+                self.type = None
+                printDBG( "Spryciarze.handleService for first self.category" )
+            else:
+                item = self.currList[index]
+                self.type = item['type']
+                self.index = index
+                self.url = ''
+                if 'url' in self.currList[index]:
+                    self.url = self.currList[index]['url']
+                self.prevList = self.currList
+
+                printDBG( "|||||||||||||||||||||||||||||||||||| %s " % item['type'] )
+
+    #MAIN MENU
+        if self.type == None:
+            self.getMainCategory()
+    #SUB CATEGORY
+        elif self.type == 'main':
+            self.getSubCategory( self.index )
+    #SUB_SUB_CATEGORY
+        elif self.type == 'sub':
+            self.getSubSubCategory( self.index )
+    #SUB__SUB_PAGES
+        elif self.type == 'subSub':
+            self.getItemsForCat( self.index )
+    #VIDEOS
+        elif self.type == 'subSubPage':
+            self.getVideoList2( self.url )
+    #SEARCH
+        elif self.type == 'search':
+            self.getSearchResut( searchPattern )
+    # end handleService
+
+class IPTVHost(IHost):
+
+    def __init__(self):
+        self.host = None
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        
+        self.searchPattern = ''
+    
+    # return firs available list of item category or video or link
+    def getInitList(self):
+        self.host = Spryciarze()
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        
+        self.host.handleService(self.currIndex)
+        
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return List of item from current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible 
+    # server instead of cache 
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        self.listOfprevList.append(self.host.getCurrList())
+        
+        self.currIndex = Index
+        self.host.handleService(Index, refresh, self.searchPattern)
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return prev requested List of item 
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getPrevList(self, refresh = 0):
+        if(len(self.listOfprevList) > 0):
+            hostList = self.listOfprevList.pop()
+            self.host.setCurrList(hostList)
+            convList = self.convertList(hostList)
+            return RetHost(RetHost.OK, value = convList)
+        else:
+            return RetHost(RetHost.ERROR, value = [])
+        
+    # return current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getCurrentList(self, refresh = 0):      
+        if refresh == 1:
+            if len(self.listOfprevList) > 0:
+                hostList = self.listOfprevList.pop()
+                self.host.setCurrList(hostList)
+                return self.getListForItem(self.currIndex)
+            else:
+                return self.getInitList()           
+                
+        convList = self.convertList(self.host.getCurrList())
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return list of links for VIDEO with given Index
+    # for given Index
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            print "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index)
+            return RetHost(RetHost.ERROR, value = [])
+        
+        selItem = self.host.currList[Index]
+        if selItem['type'] != 'video':
+            print "ERROR getLinksForVideo - current item has wrong type"
+            return RetHost(RetHost.ERROR, value = [])
+            
+        retlist = []
+        
+        if None != selItem and 'url' in selItem and 1 < len(selItem['url']):
+            tmpList = self.host.getVideoLinks( selItem['url'] )
+            
+            for item in tmpList:
+                retlist.append(CUrlItem(item['name'], item['url'], 0))
+            
+        return RetHost(RetHost.OK, value = retlist)
+            
+    def getSearchResults(self, searchpattern, searchType = None):
+        self.isSearch = True
+        retList = []
+        self.searchPattern = searchpattern.replace(' ',  '%20')
+        
+        return self.getListForItem( len(self.host.getCurrList()) -1 )
+            
+    # return full path to player logo
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [ GetLogoDir('spryciarzelogo.png') ])
+
+
+    def convertList(self, cList):
+        hostList = []
+        possibleTypesOfSearch = []
+        
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            
+            if cItem['type'] in ['main', 'sub',  'subSub', 'subSubPage']:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type']  == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                videoID = ''
+                if 'url' in cItem:
+                    url = cItem['url']
+                hostLinks.append(CUrlItem('', url, 0))
+            elif cItem['type']  == 'search':
+                type = CDisplayListItem.TYPE_SEARCH
+                
+            name = ' '
+            if 'name' in cItem:
+                name = cItem['name']
+            opis = ''
+            if 'opis' in cItem:
+                opis = cItem['opis']
+            ilosc = ''
+            if 'ilosc' in cItem:
+                ilosc = '(' + cItem['ilosc'] + ')'
+            ico = ''
+            if 'ico' in cItem:
+                ico = cItem['ico']
+
+            hostItem = CDisplayListItem(name = name + ' ' + ilosc,
+                                        description = opis,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = ico,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+        # end for
+            
+        return hostList
+
+
+
+          
+#host = Spryciarze()
+#host.getMainCategory()
+#host.getVideoList('http://kulinaria.spryciarze.pl/kategorie/dania-miesne')
+#host.getVideoLinks('58763')
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hosttvn24.py ./IPTVPlayer/hosts/Polish/hosttvn24.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hosttvn24.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hosttvn24.py	2015-11-05 22:26:57.917660252 +0100
@@ -0,0 +1,393 @@
+# -*- coding: utf-8 -*-
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, remove_html_markup, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import re
+try:    import json
+except: import simplejson as json
+from Components.config import config, ConfigSelection, getConfigListEntry
+###################################################
+
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.TVN24httpType = ConfigSelection(default = "http://", choices = [("http://", "http://"),("https://", "https://")])
+   
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry("Typ połączenia:", config.plugins.iptvplayer.TVN24httpType))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'TVN 24'
+
+class Tvn24(CBaseHostClass):
+    HOST           = 'Apache-HttpClient/UNAVAILABLE (java 1.4)'
+    API_KEY        = '70487a5562bef96d33225a1df16ec081'
+    MAIN_URL       = 'http://api.tvn24.pl'
+    ITEMS_PER_PAGE = '20'
+    
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'SeansikTV'})
+        
+    def getStr(self, v, default=''):
+        if None == v:
+            return default
+        return v.encode('utf-8')
+        
+    def converUrl(self, url):
+        if "http://" == config.plugins.iptvplayer.TVN24httpType.value and url.startswith("https://"):
+            return "http" + url[5:]
+        return url
+
+    def getIconFromRelated(self, item):
+        # get icon
+        icon = ''
+        if None != item:
+            try:    icon = self.getStr( item['Main_Content_Photo']['url'] )
+            except: pass
+            if '' == icon:
+                try:    icon = self.getStr( item['Photo_Photo']['url'] )
+                except: pass
+            if '' == icon:
+                try:    icon = self.getStr( item['Headbg_Photo']['url'] )
+                except: pass
+        return icon
+
+    def listsMainMenu(self):
+        printDBG('listsMainMenu')
+        
+        VIDEO_PLAYLIST = Tvn24.MAIN_URL + '/video/playlists/' + Tvn24.API_KEY
+        MAIN_CATEGORIES = [
+            {'name': 'category', 'title': 'Najnowsze',     'category': 'end_cat',      'url': Tvn24.MAIN_URL + '/articles/newest/' + Tvn24.API_KEY + '/20' },
+            {'name': 'category', 'title': 'Najważniejsze', 'category': 'end_cat',      'url': Tvn24.MAIN_URL + '/articles/important/' + Tvn24.API_KEY },
+            {'name': 'category', 'title': 'Informacje',    'category': 'playlist',     'url': VIDEO_PLAYLIST + '/1'},
+            {'name': 'category', 'title': 'Magazyny',      'category': 'magazines',    'url': Tvn24.MAIN_URL + '/magazines/' + Tvn24.API_KEY + '/', 'page':'1' },
+            {'name': 'category', 'title': 'Kategorie',     'category': 'categories',   'url': Tvn24.MAIN_URL + '/categories/' + Tvn24.API_KEY },
+            ]
+        for item in MAIN_CATEGORIES:
+            self.addDir(item)
+
+    def listPlaylists(self, url):
+        printDBG("listPlaylist url[%s]" % (url))
+        try:
+            sts,data = self.cm.getPage( url, {'host' : Tvn24.HOST} )
+            data = json.loads( data )
+            for item in data:
+                title  = self.getStr( item.get('title', '') )
+                plot   = self.getStr( item.get('description', '') )
+                icon  = self.getStr( item.get('pht_url', '') )
+                videosNum = int(self.getStr( item.get('videos_count', '0'), '0'))
+                
+                if videosNum > 0:
+                    videos = item.get('videos', [])
+                    if len(videos) > 0:
+                        params = {'name': 'category', 'title': title, 'plot':plot, 'icon':icon, 'videos':list(videos), 'category': 'end_playlist', 'url': ''}
+                        self.addDir(params)
+        except:
+            printExc()
+            
+    def listPlaylistVideos(self, videos):
+        printDBG("listPlaylistVideos")
+        try:
+            for item in videos:
+                title  = self.getStr( item.get('title', '') )
+                plot   = self.getStr( item.get('description', '') )
+                icon   = self.getStr( item.get('still_url', '') )
+                url   = self.getStr( item.get('url', '') )
+
+                if url != '':
+                    params = {'title': title, 'url':url, 'icon':icon, 'plot':plot, 'tar_id':'', 'id':''}
+                    self.addVideo(params)
+        except:
+            printExc()
+            
+    def listSubCategories(self, category, subCategiories):
+        printDBG("listSubCategories")
+        try:
+            for item in subCategiories:
+                title  = self.getStr( item.get('name', '') )
+                id = int( self.getStr( item.get('id', '-1'), '-1' ) )
+                if id != -1:
+                    url = Tvn24.MAIN_URL + '/categories/articles/' + Tvn24.API_KEY + '/' + str(id)
+                    params = {'name': 'category', 'category': 'end_cat', 'parent_cat': category, 'title': title, 'url':url, 'page':'1'}
+                    self.addDir(params)
+        except:
+            printExc()
+            
+    def listCategories(self, category, baseUrl, page):
+        printDBG("listCategories category[%s] url[%s] page[%s]" % (category, baseUrl, page))
+        url = baseUrl
+        pagination = False
+        if '' != page:
+            if url[-1] != '/': url + ','
+            url += '%s,%s' % (page, Tvn24.ITEMS_PER_PAGE)
+            if '' != category:
+                pagination = True
+        nextPage = None
+        if 'magazines' == category and page == '1':
+            STATIC_MAGAZINES = [{'id':'FAKTY', 'name':'Fakty', 'icon':'http://www.tvnfakty.pl/assets/images/newsy_2012/nowaczolowka_big.jpg'},
+                                {'id':'SPORT', 'name':'Sport', 'icon':''},]
+            for item in STATIC_MAGAZINES:
+                sUrl = Tvn24.MAIN_URL + '/magazines/articles/' + Tvn24.API_KEY + '/' + item['id']
+                params = {'name': 'category', 'category': 'end_cat', 'parent_cat': category, 'title': item['name'], 'url':sUrl, 'icon':item['icon'], 'page':'1'}
+                self.addDir(params)
+        try:
+            sts,data = self.cm.getPage( url, {'host' : Tvn24.HOST} )
+            data = json.loads( data )
+            if pagination:
+                if int(data['pageCount']) > int(data['currentPageNumber']):
+                    nextPage = str(int(page) + 1)
+                data = data['items']
+            for item in data:
+                title  = self.getStr( item.get('title', '') )
+                plot   = self.getStr( item.get('lead', '') )
+                icon   = self.getIconFromRelated(item.get('related', None))
+                id     = int( self.getStr( item.get('tcg_id', '-1'), '-1' ) )
+                if -1 == id: id = int( self.getStr( item.get('id', '-1'), '-1' ) )
+
+                if id != -1:
+                    url = Tvn24.MAIN_URL + '/' + category + '/articles/' + Tvn24.API_KEY + '/' + str(id)
+                    if len(item.get('items', [])):
+                        currCat        = 'sub_categiories'
+                        subCategiories = item['items']
+                    else:
+                        currCat        = 'end_cat'
+                        subCategiories = []
+                    params = {'name': 'category', 'category': currCat, 'parent_cat': category, 'title': title, 'url':url, 'icon':icon, 'plot':plot, 'page':'1', 'sub_categiories':subCategiories}
+                    self.addDir(params)
+            if None != nextPage:
+                params = {'name': 'category', 'title': 'Następna strona', 'category': category, 'url': baseUrl, 'page':nextPage}
+                self.addDir(params)
+        except:
+            printExc()
+            
+    def listEndItems(self, parent_cat, baseUrl, page):
+        printDBG("listEndItems parent_cat[%s] baseUrl[%s], page[%s]" % (parent_cat, baseUrl, page))
+        url = baseUrl
+        pagination = False
+        if '' != page:
+            url += ',%s,%s' % (page, Tvn24.ITEMS_PER_PAGE)
+            if '' != parent_cat:
+                pagination = True
+        nextPage = None
+        try:
+            sts,data = self.cm.getPage( url, {'host' : Tvn24.HOST} )
+            data = json.loads( data )
+            if pagination:
+                if int(data['pageCount']) > int(data['currentPageNumber']):
+                    nextPage = str(int(page) + 1)
+                data = data['items']
+                
+            for item in data:
+                url = ''
+                title  = self.getStr( item.get('title', '') )
+                plot   = self.getStr( item.get('lead', '') )
+                id     = self.getStr( item.get('id', '') )
+                tar_id = self.getStr( item.get('tar_id', '') )
+                
+                # get icon
+                icon  = self.getStr( item.get('pht_main_content_url', '') )
+                if '' == icon: icon = self.getStr( item.get('pht_url', '') )
+                
+                # get data from related
+                item = item.get('related', None)
+                if None != item:
+                    if '' == icon: icon = self.getIconFromRelated(item)
+                    # get data from video url
+                    videoItem = item.get('Video_Video', None)
+                    if None != videoItem:
+                        if '' == title: title = self.getStr( videoItem.get('title', '') )
+                        if '' == plot:  plot  = self.getStr( videoItem.get('description', '') )
+                        if '' == icon: icon   = self.getStr( videoItem.get('still_url', '') )
+                        url                   = self.getStr( videoItem.get('url', '') )
+                        
+                if url != '' or tar_id != '' or id != '':
+                    params = {'title': title, 'url':url, 'icon':icon, 'plot':plot, 'tar_id':tar_id, 'id':id}
+                    if '' != url:
+                        self.addVideo(params)
+                    else:
+                        self.addArticle(params)
+                    
+            if None != nextPage:
+                params = {'name': 'category', 'title': 'Następna strona', 'category': 'end_cat', 'parent_cat':parent_cat, 'url': baseUrl, 'page':nextPage}
+                self.addDir(params)
+        except:
+            printExc()
+                
+    def getHostingTable(self, idx):
+        url = self.currList[idx].get('url', '')
+        printDBG("getHostingTable idx[%d] = url[%s]" % (idx, url))
+            
+        if url.startswith('http'):
+            return [{'name':'tvn24', 'url':self.converUrl(url)}]
+        return []
+        
+    def getArticleContent(self, idx):
+        printDBG('getArticleContent idx[%s]' % idx)
+        retList = []
+        articleID = self.currList[idx].get('tar_id', '')
+        if '' == articleID: 
+            articleID = self.currList[idx].get('id', '')
+            
+        if '' != articleID:
+            try:
+                url = Tvn24.MAIN_URL + '/articles/' + Tvn24.API_KEY + '/%s,0,1,10' % articleID
+                sts,data = self.cm.getPage( url, {'host' : Tvn24.HOST} )
+                data = json.loads( data )
+                data = data['getArticleDetail']
+                item = {}
+                item['title']  = self.getStr( data.get('title',     ''), '')
+                item['text']   = self.getStr( data.get('content',   ''), '').strip()
+                if '' == item['text']:
+                    item['text']   = self.getStr( data.get('lead',   ''), '').strip()
+                img_title    = self.getStr( data.get('pht_title', ''), '')
+                img_author   = self.getStr( data.get('pht_author',''), '')
+                img_url      = self.getStr( data.get('pht_url',   ''), '')
+                
+                item['images'] = [ {'title':img_title, 'author': img_author, 'url': img_url} ]
+                retList.append( item )
+            except:
+                printExc()
+        
+        return retList
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        name       = self.currItem.get("name", '')
+        title      = self.currItem.get("title", '')
+        category   = self.currItem.get("category", '')
+        parent_cat = self.currItem.get("parent_cat", '')
+        page     = self.currItem.get("page", '')
+        icon     = self.currItem.get("icon", '')
+        url      = self.currItem.get("url", '')
+        plot     = self.currItem.get("plot", '')
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if name == None:
+            self.listsMainMenu()
+    #VIDEO_PLAYLIST
+        elif category == 'playlist':
+            self.listPlaylists(url)
+        elif category == 'end_playlist':
+            self.listPlaylistVideos(self.currItem.get("videos", []))
+    #LIST VIDEOS
+        elif category == "end_cat":
+            self.listEndItems(parent_cat, url, page)
+    #LIST MAGAZINES
+        elif category == "magazines":
+            self.listCategories(category, url, page)
+    #LIST CATEGORIES
+        elif category == "categories":
+              self.listCategories(category, url, page)
+    #LIST SUB CATEGORIES
+        elif category == "sub_categiories":
+              self.listSubCategories(category, self.currItem.get("sub_categiories", []))
+              
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Tvn24(), False) # without search history
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('tvn24logo.png')])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] != 'video':
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+
+        retlist = []
+        urlList = self.host.getHostingTable(Index)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getArticleContent(self, Index = 0):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getArticleContent - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] != 'article':
+            printDBG( "ERROR getArticleContent - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        retlist = []
+        hList = self.host.getArticleContent(Index)
+        for item in hList:
+            title  = clean_html( item.get('title', '') )
+            text   = clean_html( item.get('text', '') )
+            images = item.get("images", [])
+            retlist.append( ArticleContent(title = title, text = text, images =  images) )
+        
+        return RetHost(RetHost.OK, value = retlist)
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+        #searchTypesOptions.append(("Seriale", "seriale"))
+        searchTypesOptions.append(("Filmy", "filmy"))
+    
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if cItem['type'] == 'category':
+                if cItem['title'] == 'Wyszukaj':
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+            elif cItem['type'] == 'article':
+                type = CDisplayListItem.TYPE_ARTICLE
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  clean_html( cItem.get('title', '').decode("utf-8")).encode("utf-8" )
+            description =  clean_html( cItem.get('plot', '').decode("utf-8")).encode("utf-8" )
+            icon        =  cItem.get('icon', '')
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
+
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hosttvnvod.py ./IPTVPlayer/hosts/Polish/hosttvnvod.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hosttvnvod.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hosttvnvod.py	2015-11-11 07:16:27.407273996 +0100
@@ -0,0 +1,502 @@
+# -*- coding: utf-8 -*-
+# Based on (root)/trunk/xbmc-addons/src/plugin.video.polishtv.live/hosts/ @ 419 - Wersja 605
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, SetIPTVPlayerLastHostError
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.libs.crypto.cipher import aes_cbc, base
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+import re
+import urllib
+import time
+import binascii
+try:    import simplejson as json
+except: import json
+from os import urandom as os_urandom
+try:
+    from hashlib import sha1
+except ImportError:
+    import sha
+    sha1 = sha.new
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Screens.MessageBox import MessageBox
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.TVNDefaultformat = ConfigSelection(default = "4", choices = [("0", "Najgorsza"), ("1", "Bardzo niska"), ("2", "Niska"),  ("3", "Średnia"), ("4", "Standard"), ("5", "Wysoka"), ("6", "Bardzo wysoka"), ("7", "HD"), ("9999", "Najlepsza")])
+config.plugins.iptvplayer.TVNUseDF = ConfigYesNo(default = False)
+config.plugins.iptvplayer.TVNdevice = ConfigSelection(default = "Samsung TV", choices = [("Mobile (Android)", "Mobile (Android)"),("Samsung TV", "Samsung TV")])
+config.plugins.iptvplayer.proxyenable = ConfigYesNo(default = False)
+   
+def GetConfigList():
+    optionList = []
+
+    optionList.append(getConfigListEntry("Domyślna jakość video:", config.plugins.iptvplayer.TVNDefaultformat))
+    optionList.append(getConfigListEntry("Używaj domyślnej jakości video:", config.plugins.iptvplayer.TVNUseDF))
+    optionList.append(getConfigListEntry("TVN-Przedstaw się jako:", config.plugins.iptvplayer.TVNdevice))
+    optionList.append(getConfigListEntry("TVN-korzystaj z proxy?", config.plugins.iptvplayer.proxyenable))
+
+    return optionList
+###################################################
+
+def gettytul():
+    return 'TVN Player'
+
+class TvnVod(CBaseHostClass):
+    HOST         = 'Mozilla/5.0 (SmartHub; SMART-TV; U; Linux/SmartTV; Maple2012) AppleWebKit/534.7 (KHTML, like Gecko) SmartTV Safari/534.7'
+    HOST_ANDROID = 'Apache-HttpClient/UNAVAILABLE (java 1.4)'
+    ICON_URL     = 'http://redir.atmcdn.pl/scale/o2/tvn/web-content/m/%s?quality=50&dstw=290&dsth=287&type=1'
+    
+    QUALITIES_TABLE = { 
+        'HD'            : 7,
+        'Bardzo wysoka' : 6,
+        'Wysoka'        : 5,
+        'Standard'      : 4,
+        'Średnia'       : 3,
+        'Niska'         : 2,
+        'Bardzo niska'  : 1,
+    }
+        
+    SERVICE_MENU_TABLE = [
+        "Kategorie",
+        "Wyszukaj",
+        "Historia wyszukiwania"
+    ]
+    
+    def __init__(self):
+        printDBG("TvnVod.__init__")
+        CBaseHostClass.__init__(self, {'history':'TvnVod', 'proxyURL': config.plugins.iptvplayer.proxyurl.value, 'useProxy': config.plugins.iptvplayer.proxyenable.value})
+        
+        if config.plugins.iptvplayer.TVNdevice.value == 'Samsung TV':
+            self.baseUrl = 'https://api.tvnplayer.pl/api?platform=ConnectedTV&terminal=Samsung&format=json&v=3.0&authKey=ba786b315508f0920eca1c34d65534cd'
+            userAgent = TvnVod.HOST
+        else:
+            self.baseUrl = 'https://api.tvnplayer.pl/api?platform=Mobile&terminal=Android&format=json&v=3.1&authKey=4dc7b4f711fb9f3d53919ef94c23890c' #b4bc971840de63d105b3166403aa1bea
+            userAgent = TvnVod.HOST_ANDROID
+        
+        self.cm.HEADER = {'User-Agent': userAgent, 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
+        self.itemsPerPage = 30 # config.plugins.iptvplayer.tvp_itemsperpage.value
+        self.loggedIn = None
+        self.ACCOUNT  = False
+        
+    def _getJItemStr(self, item, key, default=''):
+        v = item.get(key, None)
+        if None == v:
+            return default
+        return clean_html(u'%s' % v).encode('utf-8')
+        
+    def _getJItemNum(self, item, key, default=0):
+        v = item.get(key, None)
+        if None != v:
+            try:
+                NumberTypes = (int, long, float, complex)
+            except NameError:
+                NumberTypes = (int, long, float)
+                
+            if isinstance(v, NumberTypes):
+                return v
+        return default
+        
+    def _getIconUrl(self, cItem):
+        iconUrl = ''
+        try:
+            thumbnails = cItem.get('thumbnail', [])
+            if None != thumbnails:
+                # prefer jpeg files
+                pngUrl = ''
+                for item in thumbnails:
+                    tmp = self._getJItemStr(item, 'url')
+                    if tmp.endswith('jpg') or tmp.endswith('jpeg'):
+                        iconUrl = tmp
+                        break
+                    if tmp.endswith('png'): pngUrl = tmp
+                if '' == iconUrl: iconUrl = pngUrl
+                if '' != iconUrl: iconUrl = TvnVod.ICON_URL % iconUrl
+        except:
+            printExc()
+        return iconUrl
+        
+    def _generateToken(self, url):
+        url = url.replace('http://redir.atmcdn.pl/http/','')
+        SecretKey = 'AB9843DSAIUDHW87Y3874Q903409QEWA'
+        iv = 'ab5ef983454a21bd'
+        KeyStr = '0f12f35aa0c542e45926c43a39ee2a7b38ec2f26975c00a30e1292f7e137e120e5ae9d1cfe10dd682834e3754efc1733'
+        salt = sha1()
+        salt.update(os_urandom(16))
+        salt = salt.hexdigest()[:32]
+        tvncrypt = aes_cbc.AES_CBC(SecretKey, base.noPadding(), keySize=32)
+        key = tvncrypt.decrypt(binascii.unhexlify(KeyStr), iv=iv)[:32]
+        expire = 3600000L + long(time.time()*1000) - 946684800000L
+        unencryptedToken = "name=%s&expire=%s\0" % (url, expire)
+        pkcs5_pad = lambda s: s + (16 - len(s) % 16) * chr(16 - len(s) % 16)
+        pkcs5_unpad = lambda s : s[0:-ord(s[-1])]
+        unencryptedToken = pkcs5_pad(unencryptedToken)
+        tvncrypt = aes_cbc.AES_CBC(binascii.unhexlify(key), padding=base.noPadding(), keySize=16)
+        encryptedToken = tvncrypt.encrypt(unencryptedToken, iv=binascii.unhexlify(salt))
+        encryptedTokenHEX = binascii.hexlify(encryptedToken).upper()
+        return "http://redir.atmcdn.pl/http/%s?salt=%s&token=%s" % (url, salt, encryptedTokenHEX)
+        
+    def listsCategories(self, cItem):
+        printDBG("TvnVod.listsCategories cItem[%s]" % cItem)
+        
+        searchMode = False
+        page = 1 + cItem.get('page', 0)
+        if 'search' == cItem.get('category', None):
+            #https://api.tvnplayer.pl/api/?v=3.1&platform=Mobile&terminal=Android&format=json&authKey=4dc7b4f711fb9f3d53919ef94c23890c&limit=30&sort=&m=getSearchItems&isUserLogged=0&page=1&query=film
+            searchMode = True
+            urlQuery  = '&sort=newest&m=getSearchItems&page=%d&query=%s' % (page, cItem['pattern'])
+        elif None != cItem.get('category', None) and None != cItem.get('id', None):
+            groupName = 'items'
+            urlQuery = '&type=%s&id=%s&limit=%s&page=%s&sort=newest&m=getItems' % (cItem['category'], cItem['id'], self.itemsPerPage, page)
+            if 0 < cItem.get('season', 0):
+                urlQuery += "&season=%d" % cItem.get('season', 0)
+        else:
+            groupName = 'categories'
+            urlQuery = '&m=mainInfo'
+        
+        try:
+            url = self.baseUrl + urlQuery
+            sts, data = self.cm.getPage(url)
+            data = json.loads(data)
+            
+            if 'success' != data['status']:
+                printDBG("TvnVod.listsCategories status[%s]" % data['status'])
+                return 
+                
+            countItem = self._getJItemNum(data, 'count_items', None)
+            if None != countItem and countItem > self.itemsPerPage * page:
+                showNextPage = True
+            else:
+                showNextPage = False
+            
+            catalogs = False
+            if searchMode:
+                seasons = None
+                tmp = []
+                for resItem in data.get('vodProgramItems', {}).get('category', []):
+                    tmp.extend(resItem.get('items', []))
+                for resItem in data.get('vodArticleItems', {}).get('program', []):
+                    tmp.extend(resItem.get('items', []))
+                data = tmp
+                tmp = None
+            else:
+                seasons  = data.get('seasons', None)
+                # some fix for sub-categories
+                # and 0 < len(data.get('items', []))
+                if 0 < len(data.get('categories', [])) and cItem.get('previd', '') != cItem.get('id', ''):
+                    catalogs = True
+                    groupName = 'categories'
+                    showNextPage = False
+                data = data[groupName]
+            
+            showSeasons = False
+            if None != seasons and 0 == cItem.get('season', 0):
+                showSeasons = True
+                numSeasons = len(seasons)
+            else:
+                numSeasons = 0
+
+            if 0 != cItem.get('season', 0) or cItem.get('season', 0) == numSeasons:
+                for item in data:
+                    category = self._getJItemStr(item, 'type', '')
+                    id       = self._getJItemStr(item, 'id', '')
+                    # some fix for sub-categories
+                    if catalogs:
+                        if 'category' == category:
+                            category = 'catalog'
+                        if '0' == id:
+                            id = cItem['id']
+                    
+                    # get title 
+                    title = self._getJItemStr(item, 'name', '')
+                    if '' == title: title = self._getJItemStr(item, 'title', _('Brak nazwy'))
+                    tmp = self._getJItemStr(item, 'episode', '')
+                    if tmp not in ('', '0'): title += _(", odcinek ") + tmp
+                    tmp = self._getJItemStr(item, 'season', '')
+                    if tmp not in ('', '0'): title += _(", sezon ") + tmp
+                    try:
+                        tmp = self._getJItemStr(item, 'start_date', '')
+                        if '' != tmp:
+                            tmp = time.strptime(tmp, "%Y-%m-%d %H:%M")
+                            if tmp > time.localtime():
+                                title += _(" (planowany)")
+                    except:
+                        printExc()
+                    
+                    # get description
+                    desc = self._getJItemStr(item, 'lead', '')
+                    # get icon
+                    icon = self._getIconUrl(item)
+                
+                    params = { 'id'       : id,
+                               'previd'   : cItem.get('id', ''),
+                               'title'    : title,
+                               'desc'     : desc,
+                               'icon'     : icon,
+                               'category' : category,
+                               'season'   : 0,
+                             }
+                    if 'episode' == category:
+                        self.addVideo(params)
+                    else:
+                        self.addDir(params)
+            else:
+                showNextPage = False
+            
+            if showSeasons:
+                for season in seasons:
+                    params = { 'id'       : cItem['id'],
+                               'previd'   : cItem.get('id', ''),
+                               'title'    : self._getJItemStr(season, 'name', ''),
+                               'desc'     : '',
+                               'icon'     : self._getIconUrl(season),
+                               'category' : cItem['category'], #self._getJItemStr(season, 'type', ''),
+                               'season'   : self._getJItemNum(season, 'id', 0),
+                             }
+                    self.addDir(params)
+            if showNextPage:
+                params = dict(cItem)
+                params.update({'title':_('Następna strona'), 'page': page, 'icon':'', 'desc':''})
+                self.addDir(params)
+        except: 
+            printExc()
+
+        
+    def listSearchResults(self, pattern, searchType):
+        printDBG("TvnVod.listSearchResults pattern[%s], searchType[%s]" % (pattern, searchType))
+        params = { 'id'       : 0,
+                   'title'    : '',
+                   'desc'     : '',
+                   'icon'     : '',
+                   'category' : 'search',
+                   'pattern'  : pattern,
+                   'season'   : 0,
+                 }
+        self.listsCategories(params)
+
+    def listsMainMenu(self):
+        for item in TvnVod.SERVICE_MENU_TABLE:
+            params = {'name': 'category', 'title': item, 'category': item}
+            self.addDir(params)
+    
+    def resolveLink(self, url):
+        printDBG("TvnVod.resolveLink url[%s]" % url)
+        videoUrl = ''
+        if len(url) > 0:
+            if config.plugins.iptvplayer.TVNdevice.value == 'Mobile (Android)':
+                videoUrl = self._generateToken(url).encode('utf-8')
+            elif config.plugins.iptvplayer.TVNdevice.value == 'Samsung TV':
+                sts, data  = self.cm.getPage(url)
+                if sts and data.startswith('http'):
+                    videoUrl =  data.encode('utf-8')
+        return videoUrl
+            
+    def getLinksForVideo(self, cItem):
+        return self.getLinks(cItem['id'])
+    
+    def getLinks(self, id):
+        printDBG("TvnVod.getLinks cItem.id[%r]" % id )
+        videoUrls = []
+        
+        url = self.baseUrl + '&type=episode&id=%s&limit=%d&page=1&sort=newest&m=%s' % (id, self.itemsPerPage, 'getItem')
+        sts, data = self.cm.getPage(url)
+        if sts:
+            try:
+                data = json.loads(data)
+                if 'success' == data['status']:
+                    data = data['item']
+                    # videoTime = 0
+                    # tmp = self._getJItemStr(data, 'run_time', '')
+                    # if '' != tmp:
+                        # tmp = tmp.split(":")
+                        # videoTime = int(tmp[0])*60*60+int(tmp[1])*60+int(tmp[2])
+                     
+                    plot = self._getJItemStr(data, 'lead', '')
+                    printDBG("data:\n%s\n" % data)
+                    videos = data['videos']['main']['video_content']
+                    if None == videos:
+                        SetIPTVPlayerLastHostError("DRM protection.")
+                    else:
+                        for video in videos:
+                            url = self._getJItemStr(video, 'url', '')
+                            if '' == url:
+                                SetIPTVPlayerLastHostError("DRM protection.")
+                            #    url = self._getJItemStr(video, 'src', '')
+                            if '' != url:
+                                qualityName = self._getJItemStr(video, 'profile_name', '')
+                                videoUrls.append({'name':qualityName, 'profile_name':qualityName, 'url':url, 'need_resolve':1})
+                    if  1 < len(videoUrls):
+                        max_bitrate = int(config.plugins.iptvplayer.TVNDefaultformat.value)
+                        def __getLinkQuality( itemLink ):
+                            return int(TvnVod.QUALITIES_TABLE.get(itemLink['profile_name'], 9999))
+                        videoUrls = CSelOneLink(videoUrls, __getLinkQuality, max_bitrate).getSortedLinks()
+                        if config.plugins.iptvplayer.TVNUseDF.value:
+                            videoUrls = [videoUrls[0]]
+            except: printExc()
+        return videoUrls
+        
+    def getFavouriteData(self, cItem):
+        return str(cItem['id'])
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.getLinks(fav_data)
+
+    def tryTologin(self):
+        printDBG('tryTologin start')
+        if '' == self.LOGIN.strip() or '' == self.PASSWORD.strip():
+            printDBG('tryTologin wrong login data')
+            return False
+        
+        post_data = {'email':self.LOGIN, 'password':self.PASSWORD}
+        params = {'header':self.HEADER, 'cookiefile':self.COOKIE_FILE, 'use_cookie': True, 'save_cookie':True}
+        sts, data = self.cm.getPage( self.MAINURL + "logowanie.html", params, post_data)
+        if not sts:
+            printDBG('tryTologin problem with login')
+            return False
+            
+        if 'wyloguj.html' in data:
+            printDBG('tryTologin user[%s] logged with VIP accounts' % self.LOGIN)
+            return True
+     
+        printDBG('tryTologin user[%s] does not have status VIP' % self.LOGIN)
+        return False
+        
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('TvnVod..handleService start')
+        
+        if None == self.loggedIn and self.ACCOUNT:
+            self.loggedIn = self.tryTologin()
+            if not self.loggedIn:
+                self.sessionEx.open(MessageBox, 'Problem z zalogowaniem użytkownika "%s".' % self.LOGIN, type = MessageBox.TYPE_INFO, timeout = 10 )
+            else:
+                self.sessionEx.open(MessageBox, 'Zostałeś poprawnie \nzalogowany.', type = MessageBox.TYPE_INFO, timeout = 10 )
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        
+        # clear hosting tab cache
+        self.linksCacheCache = {}
+
+        name     = self.currItem.get("name", '')
+        category = self.currItem.get("category", '')
+        printDBG( "TvnVod.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if name == None:
+            self.listsMainMenu()           
+    #WYSZUKAJ
+        elif category == "Wyszukaj":
+            pattern = urllib.quote_plus(searchPattern)
+            printDBG("Wyszukaj: " + pattern)
+            self.listSearchResults(pattern, searchType)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "Historia wyszukiwania":
+            self.listsHistory()
+    #KATEGORIE
+        else:
+            self.listsCategories(self.currItem)
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, TvnVod(), True, [CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO])
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('tvnvodlogo.png')])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 1
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        url = self.host.resolveLink(url)
+        urlTab = []
+        if isinstance(url, basestring) and url.startswith('http'):
+            urlTab.append(url)
+        return RetHost(RetHost.OK, value = urlTab)
+
+    def converItem(self, cItem):
+        hostList = []
+        searchTypesOptions = []
+        
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if cItem['type'] == 'category':
+            if cItem['title'] == 'Wyszukaj':
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+            url = cItem.get('url', '')
+            if '' != url:
+                hostLinks.append(CUrlItem("Link", url, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  clean_html(cItem.get('desc', ''))
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                description = description,
+                                type = type,
+                                urlItems = hostLinks,
+                                urlSeparateRequest = 1,
+                                iconimage = icon,
+                                possibleTypesOfSearch = possibleTypesOfSearch)
+    # end converItem
+
+    def getSearchItemInx(self):
+        # Find 'Wyszukaj' item
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'Wyszukaj':
+                    return i
+        except:
+            printExc()
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex].get('name', ''):
+                pattern = list[self.currIndex]['title']
+                search_type = ''
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printExc()
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostwptv.py ./IPTVPlayer/hosts/Polish/hostwptv.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Polish/hostwptv.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Polish/hostwptv.py	2015-11-05 22:26:57.921660252 +0100
@@ -0,0 +1,448 @@
+# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSelOneLink, GetLogoDir
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+###################################################
+# FOREIGN import
+###################################################
+import re, urllib
+try:
+    import simplejson as json
+except:
+    import json
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.wpDefaultformat = ConfigSelection(default = "2", choices = [("1", "Niska"), ("2", "Wysoka")])
+config.plugins.iptvplayer.wpUseDF = ConfigYesNo(default = False)
+config.plugins.iptvplayer.wpSortBy = ConfigSelection(default = "2", choices = [("1", "Najczęściej oglądane"), ("2", "Najnowsze"), ("3", "Najwyżej oceniane"), ("4", "Najczęściej komentowane")])
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("Sort by:"), config.plugins.iptvplayer.wpSortBy))
+    optionList.append( getConfigListEntry( "Domyślny jakość video:", config.plugins.iptvplayer.wpDefaultformat ) )
+    optionList.append( getConfigListEntry( "Używaj domyślnej jakości video:", config.plugins.iptvplayer.wpUseDF ) )
+    return optionList
+###################################################
+
+def gettytul():
+    return 'WP.TV'
+
+class WP():
+    HOST = 'Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0'
+    def __init__(self):
+        self.cm = pCommon.common()
+        self.currList = []
+        
+    def getCurrList(self):
+        return self.currList
+
+    def setCurrList(self, list):
+        self.currList = list
+        return 
+    
+    def getMainMenu(self):
+        printDBG('getMainMenu start')
+        list = []
+        url = 'http://wp.tv/mindex.html'        
+        sts, data = self.cm.getPage(url, {'host': self.HOST})
+        if sts:
+            # extract menu html
+            idx = data.find('Strona główna')
+            if idx <= 0: return list
+            idx2 = data.find('Inne serwisy WP.PL', idx)
+            if idx2 <= 0: return list
+            data = data[idx:idx2]
+            
+            match = re.compile('<header class="grayBar round "><a class="a" href="([^"]+?mkategoria.html)">([^<]+?)</a>').findall(data)
+            if len(match) <= 0: return list
+            
+            printDBG("---------------------------------------------")
+            for i in range(len(match)):
+                list.append({'name':match[i][1], 'url':match[i][0], 'type':'main_item'})
+                printDBG("cat: " + match[i][1] + "\t: " + match[i][0])
+            printDBG("---------------------------------------------")
+        
+        return list
+        
+    def getSubMenu(self, url):
+        printDBG('getSubMenu start')
+        list = []
+        match = re.compile('http://wp.tv/type,([^,]+?),.+?.html').findall(url)
+        if len(match) <= 0: return list
+        jtype = match[0]
+        
+        sts, data = self.cm.getPage(url, {'host': self.HOST})
+        if sts:
+            match = re.compile('<option value="([0-9]+?)" >([^<]+?)</option>').findall(data)
+            if len(match) <= 0: return list
+            
+            printDBG("---------------------------------------------")
+            for i in range(len(match)):
+                list.append({'name':match[i][1], 'id':match[i][0], 'type':'sub_item', 'jtype' : jtype})
+                printDBG("\tcat: " + match[i][1] + '\t' + jtype + "\t: " + match[i][0])
+            printDBG("---------------------------------------------")
+        
+        return list
+        
+    def getJsonList(self, type, jtype, id):
+        printDBG('getJsonList start')
+        list = []
+        
+        url = 'http://wp.tv/mlista.json'
+        params = {'host': self.HOST }
+        postdata = { 'type': jtype, 'filter': config.plugins.iptvplayer.wpSortBy.value, "cid": id, "wrapperName" :"wptv2_lib_wrapper_CategoryListSourceWrapper" }
+
+        sts, data = self.cm.getPage(url, params, postdata)
+        if not sts: return list
+        #printDBG("+++++++++++++++++++++++++")
+        #printDBG(data)
+        #printDBG("+++++++++++++++++++++++++")
+        try:
+            result = json.loads(data)
+            if None != result['subMenu'] and type == 'sub_item':
+                printDBG( 'getJsonList get sub menu' )
+                sel_id = str(result['subMenu']['menuListSelected']['cid'])
+                printDBG( sel_id )
+                dataChecked = False
+                for item in result['subMenu']['menuList']:
+                    cid = str(result['subMenu']['menuList'][item]['cid'])
+                    name = result['subMenu']['menuList'][item]['name']
+                    if cid == sel_id:
+                        dataChecked = True
+                    else:
+                        printDBG("\t\t\t" + cid + "\t" + name)
+                        list.append({'name':name.encode('utf-8'), 'id':cid, 'type':'sub_jitem', 'jtype' : jtype})
+                if 0 < len(list) or not dataChecked:
+                    return list
+        except:
+            printExc()
+            return list
+        #data = result["jsPagination"]
+        #return self.getJsonPagesList(id, data)
+        return self.setDirMenu(self.getItems("http://wp.tv/app/cliplist?catid=" + id))
+            
+    def getJsonPagesList(self, id, data):
+        printDBG( 'getJsonPagesList id=%s  data=%s' % (id,data) )
+        list = []
+        try:
+            match = re.compile('data-allresults="([0-9]+?)" data-onpage="([0-9]+?)"').findall(data)
+            if len(match) > 0: 
+                itemNum = int(match[0][0])
+                numPerPage = int(match[0][1])
+                pageNum = itemNum / numPerPage
+                if itemNum % numPerPage > 0:
+                    pageNum += 1
+                
+                for i in range(pageNum):
+                    tmpItem = {'name': 'Strona %d' % (i+1), 'id':id, 'page': str(i+1), 'type':'page'}
+                    list.append(tmpItem)
+                    printDBG( tmpItem['name'] )
+            
+            if len(list) < 2:
+                return self.getJsonVideoList('1', id)
+            else:
+                return list
+        except: printExc()
+        return list
+        
+    def getJsonVideoList(self, page, id):
+        printDBG( 'getJsonVideoList page=%s  id=%s' % (page, id) )
+        list = []
+        url ="http://wp.tv/mlista.html?page=%s&filter=%s&cid=%s&subcid=%s&wrapperName=wptv2_lib_wrapper_CategoryListSourceWrapper" % (page, config.plugins.iptvplayer.wpSortBy.value, id, id)
+        sts, data = self.cm.getPage(url, {'host': self.HOST})
+        if sts:
+            try:
+                match = re.compile('<a href="([^"]+?)"><img src="([^"]+?)" alt=""><div class="matBox">([^<]+?)</div>').findall(data)
+                if len(match) <= 0: return list
+                
+                for i in range(len(match)):
+                    item = {'name':match[i][2], 'url':match[i][0], 'ico':match[i][1], 'type':'video'}
+                    list.append(item)
+                    printDBG( "name: " + item['name'].encode('utf-8') + " url: " + item["url"].encode('utf-8') + " ico: " + item['ico'].encode('utf-8'))
+            except: printExc()
+        return list
+            
+    def getVideoLinks(self, url, data = None):
+        if data != None: url = data
+        printDBG( 'getVideoLinks url=%s ' % url )
+        list = []
+        
+        if data == None:
+            url ="http://wp.tv/" + url
+            sts, data = self.cm.getPage(url, {'host': self.HOST})
+            if not sts: return list
+        
+        match = re.compile('(http://get\.wp\.tv/\?f=[0-9]+?\.[0-9]+?\.)').search(data)
+        if None == match: return list
+        
+        list.append({'name':'Wysoka jakosc', 'url': match.group(0) + 'h.mp4'})
+        list.append({'name':'Niska jakosc', 'url': match.group(0) + 'l.mp4'})
+        #list.append({'name':'Domyslna jakosc', 'url': match.group(0) + 'm3.mp4'})
+        
+        return list
+        
+    # code based on (root)/trunk/xbmc-addons/src/plugin.video.polishtv.live/hosts/ @ 635 - Wersja 669 
+    def getItems(self, url, clip = True):
+        strTab = []
+        valTab = []
+        sts, data = self.cm.getPage(url, {'host': self.HOST})
+        if sts:
+            try:
+                result = json.loads(data)
+                if clip:
+                    for item in result['clips']:
+                        strTab.append(item['clipUrl'])
+                        strTab.append(item['thumbnail'])            
+                        strTab.append(item['title'])
+                        strTab.append(item['description'])
+                        valTab.append(strTab)
+                        strTab = []
+                    if result['page'] != result['pageCount']:
+                        valTab.append([url + "&page=" + str(result['page']+1), '', 'Nastepna strona', 'nextpage'])
+                else:
+                    for item in result:
+                        #skip {"catId":4050,"name":"Najnowsze","description":"","logo":null,"priority":0}
+                        if item['name'] != 'Najnowsze':
+                            strTab.append(item['catId'])
+                            strTab.append(item['logo'])            
+                            strTab.append(item['name'])
+                            strTab.append(item['description'])
+                            valTab.append(strTab)
+                            strTab = []
+            except:
+                printExc()
+        return valTab
+        
+    def setDirMenu(self, table):
+        resList = []
+        for i in range(len(table)):
+            if self.cm.isNumeric(table[i][0]):
+                #self.addDir(SERVICE,"sub-menu",str(table[i][0]),self.cm.html_entity_decode(table[i][2].encode('UTF-8')),table[i][3].encode('UTF-8'),"",table[i][1])
+                printDBG("APP SUB MENU:")
+                printDBG("\t: " + str(table[i][0]))
+                printDBG("\t: " + self.cm.html_entity_decode(table[i][2].encode('UTF-8')))
+                printDBG("\t: " + table[i][3].encode('UTF-8'))
+                printDBG("\t: " + table[i][1])
+            else:
+                if table[i][3] == 'nextpage':
+                    item = {'name':self.cm.html_entity_decode(table[i][2].encode('UTF-8')), 'url':table[i][0], 'type':'app_cat'}
+                    resList.append(item)              
+                else:
+                    item = {'name':self.cm.html_entity_decode(table[i][2].encode('UTF-8')), 'url':table[i][0].encode('UTF-8'), 'ico':table[i][1], 'desc':table[i][3].encode('UTF-8'), 'type':'app_video'}
+                    resList.append(item)
+        return resList
+    
+    def handleService(self, index, refresh = 0, searchPattern = ''):
+    
+        if 0 == refresh:
+            if len(self.currList) <= index:
+                printDBG( "WP.handleService wrong index: %s, len(self.currList): %d" % (index, len(self.currList)) )
+                return
+        
+            if -1 == index:
+                self.type = None
+                printDBG( "WP.handleService for first self.category" )
+            else:
+                item = self.currList[index]
+                self.type = item['type']
+                self.index = index
+                self.url = ''
+                if 'url' in self.currList[index]:
+                    self.url = self.currList[index]['url']
+                self.jtype = ''
+                if 'jtype' in self.currList[index]:
+                    self.jtype = self.currList[index]['jtype']
+                self.id = ''
+                if 'id' in self.currList[index]:
+                    self.id = self.currList[index]['id']
+                self.page = ''
+                if 'page' in self.currList[index]:
+                    self.page = self.currList[index]['page']
+                    
+                self.prevList = self.currList
+
+                printDBG( "WP: |||||||||||||||||||||||||||||||||||| %s " % item['type'] )
+
+    #MAIN MENU
+        if self.type == None:
+            self.currList = self.getMainMenu()
+            self.currList.append({'name':"Polecane", 'url': "http://wp.tv/app/recommended?", 'type':'app_cat'})
+            self.currList.append({'name':"TOP100 Tygodnia", 'url': "http://wp.tv/app/toprated?type=week", 'type':'app_cat'})
+            self.currList.append({'name':"TOP100 Miesiąca", 'url': "http://wp.tv/app/toprated?type=month", 'type':'app_cat'})
+            self.currList.append({'name':"Wyszukaj", 'url': "http://wp.tv/app/search?queryType=2&query=", 'type':'app_search'})
+    #APP CATEGORY
+        elif self.type == 'app_cat':
+            self.currList = self.setDirMenu(self.getItems(self.url)) 
+    #SUB CATEGORY
+        elif self.type == 'main_item':
+            self.currList = self.getSubMenu('http://wp.tv/' + self.url)
+    #SUB_SUB_CATEGORY
+        elif self.type == 'sub_item' or self.type == 'sub_jitem':
+            self.currList = self.getJsonList(self.type, self.jtype, self.id)
+    #VIDEOS per page
+        elif self.type == 'page':
+            self.currList = self.getJsonVideoList(self.page, self.id)
+    #SEARCH
+        elif self.type == 'app_search':
+            self.currList = self.setDirMenu(self.getItems(self.url+ urllib.quote(searchPattern))) 
+    # end handleService
+
+#list = getVideoLinks( list[0]['url'] )
+
+def _getLinkQuality( itemLink ):
+    if itemLink['name'].find('Niska') > -1:
+        return 1
+    return 2
+
+class IPTVHost(IHost):
+
+    def __init__(self):
+        self.host = None
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        
+        self.searchPattern = ''
+    
+    # return firs available list of item category or video or link
+    def getInitList(self):
+        self.host = WP()
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        
+        self.host.handleService(self.currIndex)
+        
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return List of item from current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible 
+    # server instead of cache 
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        self.listOfprevList.append(self.host.getCurrList())
+        
+        self.currIndex = Index
+        self.host.handleService(Index, refresh, self.searchPattern)
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return prev requested List of item 
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getPrevList(self, refresh = 0):
+        if(len(self.listOfprevList) > 0):
+            hostList = self.listOfprevList.pop()
+            self.host.setCurrList(hostList)
+            convList = self.convertList(hostList)
+            return RetHost(RetHost.OK, value = convList)
+        else:
+            return RetHost(RetHost.ERROR, value = [])
+        
+    # return current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getCurrentList(self, refresh = 0):      
+        if refresh == 1:
+            if len(self.listOfprevList) > 0:
+                hostList = self.listOfprevList.pop()
+                self.host.setCurrList(hostList)
+                return self.getListForItem(self.currIndex)
+            else:
+                return self.getInitList()           
+                
+        convList = self.convertList(self.host.getCurrList())
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return list of links for VIDEO with given Index
+    # for given Index
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            print "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index)
+            return RetHost(RetHost.ERROR, value = [])
+        
+        selItem = self.host.currList[Index]
+        if selItem['type'] != 'video':
+            print "ERROR getLinksForVideo - current item has wrong type"
+            return RetHost(RetHost.ERROR, value = [])
+            
+        retlist = []
+        
+        if None != selItem and 'url' in selItem and 1 < len(selItem['url']):
+            tmpList = self.host.getVideoLinks( selItem['url'] )
+            if config.plugins.iptvplayer.wpUseDF.value:
+                maxRes = int(config.plugins.iptvplayer.wpDefaultformat.value)
+                tmpList = CSelOneLink( tmpList, _getLinkQuality, maxRes ).getOneLink()
+            
+            for idx in range(len(tmpList)):
+                retlist.append(CUrlItem(tmpList[idx]['name'], tmpList[idx]['url'], 0))
+            
+        return RetHost(RetHost.OK, value = retlist)
+            
+    def getSearchResults(self, searchpattern, searchType = None):
+        self.isSearch = True
+        retList = []
+        self.searchPattern = searchpattern.replace(' ',  '%20')
+        
+        return self.getListForItem( len(self.host.getCurrList()) -1 )
+            
+    # return full path to player logo
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [ GetLogoDir('wptvlogo.png') ])
+
+
+    def convertList(self, cList):
+        hostList = []
+        possibleTypesOfSearch = []
+        
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            
+            url = ''
+            desc = ''
+            sepReq = 0
+            if cItem['type'] in ['main_item', 'sub_item',  'sub_item', 'sub_jitem', 'page', 'app_cat']:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] in ['video', 'app_video']:
+                type = CDisplayListItem.TYPE_VIDEO
+                url = cItem['url']
+                hostLinks.append(CUrlItem('', url, 0))
+            elif cItem['type']  == 'app_search':
+                type = CDisplayListItem.TYPE_SEARCH
+                
+            name = ''
+            if 'name' in cItem:
+                name = cItem['name']
+            ico = ''
+            if 'ico' in cItem:
+                ico = cItem['ico']
+            desc = ' '
+            if 'desc' in cItem:
+                desc = cItem['desc']
+
+            hostItem = CDisplayListItem(name = name,
+                                        description = desc,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = ico,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+        # end for
+            
+        return hostList
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Russian/hostexua.py ./IPTVPlayer/hosts/Russian/hostexua.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Russian/hostexua.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Russian/hostexua.py	2015-11-23 07:45:05.543772000 +0100
@@ -0,0 +1,472 @@
+﻿# -*- coding: utf-8 -*-
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, SetIPTVPlayerLastHostError
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, ArticleContent
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSearchHistoryHelper, remove_html_markup, GetLogoDir, GetCookieDir, byteify
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.tools.iptvtypes import strwithmeta
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import re
+import urllib
+import base64
+try:    import json
+except: import simplejson as json
+from datetime import datetime
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.asynccall import MainSessionWrapper
+from Screens.MessageBox import MessageBox
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.exua_proxy_enable = ConfigYesNo(default = False)
+config.plugins.iptvplayer.exua_language = ConfigSelection(default = "uk", choices = [("ru", "русский"),
+                                                                                     ("uk", "українська"),
+                                                                                     ("en", "english"),
+                                                                                     ("es", "espanol"),
+                                                                                     ("de", "deutsch"),
+                                                                                     ("fr", "français"),
+                                                                                     ("pl", "polski"),
+                                                                                     ("ja", "日本語"),
+                                                                                     ("kk", "қазақ") ])
+
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("Language:"), config.plugins.iptvplayer.exua_language))
+    optionList.append(getConfigListEntry(_("Use ru proxy server:"), config.plugins.iptvplayer.exua_proxy_enable))
+    return optionList
+###################################################
+
+
+def gettytul():
+    return 'http://www.ex.ua/'
+
+class ExUA(CBaseHostClass):
+    MAIN_URL = 'http://www.ex.ua/'
+    LANG_URL = MAIN_URL + 'language?lang='
+    SRCH_URL = MAIN_URL +  'search?original_id={0}&s=' 
+    DEFAULT_ICON_URL = 'http://cdn.keddr.com/wp-content/uploads/2011/10/ex.jpg'
+    
+    MAIN_CAT_TAB = [
+                    #{'category':'search_history', 'title': _('Search history')} 
+                   ]
+ 
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'ExUA', 'cookie':'ExUA.cookie', 'cookie_type':'MozillaCookieJar', 'proxyURL': config.plugins.iptvplayer.russian_proxyurl.value, 'useProxy': config.plugins.iptvplayer.exua_proxy_enable.value})
+        self.defaultParams = {'use_cookie': True, 'load_cookie': True, 'save_cookie': True, 'cookiefile': self.COOKIE_FILE, 'header':{'User-Agent': 'Mozilla/5.0'}}
+        self.videoCatsCache = []
+        
+    def getVideoCats(self):
+        return self.videoCatsCache
+        
+    def _getFullUrl(self, url, series=False):
+        if not series:
+            mainUrl = self.MAIN_URL
+        else:
+            mainUrl = self.S_MAIN_URL
+        if url.startswith('/'):
+            url = url[1:]
+        if 0 < len(url) and not url.startswith('http'):
+            url = mainUrl + url
+        if not mainUrl.startswith('https://'):
+            url = url.replace('https://', 'http://')
+        return url
+        
+    def listsTab(self, tab, cItem, type='dir'):
+        printDBG("ExUA.listsTab")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            if '' == params.get('icon', ''):
+                params['icon'] = self.DEFAULT_ICON_URL
+            if type == 'dir':
+                self.addDir(params)
+            else: self.addVideo(params)
+        
+    def getMainTab(self, cItem):
+        printDBG("ExUA.getMainTab")
+        url = self.LANG_URL + config.plugins.iptvplayer.exua_language.value
+        sts, data = self.cm.getPage(url, self.defaultParams)
+        if not sts: return False
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<td class=menu_text>', '</td>', False)[1]
+        data = re.compile('''<a[^>]*?href=['"]([^'^"]+?)['"][^>]*?>([^<]+?)</a>''').findall(data)
+        haveAccess = False
+        videoCatsUrl = ''
+        for item in data:
+            if 'video' in item[0] or 'audio' in item[0]:
+                params = dict(cItem)
+                url = self._getFullUrl(item[0])
+                params.update({'name':'category', 'category':'list_items', 'title':item[1], 'url':url, 'icon':self.DEFAULT_ICON_URL})
+                self.addDir(params)
+                haveAccess = True
+        if not haveAccess:
+            msg = _("You probably have not access to this page due to geolocation restriction.")
+            msg += '\n' + _("You can use Russian proxy server as a workaround.")
+            self.sessionEx.open(MessageBox, msg, type = MessageBox.TYPE_INFO, timeout = 10 )
+        return haveAccess
+            
+    def listItems(self, cItem, m1='class=include_0>'):
+        printDBG("ExUA.listMovies")
+        url = cItem['url']
+        page = cItem.get('page', 0)
+        if page > 0:
+            if '?' not in url:
+                url += '?'
+            elif not url.endswith('&'):
+                url += '&' 
+            url += 'p=%d' % page
+        
+        sts, data = self.cm.getPage(url, self.defaultParams)
+        if not sts: return
+        
+        original_id = self.cm.ph.getSearchGroups(data, '''<input[^>]+?name=original_id[^>]+?value=['"]([0-9]+?)['"]>''', 1, True)[0]
+        if original_id != '':
+            if 0 == page:
+                params = {'category':'search', 'title': _('Search'), 'search_type':cItem['title'], 'original_id':original_id, 'search_item':True}
+                self.addDir(params)
+        
+        nextPage = False
+        if 'id="browse_next"' in data:
+            nextPage = True
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, m1, '</table>', False)[1]
+        data = data.split('</td>')
+        if len(data):
+            del data[-1]
+        
+        hasItems = False
+        for item in data:
+            url    = self.cm.ph.getSearchGroups(item, '''href=["']([^"^']+?)["']''')[0]
+            icon   = self.cm.ph.getSearchGroups(item, '''src=["']([^"^']+?)["']''')[0]
+            title  = self.cm.ph.getSearchGroups(item, '''alt=["']([^"^']+?)["']''')[0]
+            if '' == title:
+                title = self.cm.ph.getDataBeetwenMarkers(item, '<b>', '</b>', False)[1]
+            title  = self.cleanHtmlStr(title) 
+            title  = title.split('/')
+            if len(title) > 1:
+                try:
+                    tmp = title[0].decode('utf-8').encode('ascii')
+                except:
+                    del data[0]
+            title  = '/'.join(title)
+            if '/' in url:
+                params = dict(cItem)
+                params.update( {'title': title, 'url':self._getFullUrl(url), 'desc': self.cleanHtmlStr( item )} )
+                icon = self._getFullUrl(icon)
+                if icon.startswith('http'):
+                    params['icon'] = icon
+                self.addDir(params)
+                hasItems = True
+        
+        if hasItems:
+            if nextPage:
+                params = dict(cItem)
+                if 'rek' in params:
+                    params.pop('rek', None)
+                params.update( {'title':_('Next page'), 'page':page+1} )
+                self.addDir(params)
+        else:
+            self.listPlayItems(cItem)
+            
+    def listPlayItems(self, cItem):
+        printDBG("ExUA.listPlayItems")
+        urlTab = self.getLinksForVideo(cItem)
+            
+        for item in urlTab:
+            params = dict(cItem)
+            params.update( item )
+            params['title'] = item['name']
+            params['fav_url'] = cItem['url']
+            type = params.get('type', 'unknown')
+            if 'picture' == type:
+                self.addPicture(params)
+            elif 'audio' == type:
+                self.addAudio(params)
+            else:
+                self.addVideo(params)
+
+    
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        searchPattern = urllib.quote_plus(searchPattern)
+        cItem = dict(cItem)
+        if 0 == cItem.get('rek', 0):
+            try:
+                id  = int(cItem['original_id'])
+            except:
+                printExc()
+                return
+            cItem['url'] = self.SRCH_URL.format( id ) + urllib.quote_plus(searchPattern)
+        cItem['rek'] = 1
+        self.listItems(cItem, 'class=panel>')
+        
+    def getLinksForVideo(self, cItem, withPicture=True):
+        printDBG("ExUA.getLinksForVideo [%s]" % cItem)
+        urlTab = []
+        url = cItem['url']
+        
+        sts, data = self.cm.getPage(url)
+        if not sts: return urlTab
+
+        meta = {}
+        if config.plugins.iptvplayer.exua_proxy_enable.value:
+            meta['http_proxy'] = config.plugins.iptvplayer.russian_proxyurl.value
+            
+        # download urls
+        downloadUrls = []
+        subTracks = []
+        picturesTab = []
+        downData = self.cm.ph.getAllItemsBeetwenMarkers(data, '<td width=17>', '</tr>', False)
+        for item in downData:
+            printDBG(">>>>>>>>>>>>>>>>>>>> [%s]" % item)
+            url    = self.cm.ph.getSearchGroups(item, '''href=["']([^"^']+?)["']''')[0]
+            title  = self.cm.ph.getSearchGroups(item, '''title=["']([^"^']+?)["']''')[0]
+            if '/get/' not in url:
+                continue
+            title = self.cleanHtmlStr( title )
+            # video
+            if 'class="fox-play-btn"' in item: 
+                downloadUrls.append({'name':title, 'url':url, 'need_resolve':0})
+            elif title.lower().endswith('.srt'):
+                subTracks.append({'title':title, 'url':self.up.decorateUrl(self._getFullUrl(url), meta), 'lang':'', 'format':'srt'})
+            elif 'picture_0' in item:
+                picturesTab.append({'name':title, 'url':self._getFullUrl(url)})
+        
+        if len (subTracks):
+            meta['external_sub_tracks'] = subTracks
+        
+        # watch urls
+        watchUrls   = self.cm.ph.getDataBeetwenMarkers(data, "player_list = '", "';", False)[1]
+        watchTitles = self.cm.ph.getDataBeetwenMarkers(data, 'new Array(', ');', False)[1]
+        tmpTypes = {}
+        try:
+            watchUrls   = byteify(json.loads('[%s]' % watchUrls))
+            watchTitles = re.compile('''title[^'^"]*?['"]([^'^"]+?)['"]''').findall(watchTitles)
+            printDBG(watchTitles)
+            for idx in range(len(watchUrls)):
+                type  = watchUrls[idx]['type']
+                if type not in ['audio', 'video']:
+                    type = 'unknown'
+                tmpTypes[title] = type
+                url   = watchUrls[idx]['url']
+                title = watchTitles[idx][:-3] + url[-3:]
+                urlTab.append({'name':_('%s [watch]') % title, 'url':self.up.decorateUrl(url, meta), 'need_resolve':0, 'type':type})
+        except:
+            printExc()
+            
+        for item in downloadUrls:
+            if item['name'].endswith('.mp3'):
+                type = 'audio'
+            else:
+                type = 'unknown'
+            item['type'] = tmpTypes.get(item['name'], type)
+            item['name'] = _('%s [download]') % item['name']
+            item['url'] = self.up.decorateUrl(self._getFullUrl(item['url']), meta)
+            urlTab.append(item)
+            
+        for item in picturesTab:
+            item['type'] = 'picture'
+            item['need_resolve'] = 0
+            urlTab.append(item)
+        
+        return urlTab
+        
+    def getFavouriteData(self, cItem):
+        return cItem['fav_url']
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.getLinksForVideo({'url':fav_data})
+
+    def getArticleContent(self, cItem):
+        printDBG("ExUA.getArticleContent [%s]" % cItem)
+        retTab = []
+        
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return retTab
+        
+        title = self.cm.ph.getDataBeetwenMarkers(data, '</select>', '</div>', False)[1]
+        desc  = self.cm.ph.getDataBeetwenMarkers(data, '<p class="description"', '</p>', True)[1]
+        icon  = self.cm.ph.getDataBeetwenMarkers(data, '<div class="coverImage">', '</div>', False)[1]
+        icon  = self.cm.ph.getSearchGroups(icon, 'href="([^"]*?\.jpg)"')[0]
+        
+        descData = self.cm.ph.getDataBeetwenMarkers(data, '<div class="overViewBox">', '</div>', False)[1].split('</dl>')
+        printDBG(descData)
+        descTabMap = {"Directors":    "director",
+                      "Cast":         "actors",
+                      "Genres":       "genre",
+                      "Country":      "country",
+                      "Release Date": "released",
+                      "Duration":     "duration"}
+        
+        otherInfo = {}
+        for item in descData:
+            item = item.split('</dt>')
+            if len(item) < 2: continue
+            key = self.cleanHtmlStr( item[0] ).replace(':', '').strip()
+            val = self.cleanHtmlStr( item[1] )
+            if key in descTabMap:
+                otherInfo[descTabMap[key]] = val
+        
+        imdbRating = self.cm.ph.getDataBeetwenMarkers(data, '<div class="imdbRating', '</p>', True)[1]
+        solarRating = self.cm.ph.getDataBeetwenMarkers(data, '<div class="solarRating', '</p>', True)[1]
+        
+        otherInfo['rating'] = self.cleanHtmlStr( imdbRating )
+        otherInfo['rated'] = self.cleanHtmlStr( solarRating )
+        
+        return [{'title':self.cleanHtmlStr( title ), 'text': self.cleanHtmlStr( desc ), 'images':[{'title':'', 'url':self._getFullUrl(icon)}], 'other_info':otherInfo}]
+        
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        name     = self.currItem.get("name", '')
+        category = self.currItem.get("category", '')
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if name == None:
+            self.getMainTab({})
+            self.listsTab(self.MAIN_CAT_TAB, {'name':'category'})
+    #MOVIES
+        elif category == 'list_items':
+            self.listItems(self.currItem)
+    #SEARCH
+        elif category in ["search", "search_next_page"]:
+            cItem = dict(self.currItem)
+            cItem.update({'search_item':False, 'name':'category'}) 
+            self.listSearchResult(cItem, searchPattern, searchType)
+    #HISTORIA SEARCH
+        elif category == "search_history":
+            self.listsHistory({'name':'history', 'category': 'search'}, 'desc', _("Type: "))
+        else:
+            printExc()
+        
+        CBaseHostClass.endHandleService(self, index, refresh)
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, ExUA(), False, [CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO])
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('exualogo.png')])
+    
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+        
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            retlist.append(CUrlItem(item["name"], item["url"], item['need_resolve']))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        retlist = []
+        urlList = self.host.getVideoLinks(url)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+        
+    #def getArticleContent(self, Index = 0):
+    #    retCode = RetHost.ERROR
+    #    retlist = []
+    #    if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+    #    cItem = self.host.currList[Index]
+    #    
+    #    if cItem['type'] != 'video' and cItem['category'] != 'list_seasons':
+    #        return RetHost(retCode, value=retlist)
+    #    hList = self.host.getArticleContent(cItem)
+    #    for item in hList:
+    #        title      = item.get('title', '')
+    #        text       = item.get('text', '')
+    #        images     = item.get("images", [])
+    #        othersInfo = item.get('other_info', '')
+    #        retlist.append( ArticleContent(title = title, text = text, images =  images, richDescParams = othersInfo) )
+    #    return RetHost(RetHost.OK, value = retlist)
+    
+    def converItem(self, cItem):
+        searchTypesOptions = [] # ustawione alfabetycznie
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if 'category' == cItem['type']:
+            if cItem.get('search_item', False):
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+        elif 'more' == cItem['type']:
+            type = CDisplayListItem.TYPE_MORE
+        elif 'audio' == cItem['type']:
+            type = CDisplayListItem.TYPE_AUDIO
+        elif 'picture' == cItem['type']:
+            type = CDisplayListItem.TYPE_PICTURE
+            
+        if type in [CDisplayListItem.TYPE_AUDIO, CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_PICTURE]:
+            url = cItem.get('url', '')
+            need_resolve = cItem.get('need_resolve', 1)
+            if '' != url:
+                hostLinks.append(CUrlItem("Link", url, need_resolve))
+            
+        title       =  cItem.get('title', '')
+        description =  cItem.get('desc', '')
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 0,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+    # end converItem
+
+    def getSearchItemInx(self):
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'search':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostekstraklasatv.py ./IPTVPlayer/hosts/Sport/hostekstraklasatv.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostekstraklasatv.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Sport/hostekstraklasatv.py	2015-11-17 06:34:21.243826000 +0100
@@ -0,0 +1,321 @@
+﻿# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+import re
+import urllib
+import time
+import random
+try:    import json
+except: import simplejson as json
+from os import urandom as os_urandom
+
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.ekstraklasa_defaultformat = ConfigSelection(default = "450", choices = [("0", "bitrate: najgorszy"), ("200", "bitrate: 200p"), ("450", "bitrate: 450p"),("900", "bitrate: 900"),("1800", "bitrate: 1800"), ("9999", "bitrate: najlepszy")])
+config.plugins.iptvplayer.ekstraklasa_usedf = ConfigYesNo(default = False)
+config.plugins.iptvplayer.ekstraklasa_proxy = ConfigYesNo(default = False)
+
+def GetConfigList():
+    optionList = []
+    optionList.append( getConfigListEntry( "Domyślny format video:", config.plugins.iptvplayer.ekstraklasa_defaultformat ) )
+    optionList.append( getConfigListEntry( "Używaj domyślnego format video:", config.plugins.iptvplayer.ekstraklasa_usedf ) )
+    optionList.append( getConfigListEntry( "Ekstraklasa korzystaj z proxy?", config.plugins.iptvplayer.ekstraklasa_proxy) )
+    return optionList
+###################################################
+
+def gettytul():
+    return 'Ekstraklasa'
+
+class Ekstraklasa(CBaseHostClass):
+
+    EORG_MAIN_URL = 'http://ekstraklasa.org/'
+    EORG_MAIN_MENU = [ {'name': 'Nowości', 'navi': 'nowosci'},
+                       {'name': 'Bramki i skróty', 'navi': 'galeria-i-wideo'},
+                     ]
+    
+    ETV_MAIN_URL  = 'http://ekstraklasa.tv/'
+    ETV_MAIN_MENU = [ {'name': 'Bramki', 'navi': 'bramki'},
+                      {'name': 'Skróty', 'navi': 'skroty'},
+                      {'name': 'Bramka kolejki', 'navi': 'bramka-kolejki'},
+                      {'name': 'Magazyn', 'navi': 'magazyn-t-mobile-ekstraklasy'},
+                    ]
+    ETV_CATEGORY  = 'etv_category'
+    ETV_FORMAT    = 'mp4'
+    def __init__(self):
+        printDBG("Ekstraklasa.__init__")
+        CBaseHostClass.__init__(self, {'proxyURL': config.plugins.iptvplayer.proxyurl.value, 'useProxy': config.plugins.iptvplayer.ekstraklasa_proxy.value})
+    
+    def listsCategories_ETV(self):
+        printDBG("Ekstraklasa.listsCategories_ETV")
+        
+        for item in Ekstraklasa.ETV_MAIN_MENU:
+            params = { 'name'     : 'category',
+                       'category' : Ekstraklasa.ETV_CATEGORY,
+                       'url'      : Ekstraklasa.ETV_MAIN_URL + item['navi'],
+                       'title'    : item['name'],
+                       'desc'     : 'ekstraklasa.tv',
+                       'icon'     : '',
+                       'depth'    : 0,
+                       'host'     : 'ekstraklasa.tv'
+                     }  
+            self.addDir(params)
+
+    def listsCategory_ETV(self, cItem):
+        printDBG("Ekstraklasa.listsCategory_ETV")
+        ITEM_MARKER = '<div class="listItem'
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        printDBG('----------------------------------------')
+        
+        # check if we should check for sub categories
+        if 0 == cItem['depth']:
+            subMenuData  = self.cm.ph.getDataBeetwenMarkers(data, '<ul class="subMenu">', '</ul>', False)[1]
+            subMenuData  = re.compile('<a[ ]+?href="(http[^">]+?)"[ ]*?>([^<]+?)</a>').findall(subMenuData)
+            if 0 < len(subMenuData):
+                params = dict(cItem)
+                params.update({'title':'Najnowsze', 'depth':1})
+                self.addDir(params)
+                for item in subMenuData:
+                    params = dict(cItem)
+                    params.update({'url':item[0], 'title': self.cleanHtmlStr(item[1]), 'depth':1, })
+                    self.addDir(params)
+                return
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, ITEM_MARKER, '<script')[1]
+        moreData = self.cm.ph.getSearchGroups(data, "id=\"moredata\" value='([^']+?)'")[0]
+        
+        data = data.split(ITEM_MARKER)
+        del data[0]
+        for item in data:
+            icon  = self.cm.ph.getSearchGroups(item, '<img[^>]+?data-original="([^"]+?)"')[0]
+            title = self.cm.ph.getDataBeetwenMarkers(item, '<h3 class="itemTitle">', '</h3>', False)[1].strip() + ', ' +self.cm.ph.getDataBeetwenMarkers(item, '<div class="datePublished">', '</div>', False)[1].strip()
+            # self.cm.ph.getDataBeetwenMarkers(item, '<div class="itemLead hyphenate">', '</div>', False)[1]
+            desc  = self.cleanHtmlStr(ITEM_MARKER + item)
+            url   = self.cm.ph.getSearchGroups(item, '<a href="([^"]+?)" title="([^"]+?)"', 2)[0]
+            params = {'title':title, 'url':url, 'icon':icon, 'desc': desc, 'host':'ekstraklasa.tv'}
+            self.addVideo(params)
+            #if "mediaType mediaVideo" in item:
+            #    self.addVideo(params)
+            #else:
+            #    self.addArticle(params)
+        # checkNewItemsAvailability
+        a = len(data)
+        if '' != moreData and 0 < a:
+            try:
+                # check if there are more data
+                moreData  = json.loads(moreData)
+                prevLimit = moreData['limit']
+                moreData['offset'] += a
+                moreData['limit']   = 1 
+                moreData = {'params':moreData}
+                url = urllib.quote(json.dumps(moreData, sort_keys=False, separators=(',', ':')))
+                url = Ekstraklasa.ETV_MAIN_URL + '_cdf/api?json=' + url + '&____presetName=liststream'
+                sts, data = self.cm.getPage(url)
+                if ITEM_MARKER in data:
+                    moreData['params']['limit']   = prevLimit 
+                    url = urllib.quote(json.dumps(moreData, sort_keys=False, separators=(',', ':')))
+                    url = Ekstraklasa.ETV_MAIN_URL + '_cdf/api?json=' + url + '&____presetName=liststream'
+                    params = dict(cItem)
+                    params.update({'title':'Następna strona', 'url':url })
+                    self.addDir(params)
+            except:
+                printExc()
+        # list items
+        
+    def getVideoTab_ETV(self, ckmId):
+        printDBG("Ekstraklasa.getVideoTab_ETV ckmId[%r]" % ckmId )
+        tm = str(int(time.time() * 1000))
+        jQ = str(random.randrange(562674473039806,962674473039806))
+        authKey = 'FDF9406DE81BE0B573142F380CFA6043'
+        contentUrl = 'http://qi.ckm.onetapi.pl/?callback=jQuery183040'+ jQ + '_' + tm + '&body%5Bid%5D=' + authKey + '&body%5Bjsonrpc%5D=2.0&body%5Bmethod%5D=get_asset_detail&body%5Bparams%5D%5BID_Publikacji%5D=' + ckmId + '&body%5Bparams%5D%5BService%5D=ekstraklasa.onet.pl&content-type=application%2Fjsonp&x-onet-app=player.front.onetapi.pl&_=' + tm
+        sts, data = self.cm.getPage(contentUrl)
+        valTab = []
+        if sts:
+            try:
+                #extract json
+                result = json.loads(data[data.find("(")+1:-2])
+                strTab = []
+                valTab = []
+                for items in result['result']['0']['formats']['wideo']:
+                    for i in range(len(result['result']['0']['formats']['wideo'][items])):
+                        strTab.append(items)
+                        strTab.append(result['result']['0']['formats']['wideo'][items][i]['url'].encode('UTF-8'))
+                        if result['result']['0']['formats']['wideo'][items][i]['video_bitrate']:
+                            strTab.append(int(float(result['result']['0']['formats']['wideo'][items][i]['video_bitrate'])))
+                        else:
+                            strTab.append(0)
+                        valTab.append(strTab)
+                        strTab = []
+            except:
+                printExc()
+        return valTab
+
+    def getLinks_ETV(self, url):
+        printDBG("Ekstraklasa.getLinks_ETV url[%r]" % url )
+        videoUrls = []
+        sts, data = self.cm.getPage(url)
+        if not sts: return videoUrls
+        ckmId = self.cm.ph.getSearchGroups(data, 'data-params-mvp="([^"]+?)"')[0]
+        if '' == ckmId: ckmId = self.cm.ph.getSearchGroups(data, 'id="mvp:([^"]+?)"')[0]
+        if '' != ckmId: videoUrls = self.getVideoTab_ETV(ckmId)
+        return videoUrls
+        
+    def getDescription_ETV(self, url):
+        printDBG("Ekstraklasa.getDescription url[%r]" % url )
+        content = {}
+        sts, data = self.cm.getPage(url)
+        if sts:
+            desc  = self.cleanHtmlStr(self.cm.ph.getDataBeetwenMarkers(data, '<div id="lead">', '</div>', False)[1])
+            title = self.cm.ph.getDataBeetwenMarkers(data, '<title>', '</title>', False)[1].strip()
+            data  = self.cm.ph.getDataBeetwenMarkers(data, '<div id="leadMedia">', '</div>', False)[1].strip()
+            icon  = self.cm.ph.getSearchGroups(data, 'src="([^"]+?)"')[0]
+            content = { 'title': title,
+                        'desc' : desc,
+                        'icon' : icon,
+                      }
+        return content
+    
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('Ekstraklasa..handleService start')
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "Ekstraklasa.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+        if None == name:
+            self.listsCategories_ETV()
+        elif Ekstraklasa.ETV_CATEGORY == category:
+            self.listsCategory_ETV(self.currItem)
+
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Ekstraklasa(), False)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('ekstraklasatvlogo.png')])
+        
+    def getArticleContent(self, Index = 0):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getArticleContent - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        if 'ekstraklasa.tv' in self.host.currList[Index].get('host', ''): 
+            content = self.host.getDescription_ETV(self.host.currList[Index]['url'])
+        elif 'ekstraklasa.org' in self.host.currList[Index].get('host', ''):
+            content = {}
+        
+        title  = content.get('title', '')
+        text   = content.get('desc', '')
+        images = [ {'title':'', 'author': '', 'url': content.get('icon', '')} ]
+        
+        return RetHost(RetHost.OK, value = [ArticleContent(title = title, text = text, images =  images)])
+
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        retlist = []
+        if 'ekstraklasa.tv' in self.host.currList[Index].get('host', ''):        
+            tab = self.host.getLinks_ETV(self.host.currList[Index].get('url', ''))
+            
+            tmp = tab
+            tab = []
+            for item in tmp:
+                if item[0] == Ekstraklasa.ETV_FORMAT:
+                    tab.append(item)
+            
+            def __getLinkQuality( itemLink ):
+                return int(itemLink[2])
+            
+            maxRes = int(config.plugins.iptvplayer.ekstraklasa_defaultformat.value) * 1.1
+            tab = CSelOneLink(tab, __getLinkQuality, maxRes).getSortedLinks()
+            printDBG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>. tab[%s]" % tab)
+            if config.plugins.iptvplayer.ekstraklasa_usedf.value and 0 < len(tab):
+                tab = [tab[0]]
+            
+            for item in tab:
+                nameLink = "type: %s \t bitrate: %s" % (item[0], item[2])
+                url = item[1]
+                retlist.append(CUrlItem(nameLink.encode('utf-8'), url.encode('utf-8'), 0))
+        elif 'ekstraklasa.org' in self.host.currList[Index].get('host', ''):
+            pass
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        url = self.host.resolveLink(url)
+        urlTab = []
+        if isinstance(url, basestring) and url.startswith('http'):
+            urlTab.append(url)
+        return RetHost(RetHost.OK, value = urlTab)
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = []
+        
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if cItem['type'] == 'category':
+                if cItem['title'] == 'Wyszukaj':
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+            elif cItem['type'] == 'article':
+                type = CDisplayListItem.TYPE_ARTICLE
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  cItem.get('title', '')
+            description =  clean_html(cItem.get('desc', ''))
+            icon        =  cItem.get('icon', '')
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostfighttube.py ./IPTVPlayer/hosts/Sport/hostfighttube.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostfighttube.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Sport/hostfighttube.py	2015-11-05 22:26:57.909660252 +0100
@@ -0,0 +1,350 @@
+# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, CSearchHistoryHelper, GetLogoDir, CSelOneLink
+from Plugins.Extensions.IPTVPlayer.libs.youtubeparser import YouTubeParser
+###################################################
+# FOREIGN import
+###################################################
+import re
+from Components.config import config
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+
+def GetConfigList():
+    return []
+###################################################
+
+def gettytul():
+    return 'FightTube'
+
+class FightTube:
+    MAINURL = 'http://www.fighttube.pl/'
+    SEARCHURL = MAINURL + 'search/?keywords='
+
+    def __init__(self):
+        self.cm = common()
+        self.history = CSearchHistoryHelper('fighttube')
+        self.ytp = YouTubeParser()
+        self.ytformats = config.plugins.iptvplayer.ytformat.value
+        
+        # temporary data
+        self.currList = []
+        self.currItem = {}
+
+    def getCurrList(self):
+        return self.currList
+
+    def setCurrList(self, list):
+        self.currList = list
+        
+    def getCurrItem(self):
+        return self.currItem
+
+    def setCurrItem(self, item):
+        self.currItem = item
+
+    @staticmethod
+    def printDBG( strDBG ):
+        printDBG('[IPTV FightTube] ' + strDBG)
+        
+    def getVideoUrl(self, url):
+        FightTube.printDBG("getVideoUrl url[%s]" % url)
+
+        query_data = {'url': url, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            FightTube.printDBG('getVideoUrl exception')
+            return []
+            
+        match = re.search('<embed src="([^"]+?)" type="application/x-shockwave-flash"', data)
+        if match:
+            return self.getYTVideoUrl(match.group(1))
+        else:
+            FightTube.printDBG('getVideoUrl YT embed not found!')
+        
+        return []
+
+    def getYTVideoUrl(self, url):
+        FightTube.printDBG("getYTVideoUrl url[%s]" % url)
+        tmpTab = self.ytp.getDirectLinks(url, self.ytformats)
+     
+        movieUrls = []
+        for item in tmpTab:
+            movieUrls.append({'name': item['format'] + '\t' + item['ext'] , 'url':item['url']})
+            
+        return movieUrls
+
+    def listsMainMenu(self):
+        FightTube.printDBG('listsMainMenu start')
+        query_data = {'url': self.MAINURL, 'return_data': True}
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            FightTube.printDBG('listsMainMenu exception')
+            return
+    
+        sts, data = CParsingHelper.getDataBeetwenMarkers(data, 'Kategorie video', '</ul>', False)
+        if not sts:
+            printDBG('listsMainMenu: menu marker cannot be found!')
+            return
+        match = re.compile("<a href='([^']+?)' class='level0'[^>]+?>([^<]+?)</a>").findall(data)
+        if len(match) > 0:
+            for i in range(len(match)):
+                params = {'type': 'category', 'title': match[i][1], 'page': match[i][0], 'icon': ''}
+                self.currList.append(params)
+                
+        params = {'type': 'category', 'title': 'Wyszukaj', 'page': self.SEARCHURL, 'icon': ''}
+        self.currList.append(params)
+        return
+        
+    def getMovieTab(self, url):
+        FightTube.printDBG('getMovieTab start')
+        query_data = { 'url': url, 'return_data': True }
+        try:
+            data = self.cm.getURLRequestData(query_data)
+        except:
+            FightTube.printDBG('getMovieTab exception')
+            return            
+        # get next page url
+        nexPageUrl = ''
+        sts, tmp = CParsingHelper.getDataBeetwenMarkers(data, "<nav class='pagination'>", "</nav>", False)
+        if sts:
+            match = re.search("<li><a href='([^']+?)'>&gt;</a></li>", tmp)
+            if match: nexPageUrl = match.group(1)
+                
+        # separete vidTab
+        sts, data = CParsingHelper.getDataBeetwenMarkers(data, "<ul class='videos-listing'>", "</ul>", False)
+        if not sts:
+            printDBG('getMovieTab: main markers cannot be found!')
+            return
+            
+        # separate videos data
+        data = data.split('</li>')
+        for vidItem in data:
+            url = ''
+            title = ''
+            icon = ''
+            ocena = ''
+            wyswietlen = ''
+            match = re.search("<a href='([^']+?)'", vidItem)
+            if match: 
+                url = match.group(1)
+            match = re.search("<img src='([^']+?)' alt='([^']+?)'", vidItem)
+            if match: 
+                icon = match.group(1)
+                title = match.group(2)
+                
+            if '' != url and '' != title:
+                params = {'type': 'video', 'title': title, 'page': url, 'icon': icon}
+                self.currList.append(params)
+            
+
+        if nexPageUrl.startswith("http://"):
+            params = {'type': 'category', 'name': 'nextpage', 'title': 'Następna strona', 'page': nexPageUrl, 'icon': ''}
+            self.currList.append(params)
+        return
+ 
+    def searchTab(self, text):
+        FightTube.printDBG('searchTab start')
+        self.getMovieTab(self.SEARCHURL + text)
+
+    def handleService(self, index, refresh = 0, searchPattern = ''):
+        FightTube.printDBG('handleService start')
+        if 0 == refresh:
+            if len(self.currList) <= index:
+                FightTube.printDBG( "handleService wrong index: %s, len(self.currList): %d" % (index, len(self.currList)) )
+                return
+            if -1 == index:
+                # use default value
+                self.currItem = { "name": None }
+                FightTube.printDBG( "handleService for first self.category" )
+            else:
+                self.currItem = self.currList[index]
+
+        name     = self.currItem.get("name", '')
+        title    = self.currItem.get("title", '')
+        category = self.currItem.get("category", '')
+        page     = self.currItem.get("page", '')
+        icon     = self.currItem.get("icon", '')
+        type     = self.currItem.get("type", '')
+
+ 
+        FightTube.printDBG( "handleService: |||||||||||||||||||||||||||||||||||| [%s] " % name )
+        self.currList = []
+
+
+    #MAIN MENU == KATEGORIE
+        if name == None:
+            self.listsMainMenu()
+        elif type != 'category':
+            return
+    #WYSZUKAJ
+        elif title == 'Wyszukaj':
+            if searchPattern != None:
+                self.searchTab(searchPattern)
+        else:
+            self.getMovieTab(page)
+            
+class IPTVHost(IHost):
+
+    def __init__(self):
+        self.host = None
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        self.listOfprevItems = [] 
+        
+        self.searchPattern = ''
+    
+    # return firs available list of item category or video or link
+    def getInitList(self):
+        self.isSearch = False
+        self.host = FightTube()
+        self.currIndex = -1
+        self.listOfprevList = [] 
+        self.listOfprevItems = []
+        
+        self.host.handleService(self.currIndex)
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+    
+    # return List of item from current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible 
+    # server instead of cache 
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        self.listOfprevList.append(self.host.getCurrList())
+        self.listOfprevItems.append(self.host.getCurrItem())
+        
+        self.currIndex = Index
+        self.host.handleService(Index, refresh, self.searchPattern)
+        convList = self.convertList(self.host.getCurrList())
+        
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return prev requested List of item 
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getPrevList(self, refresh = 0):
+        if(len(self.listOfprevList) > 0):
+            hostList = self.listOfprevList.pop()
+            hostCurrItem = self.listOfprevItems.pop()
+            self.host.setCurrList(hostList)
+            self.host.setCurrItem(hostCurrItem)
+            
+            convList = self.convertList(hostList)
+            return RetHost(RetHost.OK, value = convList)
+        else:
+            return RetHost(RetHost.ERROR, value = [])
+        
+    # return current List
+    # for given Index
+    # 1 == refresh - force to read data from 
+    #                server if possible
+    def getCurrentList(self, refresh = 0):      
+        if refresh == 1:
+            self.host.handleService(self.currIndex, refresh, self.searchPattern)
+        convList = self.convertList(self.host.getCurrList())
+        return RetHost(RetHost.OK, value = convList)
+        
+    # return list of links for VIDEO with given Index
+    # for given Index
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        listLen = len(self.host.currList)
+        if listLen < Index and listLen > 0:
+            printDBG( "ERROR getLinksForVideo - current list is to short len: %d, Index: %d" % (listLen, Index) )
+            return RetHost(RetHost.ERROR, value = [])
+        
+        if self.host.currList[Index]["type"] != 'video':
+            printDBG( "ERROR getLinksForVideo - current item has wrong type" )
+            return RetHost(RetHost.ERROR, value = [])
+            
+        
+        
+        urlsTab = self.host.getVideoUrl(self.host.currList[Index]["page"])
+        if config.plugins.iptvplayer.ytUseDF.value:
+            maxRes = int(config.plugins.iptvplayer.ytDefaultformat.value) * 1.1
+            def __getLinkQuality( itemLink ):
+                tab = itemLink['name'].split('x')
+                return int(tab[0])
+            urlsTab = CSelOneLink(urlsTab, __getLinkQuality, maxRes).getOneLink()
+        retlist = []
+        for urlItem in urlsTab:
+            retlist.append(CUrlItem(urlItem['name'], urlItem['url'], 0))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+        
+    # return resolved url
+    # for given url
+    def getResolvedURL(self, url):
+        return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+    # end getResolvedURL
+            
+    # return full path to player logo
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [ GetLogoDir('fighttubelogo.png') ])
+
+    def convertList(self, cList):
+        hostList = []
+        
+        for cItem in cList:
+            hostLinks = []
+                
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+            if cItem['type'] == 'category':
+                if cItem['title'] == 'Wyszukaj':
+                    type = CDisplayListItem.TYPE_SEARCH
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+                
+            title       =  cItem.get('title', '')
+            description =  cItem.get('plot', '')
+            icon        =  cItem.get('icon', '')
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon )
+            hostList.append(hostItem)
+            
+        return hostList
+    # end convertList
+        
+    def getSearchResults(self, searchpattern, searchType = None):
+        self.isSearch = True
+        retList = []
+        self.searchPattern = searchpattern
+        
+        # Find 'Wyszukaj' item
+        list = self.host.getCurrList()
+        try:
+            for i in range( len(list) ):
+                if list[i]['title'] == 'Wyszukaj':
+                    return self.getListForItem( i )
+        except:
+            printDBG('getSearchResults EXCEPTION')
+            
+        return RetHost(RetHost.ERROR, value = [])
+            
+    # end getSearchResults
+    
+
+
+    
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostwatchwrestling.py ./IPTVPlayer/hosts/Sport/hostwatchwrestling.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostwatchwrestling.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Sport/hostwatchwrestling.py	2015-11-11 07:16:45.118414000 +0100
@@ -0,0 +1,379 @@
+# -*- coding: utf-8 -*-
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, SetIPTVPlayerLastHostError
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, RetHost, CUrlItem, ArticleContent
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, printExc, CSearchHistoryHelper, remove_html_markup, GetLogoDir, GetCookieDir, byteify
+from Plugins.Extensions.IPTVPlayer.libs.pCommon import common, CParsingHelper
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.tools.iptvtypes import strwithmeta
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+import re
+import urllib
+import base64
+try:    import json
+except: import simplejson as json
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.asynccall import MainSessionWrapper
+from Screens.MessageBox import MessageBox
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+#config.plugins.iptvplayer.alltubetv_premium  = ConfigYesNo(default = False)
+#config.plugins.iptvplayer.alltubetv_login    = ConfigText(default = "", fixed_size = False)
+#config.plugins.iptvplayer.alltubetv_password = ConfigText(default = "", fixed_size = False)
+
+def GetConfigList():
+    optionList = []
+    #if config.plugins.iptvplayer.alltubetv_premium.value:
+    #    optionList.append(getConfigListEntry("  alltubetv login:", config.plugins.iptvplayer.alltubetv_login))
+    #    optionList.append(getConfigListEntry("  alltubetv hasło:", config.plugins.iptvplayer.alltubetv_password))
+    return optionList
+###################################################
+
+
+def gettytul():
+    return 'http://watchwrestling.to/'
+
+class Watchwrestling(CBaseHostClass):
+    MAIN_URL    = 'http://watchwrestling.to/'
+    SRCH_URL    = MAIN_URL + 'index.php?s='
+    DEFAULT_ICON_URL = 'http://watchwrestling.to/wp-content/uploads/2014/11/ww_fb.png'
+    
+    MAIN_CAT_TAB = [{'category':'categories',  'title': _('Categories'), 'url':MAIN_URL,                                 'icon':DEFAULT_ICON_URL, 'm1':'Categories</h3>'},
+                    {'category':'categories', 'title': _('Monthly'),     'url':MAIN_URL + 'video/watch-wwe-raw-101915/', 'icon':DEFAULT_ICON_URL, 'm1':'Monthly Posts</h3>'},
+                    {'category':'live',       'title': _('LIVE 24/7'),   'url':MAIN_URL + 'watch-wwe-network-live/',     'icon':DEFAULT_ICON_URL, 'm1':'Monthly Posts</h3>'},
+                    {'category':'search',             'title': _('Search'),       'search_item':True},
+                    {'category':'search_history',     'title': _('Search history')} 
+                   ]
+    
+    SORT_TAB = [{'sort':'date',     'title':_('DATE')},
+                {'sort':'views',    'title':_('VIEWS')},
+                {'sort':'likes',    'title':_('LIKES')},
+                {'sort':'comments', 'title':_('COMMENTS')}
+               ]
+ 
+    def __init__(self):
+        CBaseHostClass.__init__(self, {'history':'Watchwrestling', 'cookie':'Watchwrestling.cookie'})
+        self.serversCache = []
+        
+    def _getFullUrl(self, url, series=False):
+        if not series:
+            mainUrl = self.MAIN_URL
+        else:
+            mainUrl = self.S_MAIN_URL
+        if 0 < len(url) and not url.startswith('http'):
+            url = mainUrl + url
+        if not mainUrl.startswith('https://'):
+            url = url.replace('https://', 'http://')
+        return url
+
+    def listsTab(self, tab, cItem, type='dir'):
+        printDBG("Watchwrestling.listsTab")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            if type == 'dir':
+                self.addDir(params)
+            else: self.addVideo(params)
+            
+    def listCategories(self, cItem, category):
+        printDBG("Watchwrestling.listCategories")
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        data = self.cm.ph.getDataBeetwenMarkers(data, cItem['m1'], '</ul>', False)[1]
+        data = data.split('</li>')
+        if len(data): del data[-1]
+        for item in data:
+            url    = self.cm.ph.getSearchGroups(item, '''href=['"]([^"^']+?)["']''')[0]
+            if url == '': continue
+            title  = self.cleanHtmlStr(item)
+            params = dict(cItem)
+            params.update({'title':title, 'url':self._getFullUrl(url), 'category':category})
+            self.addDir(params)
+            
+    def listFilters(self, cItem, category):
+        printDBG("Watchwrestling.listFilters")
+        cItem = dict(cItem)
+        cItem['category'] = category
+        self.listsTab(self.SORT_TAB, cItem)
+            
+    def listMovies(self, cItem, category):
+        printDBG("Watchwrestling.listMovies")
+        url = cItem['url']
+        page = cItem.get('page', 1)
+        if page > 1:
+            url += 'page/%d/' % page
+        if '?' in url:
+            url += '&'
+        else: url += '?'
+        url += 'orderby=%s' % cItem['sort']
+        
+        sts, data = self.cm.getPage(url)
+        if not sts: return 
+        
+        if ('/page/%d/' % (page + 1)) in data:
+            nextPage = True
+        else: nextPage = False
+        
+        data = self.cm.ph.getDataBeetwenMarkers(data, '<div class="nag cf">', '<!-- end #content -->', False)[1]
+        data = data.split('<div id="post-')
+        if len(data): del data[0]
+        
+        for item in data:
+            tmp    = item.split('<p class="stats">')
+            url    = self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"')[0]
+            icon   = self.cm.ph.getSearchGroups(item, 'src="([^"]+?)"')[0]
+            title  = self.cm.ph.getSearchGroups(item, 'title="([^"]+?)"')[0]
+            desc   = tmp[-1]
+            params = dict(cItem)
+            params.update( {'category':category, 'title': self.cleanHtmlStr( title ), 'url':self._getFullUrl(url), 'desc': self.cleanHtmlStr( desc ), 'icon':self._getFullUrl(icon)} )
+            self.addDir(params)
+        
+        if nextPage:
+            params = dict(cItem)
+            params.update( {'title':_('Next page'), 'page':page+1} )
+            self.addDir(params)
+            
+    def listServers(self, cItem, category):
+        printDBG("Watchwrestling.listServers [%s]" % cItem)
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        self.serversCache = []
+        matchObj = re.compile('href="([^"]+?)"[^>]*?>([^>]+?)</a>')
+        sp = '<div style="text-align: center;">'
+        data = self.cm.ph.getDataBeetwenMarkers(data, sp, '<div id="extras">', False)[1]
+        data = data.split(sp)
+        if len(data): del data[0]
+        for item in data:
+            sts, serverName = self.cm.ph.getDataBeetwenMarkers(item, 'geneva;">', '</span>', False)
+            if not sts: continue
+            parts = matchObj.findall(item)
+            partsTab = []
+            for part in parts:
+                partsTab.append({'title':cItem['title'] + '[%s]' % part[1], 'url':part[0], 'Referer':cItem['url']})
+            if len(partsTab):
+                params = dict(cItem)
+                params.update( {'category':category, 'title':serverName, 'part_idx':len(self.serversCache)} )
+                self.addDir(params)
+                self.serversCache.append(partsTab)
+        
+    def listParts(self, cItem):
+        printDBG("Watchwrestling.listServers [%s]" % cItem)
+        partIdx = cItem['part_idx']
+        self.listsTab(self.serversCache[partIdx], cItem, 'video')
+        
+    def listLiveStreams(self, cItem):
+        printDBG("Watchwrestling.listLiveStreams [%s]" % cItem)
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return
+        sp = '<div style="text-align: center;">'
+        data = self.cm.ph.getDataBeetwenMarkers(data, sp, '<div id="livefyre-comments">', False)[1]
+        data = re.compile('href="([^"]+?)"[^>]*?>([^>]+?)</a>').findall(data)
+        for item in data:
+            params = dict(cItem)
+            params.update({'title':item[1], 'url':item[0], 'Referer':cItem['url'], 'live':True})
+            self.addVideo(params)
+        
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        searchPattern = urllib.quote_plus(searchPattern)
+        cItem = dict(cItem)
+        cItem['url']  = self.SRCH_URL + searchPattern
+        cItem['sort'] = searchType
+        self.listMovies(cItem, 'list_server')
+        
+    def _clearData(self, data):
+        data = re.sub("<!--[\s\S]*?-->", "", data)
+        data = re.sub("/\*[\s\S]*?\*/", "", data)
+        return data
+        
+    def getLinksForVideo(self, cItem):
+        printDBG("Watchwrestling.getLinksForVideo [%s]" % cItem)
+        urlTab = []
+        url = cItem['url']
+        Referer =  cItem['Referer']
+        if 1 != self.up.checkHostSupport(url):  
+            tries = 0
+            while tries < 3:
+                sts, data = self.cm.getPage(url, {'header':{'Referer':Referer, 'User-Agent':'Mozilla/5.0'}})
+                if not sts: return urlTab
+                data = data.replace('// -->', '')
+                data = self._clearData(data)
+                #printDBG(data)
+                if 'eval(unescape' in data:
+                    data = urllib.unquote(self.cm.ph.getSearchGroups(data, '''eval\(unescape\(['"]([^"^']+?)['"]''')[0])
+                url = self.cm.ph.getSearchGroups(data, '''<iframe[^>]*?src=['"]([^"^']+?)['"]''', 1, True)[0]
+                if 'protect.cgi' in url:
+                    Referer = cItem['url']
+                else:
+                    break
+                tries += 1
+        url = strwithmeta(url)
+        url.meta['Referer'] = Referer
+        url.meta['live'] = cItem.get('live', False)
+        
+        urlTab.append({'name':cItem['title'], 'url':url, 'need_resolve':1})
+        return urlTab
+        
+    def getVideoLinks(self, baseUrl):
+        printDBG("Watchwrestling.getVideoLinks [%s]" % baseUrl)
+        urlTab = []
+        
+        url = strwithmeta(baseUrl)
+        if url.meta.get('live'):
+            urlTab = self.up.getAutoDetectedStreamLink(url)
+        else:
+            urlTab = self.up.getVideoLinkExt(url)
+        return urlTab
+
+    def handleService(self, index, refresh = 0, searchPattern = '', searchType = ''):
+        printDBG('handleService start')
+        
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+
+        name     = self.currItem.get("name", '')
+        category = self.currItem.get("category", '')
+        printDBG( "handleService: |||||||||||||||||||||||||||||||||||| name[%s], category[%s] " % (name, category) )
+        self.currList = []
+        
+    #MAIN MENU
+        if name == None:
+            self.listsTab(self.MAIN_CAT_TAB, {'name':'category'})
+        elif category == 'categories':
+            self.listCategories(self.currItem, 'list_filters')
+        elif category == 'list_filters':
+            self.listFilters(self.currItem, 'list_movies')
+    #MOVIES
+        elif category == 'list_movies':
+            self.listMovies(self.currItem, 'list_server')
+        elif category == 'list_server':
+            self.listServers(self.currItem, 'list_parts')
+        elif category == 'list_parts':
+            self.listParts(self.currItem)
+    #LIVE
+        elif category == 'live':
+            self.listLiveStreams(self.currItem)
+    #SEARCH
+        elif category in ["search", "search_next_page"]:
+            cItem = dict(self.currItem)
+            cItem.update({'search_item':False, 'name':'category'}) 
+            self.listSearchResult(cItem, searchPattern, searchType)
+    #HISTORIA SEARCH
+        elif category == "search_history":
+            self.listsHistory({'name':'history', 'category': 'search'}, 'desc', _("Type: "))
+        else:
+            printExc()
+        
+        CBaseHostClass.endHandleService(self, index, refresh)
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, Watchwrestling(), True, []) #CDisplayListItem.TYPE_VIDEO, CDisplayListItem.TYPE_AUDIO
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('watchwrestlinglogo.png')])
+    
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+        
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            retlist.append(CUrlItem(item["name"], item["url"], item['need_resolve']))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        retlist = []
+        urlList = self.host.getVideoLinks(url)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    
+    def converItem(self, cItem):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie  
+        searchTypesOptions.append((_("DATE"),         "date"))
+        searchTypesOptions.append((_("VIEWS"),       "views"))
+        searchTypesOptions.append((_("LIKES"),       "likes"))
+        searchTypesOptions.append((_("COMMENTS"), "comments"))
+        
+        hostLinks = []
+        type = CDisplayListItem.TYPE_UNKNOWN
+        possibleTypesOfSearch = None
+
+        if 'category' == cItem['type']:
+            if cItem.get('search_item', False):
+                type = CDisplayListItem.TYPE_SEARCH
+                possibleTypesOfSearch = searchTypesOptions
+            else:
+                type = CDisplayListItem.TYPE_CATEGORY
+        elif cItem['type'] == 'video':
+            type = CDisplayListItem.TYPE_VIDEO
+        elif 'more' == cItem['type']:
+            type = CDisplayListItem.TYPE_MORE
+        elif 'audio' == cItem['type']:
+            type = CDisplayListItem.TYPE_AUDIO
+            
+        if type in [CDisplayListItem.TYPE_AUDIO, CDisplayListItem.TYPE_VIDEO]:
+            url = cItem.get('url', '')
+            if '' != url:
+                hostLinks.append(CUrlItem("Link", url, 1))
+            
+        title       =  cItem.get('title', '')
+        description =  cItem.get('desc', '')
+        icon        =  cItem.get('icon', '')
+        
+        return CDisplayListItem(name = title,
+                                    description = description,
+                                    type = type,
+                                    urlItems = hostLinks,
+                                    urlSeparateRequest = 1,
+                                    iconimage = icon,
+                                    possibleTypesOfSearch = possibleTypesOfSearch)
+    # end converItem
+
+    def getSearchItemInx(self):
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'search':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostwrestlingnetwork.py ./IPTVPlayer/hosts/Sport/hostwrestlingnetwork.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/Sport/hostwrestlingnetwork.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/Sport/hostwrestlingnetwork.py	2015-11-19 06:26:29.104560000 +0100
@@ -0,0 +1,327 @@
+﻿# -*- coding: utf-8 -*-
+
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _, SetIPTVPlayerLastHostError
+from Plugins.Extensions.IPTVPlayer.components.ihost import CHostBase, CBaseHostClass, CDisplayListItem, ArticleContent, RetHost, CUrlItem
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import CSelOneLink, printDBG, printExc, CSearchHistoryHelper, GetLogoDir, GetCookieDir
+from Plugins.Extensions.IPTVPlayer.libs.urlparserhelper import getDirectM3U8Playlist
+from Plugins.Extensions.IPTVPlayer.libs.urlparser import urlparser
+from Plugins.Extensions.IPTVPlayer.libs.youtube_dl.utils import clean_html
+from Plugins.Extensions.IPTVPlayer.libs.crypto.hash.sha1Hash import SHA1
+###################################################
+
+###################################################
+# FOREIGN import
+###################################################
+from Components.config import config, ConfigInteger, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry
+from datetime import timedelta
+from binascii import hexlify
+import re
+import urllib
+import time
+import random
+try:    import simplejson as json
+except: import json
+###################################################
+
+
+###################################################
+# E2 GUI COMMPONENTS 
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.asynccall import MainSessionWrapper
+from Screens.MessageBox import MessageBox
+from Components.config import config, ConfigSelection, getConfigListEntry
+###################################################
+
+
+###################################################
+# Config options for HOST
+###################################################
+config.plugins.iptvplayer.wrestling_net_sort = ConfigSelection(default = "", choices = [("", _("DEFAULT")), ("views", _("VIEWS")),("date", _("DATE"))])
+   
+def GetConfigList():
+    optionList = []
+    optionList.append(getConfigListEntry(_("SORT"), config.plugins.iptvplayer.TVN24httpType))
+    return optionList
+###################################################
+
+def gettytul():
+    return 'http://wrestlingnetwork.tv/'
+
+class WrestlingNet(CBaseHostClass):
+    MAIN_URL   = 'http://wrestlingnetwork.tv/'
+    BASE_IMAGE = MAIN_URL + 'public/images/'
+    
+    MAIN_CAT_TAB = [{'category':'latest',   'url':"",                           'title': _("LATEST VIDEOS"),     'icon':''},
+                    {'category':'tag',      'url':"tag/show-replay",             'title': _("SHOW REPLAY"),       'icon':''},
+                    {'category':'category', 'url':"category/wwe-network",        'title': _("WWE NETWORK"),       'icon':''},
+                    {'category':'category', 'url':"category/wwe",                'title': _("WWE"),               'icon':''},
+                    {'category':'category', 'url':"category/wwe/wwe-raw",        'title': _("RAW"),               'icon':BASE_IMAGE+'2013/03/348-529x300.jpg'},
+                    {'category':'category', 'url':"category/wwe/wwe-smackdown",  'title': _("SMACKDOWN"),         'icon':BASE_IMAGE+'2013/03/347-529x300.jpg'},
+                    {'category':'category', 'url':"category/wwe/wwe-nxt",        'title': _("NXT"),               'icon':BASE_IMAGE+'2013/03/3953-529x300.jpg'},
+                    {'category':'category', 'url':"category/lucha-underground",  'title': _("LUCHA UNDERGROUND"), 'icon':BASE_IMAGE+'2015/01/lucha_underground-533x300.jpg'},
+                    {'category':'category', 'url':"category/njpw",               'title': _("NJPW"),              'icon':BASE_IMAGE+'2015/04/NJPW-copy-554x300.jpg'},
+                    {'category':'category', 'url':"category/tna",                'title': _("TNA"),               'icon':BASE_IMAGE+'2015/03/WN-TNA-563x300.jpg'},
+                    {'category':'search',                'title':_('Search'), 'search_item':True},
+                    {'category':'search_history',        'title':_('Search history')} ]
+    
+    def __init__(self):
+        printDBG("WrestlingNet.__init__")
+        CBaseHostClass.__init__(self, {'history':'wrestling-network.net'})
+        self.cacheFilters = []
+        self.cacheSeries = {}
+        
+    def _getFullUrl(self, url):
+        if 0 < len(url) and not url.startswith('http'):
+            url =  self.MAIN_URL + url
+        return url
+
+    def listsTab(self, tab, cItem):
+        printDBG("WrestlingNet.listsMainMenu")
+        for item in tab:
+            params = dict(cItem)
+            params.update(item)
+            params['name']  = 'category'
+            self.addDir(params)
+
+    def listLatestVideos(self, cItem, category):
+        printDBG("WrestlingNet.listLatestVideos")
+        self._listVideos(cItem)
+        
+    def listVideosByTag(self, cItem, category):
+        printDBG("WrestlingNet.listVideosByTag")
+        self._listVideos(cItem)
+        
+    def listVideosByCategory(self, cItem, category):
+        printDBG("WrestlingNet.listVideosByCategory")
+        self._listVideos(cItem)
+        
+    def listSearchResult(self, cItem, searchPattern, searchType):
+        printDBG("WrestlingNet.listSearchResult cItem[%s], searchPattern[%s] searchType[%s]" % (cItem, searchPattern, searchType))
+        searchPattern = urllib.quote_plus(searchPattern)
+        cItem.update({'srch':'?s=' + searchPattern})
+        self._listVideos(cItem)
+    
+    #def _listVideos(self, cItem, m1='class="item', m2='</div></div></div></div><div', sp='class="item'):
+    def _listVideos(self, cItem, m1='<div id="post-', m2='end .loop-content', sp='<div id="post-'):
+        printDBG("WrestlingNet._listVideos")
+        
+        page = cItem.get('page', 1)
+        url = cItem.get('url', '')
+        if page > 1:
+            url += '/page/%s' % page
+        url += cItem.get('srch', '')
+        if '?' in url: url += '&'
+        else: url += '?'
+        url += 'orderby=' + config.plugins.iptvplayer.wrestling_net_sort.value
+        url = self._getFullUrl(url)
+        
+        sts, data = self.cm.getPage(url)
+        if not sts: return
+        
+        if ('/page/%s?' % (page+1)) in data:
+            nextPage = True
+        else: nextPage = False
+        
+        sts, data = self.cm.ph.getDataBeetwenMarkers(data, m1, m2, True)
+        if not sts:
+            SetIPTVPlayerLastHostError(_("WrestlingNet._listVideos - no markers [m1][m2] found!"))
+            return
+        
+        data = data.split(sp)
+        if len(data): del data[0]
+        for item in data:
+            icon   = self.cm.ph.getSearchGroups(item, 'src="([^"]+?)"')[0]
+            url    = self.cm.ph.getSearchGroups(item, 'href="([^"]+?)"')[0]
+            title  = self.cm.ph.getSearchGroups(item, 'title="([^"]+?)"')[0]
+            if '' == title: title  = self.cm.ph.getSearchGroups(item, 'alt="([^"]+?)"')[0]
+            desc   =  self.cleanHtmlStr('<' + item + '>')
+            if '' != url and '' != title:
+                params = dict(cItem)
+                params.update( {'title':title, 'url':self._getFullUrl(url), 'desc':desc, 'icon':self._getFullUrl(icon)} )
+                self.addVideo(params)
+        
+        if nextPage:
+            params = params = dict(cItem)
+            params.update({'title':_("Następna strona"), 'page':page+1})
+            self.addDir(params)
+    
+    def getLinksForVideo(self, cItem):
+        printDBG("WrestlingNet.getLinksForVideo [%s]" % cItem)
+        urlTab = []
+        sts, data = self.cm.getPage(cItem['url'])
+        if not sts: return urlTab
+        
+        sts, data = self.cm.ph.getDataBeetwenMarkers(data, 'entry-content', 'video-meta-info', True) #'id="more-'
+        if not sts:
+            SetIPTVPlayerLastHostError(_("Please visit '%s' from using web-browser form the PC. If links are available please report this problem.\nEmail: samsamsam@o2.pl") % cItem['url'])
+            return urlTab
+            
+        data = data.split('<h2>')
+        if len(data): del data[0]
+        re_links = re.compile('<a[^>]+?href="([^"]+?)"[^>]*?>([^<]+?)</a>')
+        for item in data:
+            type = self.cleanHtmlStr( item.split('</h2>')[0] )
+            
+            links = re_links.findall(item)
+            for link in links:
+                urlTab.append({'name':type + ' ' + link[1], 'url':link[0]})
+            
+        return urlTab
+        
+    def getResolvedURL(self, url):
+        printDBG("WrestlingNet.getResolvedURL [%s]" % url)
+        urlTab = []
+        sts, data = self.cm.getPage(url)
+        if not sts: return urlTab
+        
+        videoUrl = self.cm.ph.getSearchGroups(data, '<iframe[^>]+?src="([^"]+?)"')[0]
+        if not videoUrl:
+            videoUrl = self.cm.ph.getSearchGroups(data, "file: '([^']+?)'")[0]
+            if '.m3u8' in videoUrl:
+                urlTab = getDirectM3U8Playlist(videoUrl, checkExt=True)
+            
+        urlTab = self.up.getVideoLinkExt( videoUrl )
+        return urlTab
+        
+    def getFavouriteData(self, cItem):
+        return cItem['url']
+        
+    def getLinksForFavourite(self, fav_data):
+        return self.getLinksForVideo({'url':fav_data})
+    
+    def handleService(self, index, refresh=0, searchPattern='', searchType=''):
+        printDBG('WrestlingNet.handleService start')
+        CBaseHostClass.handleService(self, index, refresh, searchPattern, searchType)
+        name     = self.currItem.get("name", None)
+        category = self.currItem.get("category", '')
+        printDBG( "WrestlingNet.handleService: ---------> name[%s], category[%s] " % (name, category) )
+        searchPattern = self.currItem.get("search_pattern", searchPattern)
+        self.currList = [] 
+
+    #MAIN MENU
+        if None == name:
+            self.listsTab(WrestlingNet.MAIN_CAT_TAB, {'name':'category'})
+    #LATEST
+        elif 'latest' == category:
+            self.listLatestVideos(self.currItem, '')
+    #TAG
+        elif 'tag' == category:
+            self.listVideosByTag(self.currItem, '')
+    #CATEGORY
+        elif 'category' == category:
+            self.listVideosByCategory(self.currItem, '')
+    #WYSZUKAJ
+        elif category in ["search", "search_next_page"]:
+            cItem = dict(self.currItem)
+            cItem.update({'search_item':False, 'name':'category'}) 
+            self.listSearchResult(cItem, searchPattern, searchType)
+    #HISTORIA WYSZUKIWANIA
+        elif category == "search_history":
+            self.listsHistory({'name':'history', 'category': 'search'}, 'desc', _("Type: "))
+        else:
+            printExc()
+        CBaseHostClass.endHandleService(self, index, refresh)
+
+class IPTVHost(CHostBase):
+
+    def __init__(self):
+        CHostBase.__init__(self, WrestlingNet(), True)
+
+    def getLogoPath(self):
+        return RetHost(RetHost.OK, value = [GetLogoDir('wrestlingnetworklogo.png')])
+    
+    def getLinksForVideo(self, Index = 0, selItem = None):
+        retCode = RetHost.ERROR
+        retlist = []
+        if not self.isValidIndex(Index): return RetHost(retCode, value=retlist)
+        
+        urlList = self.host.getLinksForVideo(self.host.currList[Index])
+        for item in urlList:
+            need_resolve = 1
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+    # end getLinksForVideo
+    
+    def getResolvedURL(self, url):
+        # resolve url to get direct url to video file
+        retlist = []
+        urlList = self.host.getResolvedURL(url)
+        for item in urlList:
+            need_resolve = 0
+            retlist.append(CUrlItem(item["name"], item["url"], need_resolve))
+
+        return RetHost(RetHost.OK, value = retlist)
+
+    def convertList(self, cList):
+        hostList = []
+        searchTypesOptions = [] # ustawione alfabetycznie
+        #searchTypesOptions.append(("Filmy",  "filmy"))
+        #searchTypesOptions.append(("Seriale","seriale"))
+        
+        for cItem in cList:
+            hostLinks = []
+            type = CDisplayListItem.TYPE_UNKNOWN
+            possibleTypesOfSearch = None
+
+            if 'category' == cItem['type']:
+                if cItem.get('search_item', False):
+                    type = CDisplayListItem.TYPE_SEARCH
+                    possibleTypesOfSearch = searchTypesOptions
+                else:
+                    type = CDisplayListItem.TYPE_CATEGORY
+            elif cItem['type'] == 'video':
+                type = CDisplayListItem.TYPE_VIDEO
+            elif 'more' == cItem['type']:
+                type = CDisplayListItem.TYPE_MORE
+            elif 'audio' == cItem['type']:
+                type = CDisplayListItem.TYPE_AUDIO
+                
+            if type in [CDisplayListItem.TYPE_AUDIO, CDisplayListItem.TYPE_VIDEO]:
+                url = cItem.get('url', '')
+                if '' != url:
+                    hostLinks.append(CUrlItem("Link", url, 1))
+                
+            title       =  self.host.cleanHtmlStr( cItem.get('title', '') )
+            description =  self.host.cleanHtmlStr( cItem.get('desc', '') )
+            icon        =  self.host.cleanHtmlStr( cItem.get('icon', '') )
+            
+            hostItem = CDisplayListItem(name = title,
+                                        description = description,
+                                        type = type,
+                                        urlItems = hostLinks,
+                                        urlSeparateRequest = 1,
+                                        iconimage = icon,
+                                        possibleTypesOfSearch = possibleTypesOfSearch)
+            hostList.append(hostItem)
+
+        return hostList
+    # end convertList
+
+    def getSearchItemInx(self):
+        try:
+            list = self.host.getCurrList()
+            for i in range( len(list) ):
+                if list[i]['category'] == 'search':
+                    return i
+        except:
+            printDBG('getSearchItemInx EXCEPTION')
+            return -1
+
+    def setSearchPattern(self):
+        try:
+            list = self.host.getCurrList()
+            if 'history' == list[self.currIndex]['name']:
+                pattern = list[self.currIndex]['title']
+                search_type = list[self.currIndex]['search_type']
+                self.host.history.addHistoryItem( pattern, search_type)
+                self.searchPattern = pattern
+                self.searchType = search_type
+        except:
+            printDBG('setSearchPattern EXCEPTION')
+            self.searchPattern = ''
+            self.searchType = ''
+        return
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/XXX/hostXXX.py ./IPTVPlayer/hosts/XXX/hostXXX.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/hosts/XXX/hostXXX.py	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/hosts/XXX/hostXXX.py	2015-11-25 11:59:23.302458999 +0100
@@ -0,0 +1,1831 @@
+# -*- coding: utf-8 -*-
+ 
+###################################################
+# LOCAL import
+###################################################
+from Plugins.Extensions.IPTVPlayer.components.ihost import IHost, CDisplayListItem, RetHost, CUrlItem
+import Plugins.Extensions.IPTVPlayer.libs.pCommon as pCommon
+from Plugins.Extensions.IPTVPlayer.tools.iptvtools import printDBG, CSelOneLink
+import Plugins.Extensions.IPTVPlayer.libs.urlparser as urlparser
+
+###################################################
+# FOREIGN import
+###################################################
+import re, urllib, urllib2, base64, math 
+try:
+    import simplejson
+except:
+    import json as simplejson   
+from Tools.Directories import resolveFilename, SCOPE_PLUGINS
+from Components.config import config, ConfigSelection, ConfigYesNo, ConfigText, getConfigListEntry, ConfigPIN
+###################################################
+
+###################################################
+# Config options for HOST
+###################################################
+def GetConfigList():
+    optionList = []
+    return optionList
+###################################################
+
+###################################################
+# Title of HOST
+###################################################
+def gettytul():
+    return 'XXX'
+
+class IPTVHost(IHost):
+    LOGO_NAME = 'XXXlogo.png'
+    PATH_TO_LOGO = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/icons/logos/' + LOGO_NAME )
+
+    def __init__(self):
+        printDBG( "init begin" )
+        self.host = Host()
+        self.prevIndex = []
+        self.currList = []
+        self.prevList = []
+        printDBG( "init end" )
+        
+    def isProtectedByPinCode(self):
+        return True
+    
+    def getLogoPath(self):  
+        return RetHost(RetHost.OK, value = [self.PATH_TO_LOGO])
+
+    def getInitList(self):
+        printDBG( "getInitList begin" )
+        self.prevIndex = []
+        self.currList = self.host.getInitList()
+        self.host.setCurrList(self.currList)
+        self.prevList = []
+        printDBG( "getInitList end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        printDBG( "getListForItem begin" )
+        self.prevIndex.append(Index)
+        self.prevList.append(self.currList)
+        self.currList = self.host.getListForItem(Index, refresh, selItem)
+        #self.currList = [ self.prevList[-1][Index] ]
+        printDBG( "getListForItem end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getPrevList(self, refresh = 0):
+        printDBG( "getPrevList begin" )
+        if(len(self.prevList) > 0):
+            self.prevIndex.pop()
+            self.currList = self.prevList.pop()
+            self.host.setCurrList(self.currList)
+            printDBG( "getPrevList end OK" )
+            return RetHost(RetHost.OK, value = self.currList)
+        else:
+            printDBG( "getPrevList end ERROR" )
+            return RetHost(RetHost.ERROR, value = [])
+
+    def getCurrentList(self, refresh = 0):
+        printDBG( "getCurrentList begin" )
+        #if refresh == 1
+        #self.prevIndex[-1] #ostatni element prevIndex
+        #self.prevList[-1]  #ostatni element prevList
+        #tu pobranie listy dla dla elementu self.prevIndex[-1] z listy self.prevList[-1]  
+        printDBG( "getCurrentList end" )
+        return RetHost(RetHost.OK, value = self.currList)
+
+    def getLinksForVideo(self, Index = 0, item = None):
+        return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+        
+    def getResolvedURL(self, url):
+        printDBG( "getResolvedURL begin" )
+        if url != None and url != '':        
+            ret = self.host.getResolvedURL(url)
+            if ret != None and ret != '':        
+               printDBG( "getResolvedURL ret: "+ret)
+               list = []
+               list.append(ret)
+               printDBG( "getResolvedURL end OK" )
+               return RetHost(RetHost.OK, value = list)
+            else:
+               printDBG( "getResolvedURL end" )
+               return RetHost(RetHost.NOT_IMPLEMENTED, value = [])                
+        else:
+            printDBG( "getResolvedURL end" )
+            return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+
+    def getSearchResults(self, pattern, searchType = None):
+        return RetHost(RetHost.NOT_IMPLEMENTED, value = [])
+
+    ###################################################
+    # Additional functions on class IPTVHost
+    ###################################################
+
+class Host:
+    XXXversion = "18.0.0.0"
+    XXXremote  = "0.0.0.0"
+    currList = []
+    MAIN_URL = ''
+    
+    def __init__(self):
+        printDBG( 'Host __init__ begin' )
+        self.cm = pCommon.common()
+        self.currList = []
+        _url = 'https://gitlab.com/iptv-host-xxx/iptv-host-xxx/blob/master/IPTVPlayer/hosts/hostXXX.py'
+        query_data = { 'url': _url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+        try:
+           data = self.cm.getURLRequestData(query_data)
+           #printDBG( 'Host init data: '+data )
+           r=re.search( r'XXXversion.*?&quot;(.*?)&quot;',data)
+           if r:
+              printDBG( 'r' )
+              self.XXXremote=r.group(1)
+        except:
+           printDBG( 'Host init query error' )
+        printDBG( 'Host __init__ end' )
+        
+    def setCurrList(self, list):
+        printDBG( 'Host setCurrList begin' )
+        self.currList = list
+        printDBG( 'Host setCurrList end' )
+        return 
+
+    def getInitList(self):
+        printDBG( 'Host getInitList begin' )
+        #self.currList = self.MAIN_MENU
+        self.currList = self.listsItems(-1, '', 'main-menu')
+        printDBG( 'Host getInitList end' )
+        return self.currList
+
+    def getListForItem(self, Index = 0, refresh = 0, selItem = None):
+        printDBG( 'Host getListForItem begin' )
+        valTab = []
+        if len(self.currList[Index].urlItems) == 0:
+           return valTab
+        valTab = self.listsItems(Index, self.currList[Index].urlItems[0], self.currList[Index].urlSeparateRequest)
+        self.currList = valTab
+        printDBG( 'Host getListForItem end' )
+        return self.currList
+
+    def listsItems(self, Index, url, name = ''):
+        printDBG( 'Host listsItems begin' )
+        printDBG( 'Host listsItems url: '+url )
+        valTab = []
+        if name == 'main-menu':
+           printDBG( 'Host listsItems begin name='+name )
+           #if self.XXXversion <> self.XXXremote and self.XXXremote <> "0.0.0.0":
+              #valTab.append(CDisplayListItem('---UPDATE---','UPDATE MENU',        CDisplayListItem.TYPE_CATEGORY, [''],                                     'UPDATE',  '', None)) 
+           valTab.append(CDisplayListItem('4TUBE',          'www.4tube.com',      CDisplayListItem.TYPE_CATEGORY, ['http://www.4tube.com/tags'],            '4tube',   'http://i.4tube.com/free-porn.png', None)) 
+           valTab.append(CDisplayListItem('EPORNER',        'www.eporner.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.eporner.com/categories/'],   'eporner', 'http://static.eporner.com/new/logo.png', None)) 
+           #valTab.append(CDisplayListItem('TUBE8 mobile',   'm.tube8.com',        CDisplayListItem.TYPE_CATEGORY, ['http://m.tube8.com'],                   'tube8',   'http://cdn1.static.tube8.phncdn.com/images/t8logo.png', None)) 
+           valTab.append(CDisplayListItem('TUBE8',          'www.tube8.com',      CDisplayListItem.TYPE_CATEGORY, ['http://www.tube8.com/categories.html'], 'fulltube8',   'http://cdn1.static.tube8.phncdn.com/images/t8logo.png', None)) 
+           #valTab.append(CDisplayListItem('YOUPORN mobile', 'mobile.youporn.com', CDisplayListItem.TYPE_CATEGORY, ['http://mobile.youporn.com'],            'youporn',               'http://cdn1.static.youporn.phncdn.com/cb/bundles/youpornwebfront/images/l_youporn_black.png', None)) 
+           valTab.append(CDisplayListItem('YOUPORN',        'wwww.youporn.com',   CDisplayListItem.TYPE_CATEGORY, ['http://www.youporn.com/categories/alphabetical/'],'fullyouporn', 'http://cdn1.static.youporn.phncdn.com/cb/bundles/youpornwebfront/images/l_youporn_black.png', None)) 
+           #valTab.append(CDisplayListItem('PORNHUB mobile', 'm.pornhub.com',      CDisplayListItem.TYPE_CATEGORY, ['http://m.pornhub.com'],                 'pornhub', 'http://cdn1.static.pornhub.phncdn.com/images/pornhub_logo.png', None)) 
+           valTab.append(CDisplayListItem('PORNHUB',        'www.pornhub.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.pornhub.com/categories'],    'fullpornhub', 'http://cdn1.static.pornhub.phncdn.com/images/pornhub_logo.png', None)) 
+           valTab.append(CDisplayListItem('HDPORN',         'www.hdporn.net',     CDisplayListItem.TYPE_CATEGORY, ['http://www.hdporn.net/channels/'],      'hdporn',  'http://www.hdporn.net/gfx/logo.gif', None)) 
+           valTab.append(CDisplayListItem('REDTUBE',        'www.redtube.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.redtube.com/channels'],      'redtube', 'http://img02.redtubefiles.com/_thumbs/design/logo/redtube_260x52_black.png', None)) 
+           valTab.append(CDisplayListItem('XHAMSTER',       'xhamster.com',       CDisplayListItem.TYPE_CATEGORY, ['http://xhamster.com/channels.php'],     'xhamster','http://eu-st.xhamster.com/images/tpl2/logo.png', None)) 
+           valTab.append(CDisplayListItem('HENTAIGASM',     'hentaigasm.com',     CDisplayListItem.TYPE_CATEGORY, ['http://hentaigasm.com'],                'hentaigasm','http://hentaigasm.com/wp-content/themes/detube/images/logo.png', None)) 
+           valTab.append(CDisplayListItem('XVIDEOS',        'www.xvideos.com',    CDisplayListItem.TYPE_CATEGORY, ['http://www.xvideos.com'],               'xvideos', 'http://img100.xvideos.com/videos/thumbs/xvideos.gif', None)) 
+           valTab.append(CDisplayListItem('XNXX',           'www.xnxx.com',       CDisplayListItem.TYPE_CATEGORY, ['http://www.xnxx.com'],                  'xnxx',    'http://img100.xvideos.com/xnxx.com/pics/xnxx.gif', None)) 
+           valTab.append(CDisplayListItem('PORNWAY',        'www.pornway.com',     CDisplayListItem.TYPE_CATEGORY, ['http://www.pornway.com'],  'pornusy', 'http://www.pornway.com/porno.png', None)) 
+           valTab.append(CDisplayListItem('BEEG',           'beeg.com',           CDisplayListItem.TYPE_CATEGORY, ['http://beeg.com/api/v1/index/main/0/mobile'],                      'beeg',    'http://staticloads.com/img/logo/logo.png', None))
+           valTab.append(CDisplayListItem('PORNRABBIT',     'www.pornrabbit.com', CDisplayListItem.TYPE_CATEGORY, ['http://www.pornrabbit.com/page/categories/'],'pornrabbit','http://cdn1.static.pornrabbit.com/pornrabbit/img/logo.png', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.append(CDisplayListItem('SHOWUP   - live cams',       'showup.tv',          CDisplayListItem.TYPE_CATEGORY, ['http://showup.tv'],                     'showup',  'http://3.bp.blogspot.com/-E6FltqaarDQ/UXbA35XtARI/AAAAAAAAAPY/5-eNrAt8Nyg/s1600/show.jpg', None)) 
+           #valTab.append(CDisplayListItem('ZBIORNIK - live cams',       'zbiornik.com',       CDisplayListItem.TYPE_CATEGORY, ['http://zbiornik.com/live/'],            'zbiornik','http://static.zbiornik.com/images/zbiornikBig.png', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fulltube8' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.tube8.com' 
+           parser = 'http://www.tube8.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('categoriesFooterFontSize(.*?)</ul>', data, re.S)
+           if not parse: return []
+           phCats = re.findall("<a href='(.*?)'.*?>(.*?)<", parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fulltube8-clips', '', None)) 
+           phCats = re.findall('<a href="(.*?)".*?>(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fulltube8-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem('--- Featured videos ---', 'Featured videos', CDisplayListItem.TYPE_CATEGORY, ['http://www.tube8.com'], 'fulltube8-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Hits ---', 'Hits',               CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hits/'],      'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Hot ---', 'Hot',                 CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hot/'],       'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],      'xnxx-clips', '', None)) 
+           #valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/new/'],       'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fulltube8-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="thumb-wrapper float-left".*?src="(.*?)".*?href="(.*?)".*?title="(.*?)".*?<strong>(.*?)</strong>', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle, phTime ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phTime: ' +phTime )                  
+                  valTab.append(CDisplayListItem(phTitle,'['+phTime+']'+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('id="pagination_next" href="(.*?)">NEXT<', data, re.S)
+           if match:
+              phUrl = match[-1]
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.xnxx.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('ALL SEX VIDEOS:(.*?)<a href="http://www.xnxx.com/tags/">More', data, re.S)
+           if not parse: return valTab
+           phCats = re.findall('<a href="(.*?)">(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'xnxx-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem('--- Tags alfabetical ---',  'Tags',         CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/tags/'],      'xnxx-tagsalfa', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Hits ---', 'Hits',               CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hits/'],      'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Hot ---', 'Hot',                 CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/hot/'],       'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],      'xnxx-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/new/'],       'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx-tagsalfa' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<td align=left nowrap><a href="(.*?)">(.*?)</a>(.*?)<', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phCount) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phCount: '+phCount )
+                  valTab.append(CDisplayListItem(phTitle+': '+phCount,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xnxx-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xnxx-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           if not data: return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           try: phMovies = re.findall('<li><div align="center">.*?href="(.*?)".*?src="(.*?)".*?title="(.*?)".*?#5C99FE">(.*?)<', data, re.S)
+           except:
+              printDBG( 'Host listsItems phmovies error' )
+              return valTab           
+           #printDBG( 'Host listsItems phmovies ' )
+           if phMovies:
+              for (phUrl, phImage, phTitle, phTime ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phTime: ' +phTime )                  
+                  phTitle = decodeHtml(phTitle)
+                  valTab.append(CDisplayListItem(phTitle,phTime+'\n'+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<a class="nP" href="(.*?)">Next<', data, re.S)
+           if match:
+              phUrl = match[-1]
+              if phUrl[0] <> '/'[0]:
+                 phUrl = '/'+phUrl
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'zbiornik' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://zbiornik.com' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'zbiornik.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://zbiornik.com/#ENTER', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           #printDBG( 'Host listsItems data cookie: '+data )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           ph1 = re.search('var streams=(.*?)}];', data, re.S)
+           if ph1: ph1 = ph1.group(1)+'}]'
+           result = simplejson.loads(ph1)
+           if result:
+              for item in result:
+                  printDBG( 'Host listsItems nick: '+item["nick"] )
+                  printDBG( 'Host listsItems broadcasturl: '+item["broadcasturl"] )
+                  printDBG( 'Host listsItems topic: '+item["topic"] )
+                  printDBG( 'Host listsItems goalDsc: '+item["goalDsc"] )
+                  phImage = 'http://cm2.zbiornik.com/cams/'+str(item["broadcasturl"])+'-224.jpg'
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  streamUrl = 'rtmp://'+str(item["server"])[0]+''+str(item["server"])[1:]+'/videochat playpath='+str(item["broadcasturl"])+' swfUrl=http://zbiornik.com/wowza.swf?v42 pageUrl=http://zbiornik.com/live/'
+                  printDBG( 'Host listsItems streamUrl: '+streamUrl )
+                  valTab.append(CDisplayListItem(str(item["nick"]),str(item["topic"])+' ; '+str(item["goalDsc"]),CDisplayListItem.TYPE_VIDEO, [CUrlItem('', streamUrl, 0)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'showup' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://showup.tv' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'showup.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://showup.tv/site/accept_rules/yes?ref=http://showup.tv/', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="stream-meta".*?data-original="(.*?)".*?href="(.*?)".*?class="stream-name">(.*?)<.*?class="stream-desc">(.*?)<', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle, phDesc ) in phMovies:
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phDesc: '+phDesc )
+                  phImage = self.MAIN_URL+'/'+phImage
+                  valTab.append(CDisplayListItem(phTitle,phDesc,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xvideos' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.xvideos.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('id="categories"(.*?)</div>', data, re.S)
+           phCats = re.findall('<a href="(.*?)">(.*?)<', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xvideos-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.insert(0,CDisplayListItem('--- Pornstars ---',   'Pornstars',   CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/pornstars'], 'xvideos-pornstars', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- Best Videos ---', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'],     'xvideos-clips', '', None)) 
+           valTab.insert(0,CDisplayListItem('--- New Videos ---',  'New Videos',  CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],              'xvideos-clips', '', None)) 
+
+           #valTab.append(CDisplayListItem('Best Videos', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/channels'],  'xvideos-clips', '', None)) 
+           #valTab.append(CDisplayListItem('Best Videos', 'Best Videos', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/best/'], 'xvideos-clips', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xvideos-pornstars' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="thumbProfile".*?href="(.*?)".*?img src="(.*?)".*?href=".*?">(.*?)<', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '  +phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'xvideos-clips', phImage, None)) 
+        if 'xvideos-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="thumb".*?img src="(.*?)".*?href="(.*?)" title="(.*?)"', data, re.S)
+           if phMovies:
+              for (phImage, phUrl, phTitle ) in phMovies:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  phTitle = decodeHtml(phTitle)
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<li><a class="nP" href="(.*?)"', data, re.S)
+           if match:
+              phUrl = match[-1]
+              if phUrl[0] <> '/'[0]:
+                 phUrl = '/'+phUrl
+              valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hentaigasm' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://hentaigasm.com' 
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('Genres(.*?)</div></div>', data, re.S)
+           if not parse: return valTab
+           phCats = re.findall("<a href='(.*?)'.*?>(.*?)<", parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'hentaigasm-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- New ---", "New",        CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL], 'hentaigasm-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hentaigasm-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="thumb">.*?title="(.*?)" href="(.*?)".*?<img src="(.*?)"', data, re.S)
+           if phMovies:
+              for (phTitle, phUrl, phImage) in phMovies:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  #phImage.replace(' ','%20')
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.search("<div class='wp-pagenavi'>(.*?)</div>", data, re.S)
+           if match: match = re.findall("href='(.*?)'", match.group(1), re.S)
+           if match:
+                  phUrl = match[-1]
+                  #printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullyouporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.youporn.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           #phCats = re.findall('class="cat_pic">.*?<a\shref="/category(.*?)".*?<img\ssrc="(.*?)"\salt="(.*?)"><span\sclass="cat_overlay', data, re.S)
+           phCats = re.findall('<li\sclass=\'.*?\'><a\shref="/category/(.*?)">(.*?)</a', data, re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  #printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  phUrl = self.MAIN_URL+"/category/" + phUrl
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'fullyouporn-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           #valTab.insert(0,CDisplayListItem("--- Channels ---",           "Channels",           CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/channels/most_subscribed/alltime/"], 'fullyouporn-channels', '',None))
+           #valTab.insert(0,CDisplayListItem("Popular by Country", "Popular by Country", CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/categories/"],                       'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Discussed ---",     "Most Discussed",     CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_discussed/"],                   'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Favorited ---",     "Most Favorited",     CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_favorited/"],                   'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Most Viewed ---",        "Most Viewed",        CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/most_viewed/"],                      'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- Top Rated ---",          "Top Rated",          CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/top_rated/"],                        'fullyouporn-clips', '',None))
+           #valTab.insert(0,CDisplayListItem("--- New ---",                "New",                CDisplayListItem.TYPE_CATEGORY,["http://www.youporn.com/"],                                  'fullyouporn-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullyouporn-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('class=\'row video-row\'>(.*?)class=\'footer', data, re.S)
+           if not parse:
+              parse = re.search('class=\'title-bar(.*?)class=\'footer', data, re.S) 
+           phMovies = re.findall('class=\'video-box.*?<a\shref="(.*?)".*?<img\ssrc=".*?"\salt=\'(.*?)\'.*?data-(thumbnail|echo)="(.*?)".*?class=\'video-box-percentage\sup\'>(.*?)</span>.*?class="video-box-duration">(.*?)</span>', parse.group(1), re.S)
+           if phMovies:
+              for (phUrl, phTitle, phdummy, phImage, phViews, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  phUrl = phUrl.replace("&amp;","&")
+                  valTab.append(CDisplayListItem(decodeHtml(phTitle),'['+phRuntime+'] ['+phViews+'] '+decodeHtml(phTitle),CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<nav id="pagination">.*?</nav>', data, re.S)
+           if match:
+              #printDBG( 'Host listsItems page match: '+match[0] )
+              match = re.findall('href="(.*?)"', match[0], re.S)
+           if match:
+                  phUrl = match[-1]
+                  #printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'redtube' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.redtube.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="video">.*?<a href="(.*?)" title="(.*?)">.*?data-src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'redtube-clips', phImage, None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Most Favored ---", "Most Favored", CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/mostfavored?period=alltime"], 'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Viewed ---",  "Most Viewed",  CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/mostviewed?period=alltime"],  'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---",    "Top Rated",    CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/top?period=alltime"],         'redtube-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Newest ---",       "Newest",       CDisplayListItem.TYPE_CATEGORY,["http://www.redtube.com/"],                           'redtube-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'redtube-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="video-duration".*?>(.*?)<.*?data-src="(.*?)".*?<a href="(.*?)" title="(.*?)".*?<span class="video-views">(.*?)<', data, re.S)
+           if phMovies:
+              for (phRuntime, phImage, phUrl, phTitle, phViews) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] ['+phViews+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<link rel="next" href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xhamster' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://xhamster.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('id="letter_A">(.*?)id="footer">', data, re.S)
+           phCats = re.findall('href="(.*?)">(.*?)<div.*?</a>', parse.group(1), re.S|re.I)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  phTitle = phTitle.strip(' ')
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'xhamster-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- New ---",       "New",       CDisplayListItem.TYPE_CATEGORY,["http://xhamster.com/"], 'xhamster-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'xhamster-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           if re.search('vDate', data, re.S):
+              parse = re.search('<div\sclass=\'vDate(.*)</html>', data, re.S)
+           else:
+              parse = re.search('<html>(.*)</html>', data, re.S)
+           phMovies = re.findall('class=\'video\'><a\shref=\'(.*?/movies/.*?)\'.*?class=\'hRotator\'\s><img\ssrc=\'(.*?)\'.*?alt="(.*?)".*?start2.*?<b>(.*?)</b>', parse.group(1), re.S)
+           if phMovies:
+              for (phUrl, phImage, phTitle, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall("<div class='pager'>.*?>Next<", data, re.S)
+           if match:
+              match = re.findall("href='(.*?)'", match[0], re.S)
+           if match:
+                  phUrl = match[-1]
+                  printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  valTab.append(CDisplayListItem('Next', 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [phUrl], name, '', None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'eporner' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.eporner.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="categoriesbox" id=".*?"><a href="(.*?)" title="(.*?)"><img src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle, phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  phTitle = phTitle.replace(' movies', '')
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'eporner-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- HD ---",        "HD",        CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/hd/"], 'eporner-clips', '','/hd/'))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---", "Top Rated", CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/top_rated/"], 'eporner-clips', '','/top_rated/'))
+           valTab.insert(0,CDisplayListItem("--- Popular ---",   "Popular",   CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/weekly_top/"], 'eporner-clips', '','/weekly_top/'))
+           valTab.insert(0,CDisplayListItem("--- On Air ---",    "On Air",    CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/currently/"], 'eporner-clips', '','/currently/'))
+           valTab.insert(0,CDisplayListItem("--- New ---",       "New",       CDisplayListItem.TYPE_CATEGORY,["http://www.eporner.com/"], 'eporner-clips', '',''))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'eporner-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="mbtit".*?><a href="(.*?)" title="(.*?)".*?src="(.*?)".*?"mbtim">(.*?)</div>', data, re.S)
+           if phMovies:
+                 for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<center> <div class="numlist2">.*?</center>', data, re.S)
+           if match:
+              printDBG( 'Host listsItems page match: '+match[0] )
+              match = re.findall("<a href='(.*?)' title='(.*?)'", match[0], re.S)
+           if match:
+              for (phUrl, phTitle) in match:
+                  printDBG( 'Host listsItems page phUrl: '+phUrl )
+                  printDBG( 'Host listsItems page phTitle: '+phTitle )
+                  if phTitle == 'Next page':
+                     valTab.append(CDisplayListItem(phTitle, 'Page: '+phUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl], name, '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullpornhub' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornhub.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<div\sclass="category-wrapper">.*?<a\shref="(/video\?c=.*?)".*?<img\ssrc="(.*?)".*?alt="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'fullpornhub-clips', phImage, None)) 
+                  valTab.sort()
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- HD ---",         "HD",          CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?c=38"], 'fullpornhub-clips', 'http://cdn1a.static.pornhub.phncdn.com/images/categories/38.jpg',None))
+           valTab.insert(0,CDisplayListItem("--- Longest ---",    "Longest",     CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=lg"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---",  "Top Rated",   CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=tr"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Viewed ---","Most Viewed", CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=mv"], 'fullpornhub-clips', '',None))
+           valTab.insert(0,CDisplayListItem("--- Most Recent ---","Most Recent", CDisplayListItem.TYPE_CATEGORY,["http://www.pornhub.com/video?o=mr"], 'fullpornhub-clips', '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'fullpornhub-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div\sclass="wrap">.*?<a\shref="(.*?)".*?\stitle="(.*?)".*?data-mediumthumb="(.*?)".*?<var\sclass="duration">(.*?)</var>.*?<span\sclass="views"><var>(.*?)<.*?<var\sclass="added">(.*?)<', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime, phViews, phAdded) in phMovies:
+                  phUrl = self.MAIN_URL+phUrl
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  printDBG( 'Host listsItems phViews: '+phViews )
+                  printDBG( 'Host listsItems phAdded: '+phAdded )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] [ Views: '+phViews+'] [Added: '+phAdded+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<li class="page_next"><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0].replace('&amp;','&')], name, '', None))        
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.4tube.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           parse = re.search('All categories(.*?)</div></div>', data, re.S)
+           if not parse: return []
+           phCats = re.findall('<li><a href="(.*?)" title=".*?">(.*?)<span>', parse.group(1), re.S)
+           if phCats:
+              for (phUrl, phTitle) in phCats:
+                  phTitle = phTitle.strip()
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  phTitle = phTitle.title()
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl],'4tube-clips', '', None)) 
+           #valTab.sort()
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Channels ---","Channels",   CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/channels"]  ,         '4tube-channels', '',None))
+           valTab.insert(0,CDisplayListItem("--- Pornstars ---","Pornstars", CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/pornstars"],          '4tube-pornstars','',None))
+           valTab.insert(0,CDisplayListItem("--- Most viewed ---","Most viewed",     CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos?sort=views&time=month"],             '4tube-clips',    '',None))
+           valTab.insert(0,CDisplayListItem("--- Highest Rated ---","Highest Rated", CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos?sort=rating&time=month"],             '4tube-clips',    '',None))
+           valTab.insert(0,CDisplayListItem("--- Lastest ---","Lastest",     CDisplayListItem.TYPE_CATEGORY,["http://www.4tube.com/videos"],             '4tube-clips',    '',None))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-channels' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<a class="thumb-link" href="(.*?)" title="(.*?)".*?<i class="icon icon-video"></i>(.*?)<.*?<img data-original="(.*?)"',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phVid, phImage ) in phMovies:           
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phVid: '+phVid )
+                  valTab.append(CDisplayListItem(phTitle,'[Video: '+phVid+'] '+phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl], '4tube-clips', phImage, None)) 
+           match = re.findall('<ul class="pagination">.*?</a></li><li><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-pornstars' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<a class="thumb-link" href="(.*?)" title="(.*?)".*?<i class="icon icon-video"></i>(.*?)<.*?<img data-original="(.*?)"',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phVid, phImage ) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phVid: '+phVid )
+                  valTab.append(CDisplayListItem(phTitle,'[Video: '+phVid+'] '+phTitle,CDisplayListItem.TYPE_CATEGORY, [phUrl], '4tube-clips', phImage, None)) 
+           match = re.findall('<ul class="pagination">.*?</a></li><li><a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if '4tube-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('<div class="col thumb_video".*?href="(.*?)".*?title="(.*?)".*?<img data-master="(.*?)".*?class="duration-top">(.*?)<',data,re.S) 
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,phRuntime+' '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<a class="page " href="(.*?)"', data, re.S)
+           if match:
+              for (phPageUrl) in match: 
+                  printDBG( 'Host listsItems phPageUrl: '  +phPageUrl )
+                  valTab.append(CDisplayListItem('Page', phPageUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phPageUrl], name, '', None))                
+           match = re.findall('<a class="last" href="(.*?)" title="Last page">', data, re.S)
+           if match:
+              for (phPageUrl) in match: 
+                  printDBG( 'Host listsItems phPageUrl: '  +phPageUrl )
+                  valTab.append(CDisplayListItem('Last Page', phPageUrl, CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phPageUrl], name, '', None))                
+           match = re.findall('<link rel="next" href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hdporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.hdporn.net'
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('class="content">.*?href="(.*?)".*?src="(.*?)".*?alt="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phImage, phTitle) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'hdporn-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Top Rated ---","Top Rated",           CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+"/top-rated/"]  , 'hdporn-clips','',phUrl))
+           valTab.insert(0,CDisplayListItem("--- Most Popular ---","Most Popular",     CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+"/most-viewed/"], 'hdporn-clips','',phUrl))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'hdporn-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           printDBG( 'Host listsItems cat-url: '+catUrl )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phMovies = re.findall('class="content.*?<a href="(.*?)" title="(.*?)".*?src="(.*?)".*?TIME:  (.*?)</div>', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage, phRuntime) in phMovies:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phRuntime: '+phRuntime )
+                  valTab.append(CDisplayListItem(phTitle,'['+phRuntime+'] '+phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+phUrl, 1)], 0, phImage, None)) 
+           match = re.findall('<div id="pagination">.*?</div>', data, re.S)
+           if not match: return valTab
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           #printDBG( 'Host listsItems match: '+match[0])
+           match = re.findall("</a><a href='(.*?)'>", match[0], re.S)
+           if not match: return valTab
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           #printDBG( 'Host listsItems match: '+match[0])
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+catUrl+match[0]], 'hdporn-clips', '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://m.tube8.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'tube8-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'tube8-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<div class="scene_box">.+?background: url(.+?) no-repeat.+?style="margin: 0;".+?<a href="(.+?)" class="bold".+?[\t]*(.+?)<span style=.+?<p>(.+?)</p>.+?<div style="float: right;" class="bold"><span>(.+?)</span>.+?<div class="clear"></div>', re.DOTALL).findall(data)
+           if len(match) == 0:
+              match = re.compile('<div class="scene_box">.+?background: url(.+?) no-repeat.+?style="margin: 0;".+?<a href="(.+?)" class="bold".+?[\t]*(.+?)</a>.+?<p>(.+?)</p>.+?<div style="float: right;" class="bold"><span>(.+?)</span>.+?<div class="clear"></div>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2], '['+match[i][4]+'] ['+match[i][3]+'] '+match[i][2], CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'tube8-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'tube8-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'tube8-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://mobile.youporn.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'youporn-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'youporn-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile(   '<div class="video_box".+?background: url(.+?) no-repeat.+?<h2 class="h5"><a href="(.+?)">\n(.+?)          .+?<span>Length:.+?[\t]*(.+?)[\t]*</p>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2].replace('<br />',' '), '['+match[i][3]+'] '+match[i][2].replace('<br />',' '), CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'youporn-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'youporn-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'youporn-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://m.pornhub.com' 
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'pornhub-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'pornhub-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub-last' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<div class="video_box".+?background: url(.+?) no-repeat.+?<h2 class="h5"><a href="(.+?)" >(.+?)</a></h2>.+?<span>Length:.+?[\t]*(.+?)[\t]*</p>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][2].replace('<br />',' '), '['+match[i][3]+'] '+match[i][2].replace('<br />',' '), CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+match[i][1], 1)], 0, match[i][0][1:-1], None)) 
+           match = re.compile('<div class="next_nav">.+?<a href="(.+?)">NEXT</a>', re.DOTALL).findall(data)
+           if len(match)>0:
+              valTab.append(CDisplayListItem('Next', 'Next Page', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[0]], 'pornhub-last', '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornhub-categories' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           match = re.compile('<h2><a href="(.+?)">(.+?)</a></h2>', re.DOTALL).findall(data)
+           printDBG( 'Host listsItems len match: '+str(len(match)))
+           for i in range(len(match)):
+              for j in range(len(match[i])):
+                printDBG( 'Host listsItems match: '+str(i)+','+str(j)+': '+match[i][j])
+              valTab.append(CDisplayListItem(match[i][1], match[i][1], CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+match[i][0]], 'pornhub-last', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           valTab.append(CDisplayListItem(self.XXXversion+' - Local version',   'Local  XXXversion', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           valTab.append(CDisplayListItem(self.XXXremote+ ' - Remote version',  'Remote XXXversion', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           valTab.append(CDisplayListItem('ZMIANY W WERSJI',                    'ZMIANY W WERSJI',   CDisplayListItem.TYPE_CATEGORY, ['https://gitlab.com/iptv-host-xxx/iptv-host-xxx/commits/master.atom'], 'UPDATE-ZMIANY', '', None)) 
+           valTab.append(CDisplayListItem('Update Now',                         'Update Now',        CDisplayListItem.TYPE_CATEGORY, [''], 'UPDATE-NOW',    '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE-ZMIANY' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           try:
+              data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error' )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall("<entry>.*?<title>(.*?)</title>.*?<updated>(.*?)</updated>.*?<name>(.*?)</name>", data, re.S)
+           if phCats:
+              for (phTitle, phUpdated, phName ) in phCats:
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  printDBG( 'Host listsItems phUpdated: '+phUpdated )
+                  printDBG( 'Host listsItems phName: '+phName )
+                  valTab.append(CDisplayListItem(phUpdated+' ' +phName,phTitle,CDisplayListItem.TYPE_CATEGORY, [''],'', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'UPDATE-NOW' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           import os
+           _url = 'https://gitlab.com/iptv-host-xxx/iptv-host-xxx/repository/archive.tar.gz?ref=master'              
+           output = open('/tmp/iptv-host-xxx.tar.gz','wb')
+           query_data = { 'url': _url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              output.write(self.cm.getURLRequestData(query_data))
+              output.close()
+              os.system('sync')
+           except:
+              if os.path.exists('/tmp/iptv-host-xxx.tar.gz'):
+                 os.remove('/tmp/iptv-host-xxx.tar.gz')
+              printDBG( 'Błąd pobierania master.tar.gz' )
+              valTab.append(CDisplayListItem('ERROR - Blad pobierania: '+_url,   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab           
+           try: 
+              os.system('cd /tmp; tar -xzf iptv-host-xxx.tar.gz; sync')
+           except:
+              printDBG( 'Błąd rozpakowania iptv-host-xxx.tar.gz' )
+              os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+              os.system('rm -rf /tmp/iptv-host-xxx*')
+              valTab.append(CDisplayListItem('ERROR - Blad rozpakowania /tmp/iptv-host-xxx.tar.gz',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab
+           #if not os.path.exists('/tmp/iptv-host-xxx*/IPTVPlayer'):
+           #   printDBG( 'Niepoprawny format pliku /tmp/iptv-host-xxx.tar.gz' )
+           #   os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+           #   os.system('rm -rf /tmp/iptv-host-xxx*')
+           #   valTab.append(CDisplayListItem('ERROR - Niepoprawny format pliku /tmp/iptv-host-xxx.tar.gz',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           #   return valTab           
+           try:
+              os.system('cp -rf /tmp/iptv-host-xxx*/IPTVPlayer/* /usr/lib/enigma2/python/Plugins/Extensions/IPTVPlayer/')
+              os.system('sync')
+           except:
+              printDBG( 'blad kopiowania' )
+              os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+              os.system('rm -rf /tmp/iptv-host-xxx*')
+              valTab.append(CDisplayListItem('ERROR - blad kopiowania',   'ERROR', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+              return valTab
+               
+           valTab.append(CDisplayListItem('Update End. Please manual restart enigma2',   'Restart', CDisplayListItem.TYPE_CATEGORY, [''], '', '', None)) 
+           os.system('rm -f /tmp/iptv-host-xxx.tar.gz')
+           os.system('rm -rf /tmp/iptv-host-xxx*')
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'pornusy' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornway.com' 
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'pornusy.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': 'http://showup.tv/site/accept_rules/yes?ref=http://showup.tv/', 'use_host': False, 'use_cookie': True, 'save_cookie': True, 'load_cookie': False, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host listsItems query error cookie' )
+              return valTab
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return valTab
+           phMovies = re.findall('<li class="video".*?<a href="(.*?)" title="(.*?)".*?data-src="(.*?)"', data, re.S)
+           if phMovies:
+              for (phUrl, phTitle, phImage ) in phMovies:
+                  printDBG( 'Host listsItems phImage: '+phImage )
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle,phTitle,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 1)], 0, phImage, None)) 
+           match = re.findall("link rel='next' href='(.*?)'", data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', 'Page: '+match[0], CDisplayListItem.TYPE_CATEGORY, [match[0]], name, '', None))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+           valTab.append(CDisplayListItem('LAST',       'Last',       CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL],                    'youporn-last', '', None)) 
+           valTab.append(CDisplayListItem('CATEGORIES', 'Categories', CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+'/category/browse'], 'youporn-categories', '', None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'beeg' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://beeg.com/api/v1/index/main/0/mobile' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           self.tags = 'popular'
+           self.page = 1
+           parse = re.search('"%s":\[(.*?)\]' % self.tags, data, re.S)
+           if parse:
+              phCats = re.findall('"(.*?)"', parse.group(1), re.S)
+              if phCats:
+                 for phTitle in phCats:
+                     phUrl = 'http://beeg.com/api/v1/index/tag/$PAGE$/mobile?tag=%s' % phTitle
+                     phUrl = phUrl.replace('$PAGE$', '%s' % str(self.page-1))
+                     printDBG( 'Host listsItems phUrl: '  +phUrl )
+                     printDBG( 'Host listsItems phTitle: '+phTitle )
+                     valTab.append(CDisplayListItem(phTitle,phUrl,CDisplayListItem.TYPE_CATEGORY, [phUrl],'beeg-clips', '', None)) 
+           valTab.sort(key=lambda poz: poz.name)
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'beeg-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phVideos = re.findall('\{"title":"(.*?)","id":"(.*?)",(.*?),"ps_name"', data, re.S)
+           if phVideos:
+              for (phTitle, phVideoId, phUrl) in phVideos:
+                 bestUrl = re.findall(':"(.*?)"', phUrl)
+                 if bestUrl:
+                    phUrl = 'http:%s' % bestUrl[-1]
+                 phUrl = phUrl.replace('{DATA_MARKERS}','data=pc.DE')
+                 phImage = 'http://img.beeg.com/236x177/%s.jpg' % phVideoId
+                 printDBG( 'Host listsItems phUrl: '  +phUrl )
+                 printDBG( 'Host listsItems phTitle: '+phTitle )
+                 printDBG( 'Host listsItems phImage: '+phImage )
+                 valTab.append(CDisplayListItem(phTitle,phUrl,CDisplayListItem.TYPE_VIDEO, [CUrlItem('', phUrl, 0)], 0, phImage, None)) 
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        if 'pornrabbit' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           self.MAIN_URL = 'http://www.pornrabbit.com' 
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url:'+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           phCats = re.findall('<div class="cat">.*?href="(.*?)".*?<h2>(.*?)<small>(.*?)<.*?img src="(.*?)"', data, re.S)
+           if phCats:
+              for (phUrl, phTitle,phTitle2,phImage) in phCats:
+                  printDBG( 'Host listsItems phUrl: '  +phUrl )
+                  printDBG( 'Host listsItems phTitle: '+phTitle )
+                  valTab.append(CDisplayListItem(phTitle+phTitle2,phUrl,CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+phUrl],'pornrabbit-clips', phImage, phUrl)) 
+           valTab.sort(key=lambda poz: poz.name)
+           valTab.insert(0,CDisplayListItem("--- Most Recent ---", "Most Recent", CDisplayListItem.TYPE_CATEGORY,[self.MAIN_URL+'/videos/'], 'pornrabbit-clips', '','/videos/'))
+           printDBG( 'Host listsItems end' )
+           return valTab
+        if 'pornrabbit-clips' == name:
+           printDBG( 'Host listsItems begin name='+name )
+           catUrl = self.currList[Index].possibleTypesOfSearch
+           query_data = { 'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True }
+           try:
+              data = self.cm.getURLRequestData(query_data)
+           except:
+              printDBG( 'Host listsItems query error' )
+              printDBG( 'Host listsItems query error url: '+url )
+              return valTab
+           #printDBG( 'Host listsItems data: '+data )
+           x = 0
+           Movies = re.findall('class="video">.*?<a href="(.*?)" title="(.*?)".*?<img.*?src="(.*?)".*?views: <b>(.*?)</b>.*?runtime: <b>(.*?)</b>', data, re.S)
+           if Movies:
+              for (Url, Title, Image, Views, Runtime) in Movies:
+                  valTab.append(CDisplayListItem(decodeHtml(Title),'['+Runtime+'] ['+Views+' views]',CDisplayListItem.TYPE_VIDEO, [CUrlItem('', self.MAIN_URL+Url, 1)], 0, Image, None)) 
+                  x = x + 1
+           match = re.findall(r'&nbsp;<a href="(.*?)"', data, re.S)
+           if match:
+              valTab.append(CDisplayListItem('Next', self.MAIN_URL+catUrl+match[0].replace(r'../',''), CDisplayListItem.TYPE_CATEGORY, [self.MAIN_URL+catUrl+match[0].replace(r'../','')], name, '', catUrl))                
+           printDBG( 'Host listsItems end' )
+           return valTab
+
+        return valTab
+
+    def getParser(self, url):
+        printDBG( 'Host getParser begin' )
+        printDBG( 'Host getParser mainurl: '+self.MAIN_URL )
+        printDBG( 'Host getParser url    : '+url )
+        if self.MAIN_URL == 'http://www.pornrabbit.com':    return self.MAIN_URL
+        if self.MAIN_URL == 'http://beeg.com':              return self.MAIN_URL
+        if url.startswith('http://www.pornway.com'):         return 'http://www.pornway.com'
+        if url.startswith('http://www.tube8.com/embed/'):   return 'http://www.tube8.com/embed/'
+        if url.startswith('http://www.tube8.com'):          return 'http://www.tube8.com'
+        if self.MAIN_URL == 'http://www.tube8.com':         return self.MAIN_URL
+        if url.startswith('http://embed.redtube.com'):      return 'http://embed.redtube.com'
+        if url.startswith('http://www.redtube.com'):        return 'http://www.redtube.com'
+        if self.MAIN_URL == 'http://www.redtube.com':       return self.MAIN_URL
+        if url.startswith('http://www.youporn.com/embed/'): return 'http://www.youporn.com/embed/'
+        if url.startswith('http://www.youporn.com'):        return 'http://www.youporn.com'
+        if self.MAIN_URL == 'http://www.youporn.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://showup.tv':             return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.xnxx.com':          return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.xvideos.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://hentaigasm.com':        return self.MAIN_URL
+        if self.MAIN_URL == 'http://xhamster.com':          return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.eporner.com':       return self.MAIN_URL
+        if url.startswith('http://www.pornhub.com/embed/'): return 'http://www.pornhub.com/embed/'
+        if url.startswith('http://www.pornhub.com'):        return 'http://www.pornhub.com'
+        if self.MAIN_URL == 'http://www.pornhub.com':       return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.4tube.com':         return self.MAIN_URL
+        if self.MAIN_URL == 'http://www.hdporn.net':        return self.MAIN_URL
+        if self.MAIN_URL == 'http://m.tube8.com':           return self.MAIN_URL
+        if self.MAIN_URL == 'http://mobile.youporn.com':    return self.MAIN_URL
+        if self.MAIN_URL == 'http://m.pornhub.com':         return self.MAIN_URL
+        if url.startswith('http://www.xnxx.com'):           return 'http://www.xnxx.com'
+        if url.startswith('http://www.xvideos.com'):        return 'http://www.xvideos.com'
+        if url.startswith('http://hentaigasm.com'):         return 'http://hentaigasm.com'
+        if url.startswith('http://xhamster.com'):          return 'http://xhamster.com'
+        if url.startswith('http://www.eporner.com'):       return 'http://www.eporner.com'
+        if url.startswith('http://www.4tube.com'):         return 'http://www.4tube.com'
+        if url.startswith('http://www.hdporn.net'):        return 'http://www.hdporn.net'
+        if url.startswith('http://m.tube8.com'):           return 'http://m.tube8.com'
+        if url.startswith('http://mobile.youporn.com'):    return 'http://mobile.youporn.com'
+        if url.startswith('http://m.pornhub.com'):         return 'http://m.pornhub.com'
+        return ''
+
+    def getResolvedURL(self, url):
+        printDBG( 'Host getResolvedURL begin' )
+        printDBG( 'Host getResolvedURL url: '+url )
+        videoUrl = ''
+        parser = self.getParser(url)
+        printDBG( 'Host getResolvedURL parser: '+parser )
+        if parser == '': return ''
+
+        if parser == 'http://www.pornway.com':
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'pornusy.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return ''
+           #printDBG( 'Host getResolvedURL data: '+data )
+           parse = re.search('<iframe src="(.*?)"', data, re.S)
+           if parse:
+              if parse.group(1).startswith('http://www.pornway.com'):
+                 printDBG( 'Host getResolvedURL pornway.com: zapetlony parser: '+parse.group(1) )
+                 return ''
+              return self.getResolvedURL(parse.group(1))
+           else: return ''
+
+        if parser == 'http://showup.tv':
+           COOKIEFILE = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/cache/') + 'showup.cookie'
+           try: data = self.cm.getURLRequestData({ 'url': url, 'use_host': False, 'use_cookie': True, 'save_cookie': False, 'load_cookie': True, 'cookiefile': COOKIEFILE, 'use_post': False, 'return_data': True })
+           except:
+              printDBG( 'Host getResolvedURL query error' )
+              printDBG( 'Host getResolvedURL query error url: '+url )
+              return ''
+           #printDBG( 'Host getResolvedURL data: '+data )
+           parse = re.search("var streamID = '(.*?)'.*?var srvE = '(.*?)'", data, re.S)
+           if parse:
+              printDBG( 'Host gr1: '+ parse.group(1))
+              printDBG( 'Host gr2: '+ parse.group(2))
+              videoUrl = parse.group(2)+' playpath='+parse.group(1)+' swfUrl=http://showup.tv/flash/suStreamer.swf?cache=20&autoReconnect=1&id='+parse.group(1)+'&swfObjectID=video&sender=false&token=&address='+parse.group(2)[7:-9]+'@liveedge live=1 pageUrl='+url+ ' conn=S:OK --live'
+              #videoUrl = parse.group(2)+' playpath='+parse.group(1)+' swfUrl=http://showup.tv/flash/suStreamer.swf?cache=10&id='+parse.group(1)+'&swfObjectID=video&sender=false&token=&address='+parse.group(2)[7:-9]+'@liveedge live=1 pageUrl='+url
+              printDBG( 'Host videoUrl: '+ videoUrl)
+              return videoUrl
+           return ''
+        
+        if parser == 'http://www.tube8.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r""))
+        
+        if parser == 'http://www.youporn.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r"watch/"))
+
+        if parser == 'http://www.pornhub.com/embed/':
+           return self.getResolvedURL(url.replace(r"embed/",r"view_video.php?viewkey="))
+
+        query_data = {'url': url, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True}
+        try:
+           data = self.cm.getURLRequestData(query_data)
+           #printDBG( 'Host getResolvedURL data: '+data )
+        except:
+           printDBG( 'Host getResolvedURL query error' )
+           return videoUrl
+
+        if parser == 'http://www.pornrabbit.com':
+           videoPage = re.findall("file: '(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://beeg.com':
+           videoPage = re.findall("'file': '(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://www.tube8.com':
+           match = re.findall('"quality_\d+p":"(http.*?)"', data)
+           if not match: match = re.compile('"quality_720p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_480p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_240p":"([^"]+)"').findall(data)
+           if not match: return ''
+           fetchurl = urllib2.unquote(match[0])
+           fetchurl = fetchurl.replace(r"\/",r"/")
+           printDBG( 'Host getResolvedURL fetchurl: '+fetchurl )
+           return fetchurl 
+
+        if parser == 'http://www.xnxx.com':
+           videoUrl = re.search('flv_url=(.*?)&', data, re.S)
+           if videoUrl: return decodeUrl(videoUrl.group(1))
+           return ''
+
+        if parser == 'http://www.xvideos.com':
+           videoUrl = re.search('flv_url=(.*?)&', data, re.S)
+           if videoUrl: return decodeUrl(videoUrl.group(1))
+           return ''
+
+        if parser == 'http://hentaigasm.com':
+           videoUrl = re.search('<div id="player_1111"></div>.*?file: "(.*?)"', data, re.S)
+           if videoUrl: return videoUrl.group(1)
+           return ''
+
+        if parser == 'http://www.youporn.com':
+           match = re.findall(r'encryptedQuality720URL\s=\s\'([a-zA-Z0-9+/]+={0,2})\',', data)
+           if match:
+              fetchurl = urllib2.unquote(match[0])
+              printDBG( 'Host getResolvedURL fetchurl: '+fetchurl )
+              match = re.compile("video_title = '(.*?)'").findall(data)
+              if match:
+                 title = urllib.unquote_plus(match[0])
+                 #title = '%s_720p' % title
+                 printDBG( 'Host getResolvedURL title: '+title )
+                 printDBG( 'Host getResolvedURL decrypt begin ' )
+                 phStream = decrypt(fetchurl, title, 32)
+                 if phStream: 
+                    printDBG( 'Host getResolvedURL decrypted url: '+phStream )
+                    return phStream
+           videoPage = re.findall("\d\d\d:\s'(http.*?)'", data, re.S)
+           if videoPage:
+              videos = videoPage[-1] 
+              videos = urllib.unquote(videos)
+              videos = videos.replace('&amp;','&')
+              printDBG( 'Host getResolvedURL normal url: '+videos )
+              return videos
+           return ''
+
+        if parser == 'http://embed.redtube.com':
+           videoPage = re.findall("<source src='(.*?)'", data, re.S)
+           if videoPage:
+              return videoPage[0]
+           return ''
+
+        if parser == 'http://www.redtube.com':
+           videoPage = re.findall('<source\ssrc="(.*?)"\stype="video/mp4">', data, re.S)
+           if videoPage:
+              videos = '%s' % (videoPage[0])
+              videos = urllib.unquote(videos)
+              videos = videos.replace(r"\/",r"/")
+              return videos
+           return ''
+
+        if parser == 'http://xhamster.com':
+           xhFile = re.findall('"file":"(.*?)"', data)
+           if xhFile: return xhFile[0].replace(r"\/",r"/")
+           else: return ''
+        
+        if parser == 'http://www.eporner.com':
+           videoPage = re.findall("mediaspace --> <script>.*?getScript.*?'(.*?)'", data, re.S)
+           if not videoPage: return ''
+           xml = parser+videoPage[0]
+           printDBG( 'Host getResolvedURL xml: '+xml )
+           try:    data = self.cm.getURLRequestData({'url': xml, 'use_host': False, 'use_cookie': False, 'use_post': False, 'return_data': True})
+           except: 
+                   printDBG( 'Host getResolvedURL query error xml' )
+                   return videoUrl
+           videoPage = re.findall('file: ?"(.*?)"', data, re.S)
+           if videoPage: return videoPage[0]
+           return ''
+
+        if parser == 'http://www.pornhub.com/embed/':
+           match = re.findall("container.*?src.*?'(.*?)'", data, re.S)
+           if match: return match[0]
+           return ''
+        
+        if parser == 'http://www.pornhub.com':
+           match = re.compile('"video_url":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_720p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_480p":"([^"]+)"').findall(data)
+           if not match: match = re.compile('"quality_240p":"([^"]+)"').findall(data)
+           if not match: match = re.compile("quality_720p = '(.*?)'").findall(data)
+           if not match: match = re.compile("quality_480p = '(.*?)'").findall(data)
+           if not match: match = re.compile("quality_240p = '(.*?)'").findall(data)
+           if not match: 
+                         printDBG( 'Host getResolvedURL not match' )  
+                         return ''
+           return match[0]   
+
+        if parser == 'http://www.4tube.com':
+           #printDBG( 'Host getResolvedURL data: '+data )
+           videoID = re.findall('data-id="(\d+)".*?data-quality="(\d+)"', data, re.S)
+           if videoID:
+              res = ''
+              for x in videoID:
+                  res += x[1] + "+"
+              res.strip('+')
+              posturl = "%s/%s/desktop/%s" % (parser.replace('www','tkn'), videoID[-1][0], res)
+              printDBG( 'Host getResolvedURL posturl: '+posturl )
+              try:
+                 data = self.cm.getURLRequestData({'url': posturl, 'header': {'Origin':'http://www.4tube.com'},'use_host': False, 'use_cookie': False, 'use_post': True, 'return_data': True},{})
+              except:
+                 printDBG( 'Host getResolvedURL query error posturl' )
+                 return ''
+              #printDBG( 'Host getResolvedURL posturl data: '+data )
+              videoUrl = re.findall('token":"(.*?)"', data, re.S)
+              if videoUrl: return videoUrl[-1]                 
+              else: return ''
+           else: return ''
+        
+        if parser == 'http://www.hdporn.net':
+           match = re.findall('source src="(.*?)"', data, re.S)
+           if match: return match[0]
+           else: return ''
+
+        if parser == 'http://m.tube8.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        if parser == 'http://mobile.youporn.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        if parser == 'http://m.pornhub.com':
+           match = re.compile('<div class="play_video.+?<a href="(.+?)"', re.DOTALL).findall(data)
+           return match[0]
+
+        printDBG( 'Host getResolvedURL end' )
+        return videoUrl
+
+
+############################################
+# functions for host
+############################################
+def decodeUrl(text):
+    text = text.replace('%20',' ')
+    text = text.replace('%21','!')
+    text = text.replace('%22','"')
+    text = text.replace('%23','&')
+    text = text.replace('%24','$')
+    text = text.replace('%25','%')
+    text = text.replace('%26','&')
+    text = text.replace('%2F','/')
+    text = text.replace('%3A',':')
+    text = text.replace('%3B',';')
+    text = text.replace('%3D','=')
+    text = text.replace('%3F','?')
+    text = text.replace('%40','@')
+    return text
+
+def decodeHtml(text):
+    text = text.replace('&auml;','ä')
+    text = text.replace('\u00e4','ä')
+    text = text.replace('&#228;','ä')
+ 
+    text = text.replace('&Auml;','Ä')
+    text = text.replace('\u00c4','Ä')
+    text = text.replace('&#196;','Ä')
+        
+    text = text.replace('&ouml;','ö')
+    text = text.replace('\u00f6','ö')
+    text = text.replace('&#246;','ö')
+        
+    text = text.replace('&ouml;','Ö')
+    text = text.replace('\u00d6','Ö')
+    text = text.replace('&#214;','Ö')
+        
+    text = text.replace('&uuml;','ü')
+    text = text.replace('\u00fc','ü')
+    text = text.replace('&#252;','ü')
+        
+    text = text.replace('&Uuml;','Ü')
+    text = text.replace('\u00dc','Ü')
+    text = text.replace('&#220;','Ü')
+        
+    text = text.replace('&szlig;','ß')
+    text = text.replace('\u00df','ß')
+    text = text.replace('&#223;','ß')
+        
+    text = text.replace('&amp;','&')
+    text = text.replace('&quot;','\"')
+    
+    text = text.replace('&amp;','&')
+    text = text.replace('&quot;','\"')
+    text = text.replace('&gt;','>')
+    text = text.replace('&apos;',"'")
+    text = text.replace('&acute;','\'')
+    text = text.replace('&ndash;','-')
+    text = text.replace('&bdquo;','"')
+    text = text.replace('&rdquo;','"')
+    text = text.replace('&ldquo;','"')
+    text = text.replace('&lsquo;','\'')
+    text = text.replace('&rsquo;','\'')
+    text = text.replace('&#034;','\'')
+    text = text.replace('&#038;','&')
+    text = text.replace('&#039;','\'')
+    text = text.replace('&#160;',' ')
+    text = text.replace('\u00a0',' ')
+    text = text.replace('&#174;','')
+    text = text.replace('&#225;','a')
+    text = text.replace('&#233;','e')
+    text = text.replace('&#243;','o')
+    text = text.replace('&#8211;',"-")
+    text = text.replace('\u2013',"-")
+    text = text.replace('&#8216;',"'")
+    text = text.replace('&#8217;',"'")
+    text = text.replace('&#8220;',"'")
+    text = text.replace('&#8221;','"')
+    text = text.replace('&#8222;',',')
+    
+    text = text.replace('&#8230;','...')
+    text = text.replace('\u2026','...')
+    return text
+
+############################################
+# functions for fullpornhub
+############################################
+def decrypt(ciphertext, password, nBits):
+    printDBG( 'decrypt begin ' )
+    blockSize = 16
+    if not nBits in (128, 192, 256): return ""
+    ciphertext = base64.b64decode(ciphertext)
+#    password = password.encode("utf-8")
+
+    nBytes = nBits//8
+    pwBytes = [0] * nBytes
+    for i in range(nBytes): pwBytes[i] = 0 if i>=len(password) else ord(password[i])
+    key = Cipher(pwBytes, KeyExpansion(pwBytes))
+    key += key[:nBytes-16]
+
+    counterBlock = [0] * blockSize
+    ctrTxt = ciphertext[:8]
+    for i in range(8): counterBlock[i] = ord(ctrTxt[i])
+
+    keySchedule = KeyExpansion(key)
+
+    nBlocks = int( math.ceil( float(len(ciphertext)-8) / float(blockSize) ) )
+    ct = [0] * nBlocks
+    for b in range(nBlocks):
+        ct[b] = ciphertext[8+b*blockSize : 8+b*blockSize+blockSize]
+    ciphertext = ct
+
+    plaintxt = [0] * len(ciphertext)
+
+    for b in range(nBlocks):
+        for c in range(4): counterBlock[15-c] = urs(b, c*8) & 0xff
+        for c in range(4): counterBlock[15-c-4] = urs( int( float(b+1)/0x100000000-1 ), c*8) & 0xff
+
+        cipherCntr = Cipher(counterBlock, keySchedule)
+
+        plaintxtByte = [0] * len(ciphertext[b])
+        for i in range(len(ciphertext[b])):
+            plaintxtByte[i] = cipherCntr[i] ^ ord(ciphertext[b][i])
+            plaintxtByte[i] = chr(plaintxtByte[i])
+        plaintxt[b] = "".join(plaintxtByte)
+
+    plaintext = "".join(plaintxt)
+ #   plaintext = plaintext.decode("utf-8")
+    return plaintext
+
+Sbox = [
+    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
+    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
+    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
+    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
+    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
+    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
+    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
+    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
+    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
+    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
+    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
+    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
+    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
+    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
+    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
+    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
+]
+
+Rcon = [
+    [0x00, 0x00, 0x00, 0x00],
+    [0x01, 0x00, 0x00, 0x00],
+    [0x02, 0x00, 0x00, 0x00],
+    [0x04, 0x00, 0x00, 0x00],
+    [0x08, 0x00, 0x00, 0x00],
+    [0x10, 0x00, 0x00, 0x00],
+    [0x20, 0x00, 0x00, 0x00],
+    [0x40, 0x00, 0x00, 0x00],
+    [0x80, 0x00, 0x00, 0x00],
+    [0x1b, 0x00, 0x00, 0x00],
+    [0x36, 0x00, 0x00, 0x00]
+]
+
+def Cipher(input, w):
+    printDBG( 'cipher begin ' )
+    Nb = 4
+    Nr = len(w)/Nb - 1
+
+    state = [ [0] * Nb, [0] * Nb, [0] * Nb, [0] * Nb ]
+    for i in range(0, 4*Nb): state[i%4][i//4] = input[i]
+
+    state = AddRoundKey(state, w, 0, Nb)
+
+    for round in range(1, Nr):
+        state = SubBytes(state, Nb)
+        state = ShiftRows(state, Nb)
+        state = MixColumns(state, Nb)
+        state = AddRoundKey(state, w, round, Nb)
+
+    state = SubBytes(state, Nb)
+    state = ShiftRows(state, Nb)
+    state = AddRoundKey(state, w, Nr, Nb)
+
+    output = [0] * 4*Nb
+    for i in range(4*Nb): output[i] = state[i%4][i//4]
+    return output
+
+def SubBytes(s, Nb):
+    printDBG( 'subbytes begin ' )
+    for r in range(4):
+        for c in range(Nb):
+            s[r][c] = Sbox[s[r][c]]
+    return s
+
+def ShiftRows(s, Nb):
+    printDBG( 'shiftrows begin ' )
+    t = [0] * 4
+    for r in range (1,4):
+        for c in range(4): t[c] = s[r][(c+r)%Nb]
+        for c in range(4): s[r][c] = t[c]
+    return s
+
+def MixColumns(s, Nb):
+    printDBG( 'mixcolumns begin ' )
+    for c in range(4):
+        a = [0] * 4
+        b = [0] * 4
+        for i in range(4):
+            a[i] = s[i][c]
+            b[i] = s[i][c]<<1 ^ 0x011b if s[i][c]&0x80 else s[i][c]<<1
+        s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]
+        s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]
+        s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]
+        s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]
+    return s
+
+def AddRoundKey(state, w, rnd, Nb):
+    printDBG( 'addroundkey begin ' )
+    for r in range(4):
+        for c in range(Nb):
+            state[r][c] ^= w[rnd*4+c][r]
+    return state
+
+def KeyExpansion(key):
+    printDBG( 'keyexpansion begin ' )
+    Nb = 4
+    Nk = len(key)/4
+    Nr = Nk + 6
+
+    w = [0] * Nb*(Nr+1)
+    temp = [0] * 4
+
+    for i in range(Nk):
+        r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]]
+        w[i] = r
+
+    for i in range(Nk, Nb*(Nr+1)):
+        w[i] = [0] * 4
+        for t in range(4): temp[t] = w[i-1][t]
+        if i%Nk == 0:
+            temp = SubWord(RotWord(temp))
+            for t in range(4): temp[t] ^= Rcon[i/Nk][t]
+        elif Nk>6 and i%Nk == 4:
+            temp = SubWord(temp)
+        for t in range(4): w[i][t] = w[i-Nk][t] ^ temp[t]
+    return w
+
+def SubWord(w):
+    printDBG( 'subword begin ' )
+    for i in range(4): w[i] = Sbox[w[i]]
+    return w
+
+def RotWord(w):
+    printDBG( 'rotword begin ' )
+    tmp = w[0]
+    for i in range(3): w[i] = w[i+1]
+    w[3] = tmp
+    return w
+
+def encrypt(plaintext, password, nBits):
+    printDBG( 'encrypt begin ' )
+    blockSize = 16
+    if not nBits in (128, 192, 256): return ""
+#    plaintext = plaintext.encode("utf-8")
+#    password  = password.encode("utf-8")
+    nBytes = nBits//8
+    pwBytes = [0] * nBytes
+    for i in range(nBytes): pwBytes[i] = 0 if i>=len(password) else ord(password[i])
+    key = Cipher(pwBytes, KeyExpansion(pwBytes))
+    key += key[:nBytes-16]
+
+    counterBlock = [0] * blockSize
+    now = datetime.datetime.now()
+    nonce = time.mktime( now.timetuple() )*1000 + now.microsecond//1000
+    nonceSec = int(nonce // 1000)
+    nonceMs  = int(nonce % 1000)
+
+    for i in range(4): counterBlock[i] = urs(nonceSec, i*8) & 0xff
+    for i in range(4): counterBlock[i+4] = nonceMs & 0xff
+
+    ctrTxt = ""
+    for i in range(8): ctrTxt += chr(counterBlock[i])
+
+    keySchedule = KeyExpansion(key)
+
+    blockCount = int(math.ceil(float(len(plaintext))/float(blockSize)))
+    ciphertxt = [0] * blockCount
+
+    for b in range(blockCount):
+        for c in range(4): counterBlock[15-c] = urs(b, c*8) & 0xff
+        for c in range(4): counterBlock[15-c-4] = urs(b/0x100000000, c*8)
+
+        cipherCntr = Cipher(counterBlock, keySchedule)
+
+        blockLength = blockSize if b<blockCount-1 else (len(plaintext)-1)%blockSize+1
+        cipherChar = [0] * blockLength
+
+        for i in range(blockLength):
+            cipherChar[i] = cipherCntr[i] ^ ord(plaintext[b*blockSize+i])
+            cipherChar[i] = chr( cipherChar[i] )
+        ciphertxt[b] = ''.join(cipherChar)
+
+    ciphertext = ctrTxt + ''.join(ciphertxt)
+    ciphertext = base64.b64encode(ciphertext)
+
+    return ciphertext
+
+def urs(a, b):
+    printDBG( 'urs begin ' )
+    a &= 0xffffffff
+    b &= 0x1f
+    if a&0x80000000 and b>0:
+        a = (a>>1) & 0x7fffffff
+        a = a >> (b-1)
+    else:
+        a = (a >> b)
+    return a 
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/logos/XXXlogo.png ./IPTVPlayer/icons/logos/XXXlogo.png
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/logos/XXXlogo.png	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/icons/logos/XXXlogo.png	2015-11-24 20:13:20.673688999 +0100
@@ -0,0 +1,22 @@
+PNG
+
+   IHDR   x   (   4   PLTE9ô~DDh"ۍĢ|fd
+ЬN̩EGfԴddy1<÷T\d䢔㷴"$̄lRL
+d'h
+vt˰uxDLSRj޽ŨX24׾L
+:=41	v|iw﷾Ĭ^hNبˉȒYYᾹz֙ttyEMCA¾鰪̛{L
+Ļ\",٣fl]\y䨴w	>LgT\㹼ܠ8@hn+/GTvt秧y32dlbdSRWd9>Z\ϋ>4t,-؊lLTɛb\#!|tw&ԱܞKL{t\^V\~y;4mqا屴T䆄32|9<t^l̴ˎ,ҽu#,䊄ʼ̪β\$׊>B^\؞JMJDnoZT>4ՑcaιTT
+vĪux܊Փ}|~./JLOԪyN\ضJDy"eĶѾjd̞ʗrt̷[\ܚ<üģΒ   tRNS Y   	pHYs       IDATx͘|xcӃzm,b$X9]HL6a6{VA+*VA?mEb⏢5JcojǾs7ޛ7;3;s9$9!`˒$~'jǖKPj0YS{6_d&jNbqaAlTˠj>eN3e'3-J2^g֚N6^3q*s99@qFYSLs&̣#.L0vh쵻2vع4s262-	 rVݠqsDm'􈹝6vZa~E#nڍ`T@SUD3F:kObNHY{cQp+`d[0X)ۉxb: -%j`Mxׁ*B[0JCb@яkݩS~r-.n׿VyW\|f01۔i,Z?Z0׿tLqKb]C1v/^2V<"EvzD9/;gΐ`r@JvM5lf,ްs.8Za8#箓Kr&4_/.;BL#bNls2	;4 TxFdbҢ˾LZ^L\BN.5ЇUA	4 ̓BAYTdUtD)X^N&#Sed\3 E36}JQ^zU,Y@`r8uI!yaD.owK~nI>Ie-fħW,(se0-P&JEەLZP@J2/u:/|0ϒxI*+䷒L`"1N@7ejVH\7`Qh),`K 3[^ܷiI'"A`Bo"qB`bIS~EEr?($Fb,CGJI^q]*)btɖeͦ`%mdX#A6)d)*FMBy,JlwE_t,rwW
+/|W\cĨ BbAyaKޒ$D?>幥"WI*E2xu!}tۮe}mTNwwwuH/@)M
+nEESuNbA03xpOA@Y,2Mr81*)iYҪ^4C{]{_ws)$q~h.S|۝,QOˉRC[WM
+t\1 ̐8@*1\-)vzl~2WlVda>sƄܢvo 4}	-s,JzCf|&ip}wߡ
+ì9Dl\b߷͔H91tk&A υL&L>;S X´]5&p8RZyKckӴqij`m'HM}JڡiQ+aR/V:43B	s\8`@{TըB o'G
+N/.ey媪+vlNjCX:R1|29[!vp˂9">)#U(L0pذZoZx&Bk	wkVzê]RڜWOv`.)6BtbvKӴ v`v2i~C\}D	`|<^0޿Xh *Ow7乗h 4-?++4-TWXF/WAV=ld# Ϗ=BtpyB{P5v GϽ|qP]ZV6:hԥa:Ov4s5m9r1ծ(y+'
+gJ!c| ,,䆟,/ Q@`={)Y,Fcuns_($OHc.Vr]Mh 粐1=*Ig?0B*\7%V1#%<~mU儨'=Ax;\au8#	)m4#LDƹ,fE7
+px+/1T8'D;>0c+<sZ^'<M|	aKQ&5K!xkGh<"xS;r=ɇ=eꞚ͔ϲKlFy9VLO[&y:)!GT
+Ș(d~ewOֳ0+d</#x{!㙰
+7mZa=Vx/<̈́Z2.a笀2{rE-M-lfB/AdGE8@=)]_M~zȲVenť[W<<Zޕ}޶Ѽ6zt:ފãc=?b+{8Y[']B<Q
+."K~	VK*WXzcAlUp~^wX샿`qv8I/\{i+XXz6W`3n #{v`P
+fMtM^~M=AvDmp7J[Q+NnY>(*	V{K1uE$y5n%RE_%'"~zLŪJǸE!. VV2=mk)<h($En#
+DXKJȈ-	 Z~
+WBl@ĄAG"?[-JH"XJH<0۔x4S4lϜ9sÆ3x[>]Y`;^>\ә"QJr>Oy?H)ːRUFd;    IENDB`
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX100.png ./IPTVPlayer/icons/PlayerSelector/XXX100.png
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX100.png	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/icons/PlayerSelector/XXX100.png	2015-11-24 20:13:20.673688999 +0100
@@ -0,0 +1,20 @@
+PNG
+
+   IHDR   d   d   G<ef   PLTE<><¼DĂtĲdB|$"$,F\^\<
+*4f|J\,MNLĶĤv"Ԝ:L$4*D424$",b
+̘$ܪVVTftBD|Rd",qnlԶԴ,*,4ܽ<*dr,T܎
+4V2ֲHFDͶvT:d
+ԌoJljl\4<jTV\$L(&,\^d4dN\ܱ,
+<:<$,
+<LԊԄ$Nz|LNTĺ~*446<<*\Z|JTn^:ܬnT:t|vtD2d<&\PZ~,|N\24Ѳ<DBD̂lFf|FLtrt4.4n4"\DFLL6l,4dZ\4<.ԬL2l$$l<D|lF|(&$ļz,
+764fڮԜ2.,D.d̺"ZZ\dbd4$$<}~|TRTLJLJ줦&jZ6zR4
+윞rb>̆4D><Dd^\,y   tRNS 
+<   	pHYs       ~IDATxU9NDk&	#Յz=ᘺ*O]7jjRŰ% ջ%zl<veJcp {;sgyxoޞ\kəg#s6Qz3@fIvozNf3%x2/rY3Ռ0CN:\,$gFbΌ]8Ez6
+O%j	qpIiހCJT=	͖1AQ>KB!!s^2KBR>ca_vl;]n/ƼGh3kt;up:Lm1Y`f.@W0cAL0CD.rm3 aszWR6dlTc暶I1e:Dyp|z3Y6M]7xX&LsJozʭn@f.g&\fU}(2Nv8GByf'a8b2	!L@	0/:X/t#!խA3!}j}4pi$!-ƾ]jEjL'ʼ|Y}n^L.(0[ǄcOUnUC_W$^?UQ=5ѺRCj(6k}Kh(R Z=o]oq0y9h6{#;@³5<a[wq׮%U|<42T!CʵIpJ{`N|L9)t6w{W߽~P04s.&dw8= Y|\270-ŋA[龅BAor+<	'H%܂
+kV\FI(ڈezeAn!_f(n !>ؖT[k0$JJJby@p,j
+yһJXm};GaQ"->
+oNKCU=LX(y4NuN-` EX9HB)#]Avfٛ!UBs62j]B~:x5dxZwoizo+yw=E٬i
+yWNw+΃\?Dn">$Lai?'#amL97X=AolA2趮 c J ^^h]̐_җ%2iHCLq <	NߎABbs,Ff B5Z(\J/ _]L2be^ V9X_M;~ZBj-P/<x]2]!<YX>Q;:PȤ1~|z?햭w'aB;oj?6pCb˷DmNqy;%Ƚ9{|έt'}=F`e۶h"M-[𻈷t]I1j{^o
+O	rD#[*{?Ŕ6ntŝ%GOpkD R]tpJbvT*nݢ}m۞y<(ME9Wx5]m<Uxʿ[5Mv)d3i,|KƈW|6){K-q7)C@ibTz3sƈs ?r~{m.W*71}x<ܝ-sLqqߖ`iģw!e1˖pږ`5z!ɧ\~ZF͎	 >eT\3%1
+Ȳ+t	J;,!pJwCҽ-1XSr%bS{%Cx("DA%С@#C@ᄀi`j<獍ufD)' XX:0)1;*#hsw\$<p1@eg$
+܈௿]RVL~UqSJ׌ sAw7CsTW/99F*u}-l0'k,g|y,ҫxK    IENDB`
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX120.png ./IPTVPlayer/icons/PlayerSelector/XXX120.png
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX120.png	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/icons/PlayerSelector/XXX120.png	2015-11-24 20:13:20.673688999 +0100
@@ -0,0 +1,25 @@
+PNG
+
+   IHDR   x   x      PLTE<><¼DĂtĲdB|$"$,F\^\<
+*4f|J\,MNLĶĤv"Ԝ:L$4*D424$",b
+̘$ܪVVTftBD|Rd",qnlԶԴ,*,4ܽ<*dr,T܎
+4V2ֲHFDͶvT:d
+ԌoJljl\4<jTV\$L(&,\^d4dN\ܱ,
+<:<$,
+<LԊԄ$Nz|LNTĺ~*446<<*\Z|JTn^:ܬnT:t|vtD2d<&\PZ~,|N\24Ѳ<DBD̂lFf|FLtrt4.4n4"\DFLL6l,4dZ\4<.ԬL2l$$l<D|lF|(&$ļz,
+764fڮԜ2.,D.d̺"ZZ\dbd4$$<}~|TRTLJLJ줦&jZ6zR4
+윞rb>̆4D><Dd^\,y   tRNS 
+<   	pHYs       1IDATxŚWǬg5KRYw.*fie7Ѳ-u[ZХ"QW튵=֟mVF&d=V(VTO2ovឳIޛͽ{߼A8"k)_.7piY#nf2y,PKygD3+3NxɘekcL cxS]@&was8.\1^Y.΃Xl`c?+t3tf9bkp&^bR*bE
+~/DP ?U>qH=|%89BšR9N&}bD_'_/!dޔ(&| Vqs%NA(`n"(k  LVp}[
+Vs@D#fqy59u0XL8b-d3=d`VSs!THk.c0`sUYāZ3~,y'>P3
+,?>S(̫6 	jB3'CFA蛢T4ςHTGwm%ꐽn{'eOIb2[phj|\ ܘLҳ69<.BSj)httӄW1ױv;rκ9w4.zt)Ϸ#z	-!Px^Mv@BI/zjߟcd[B"*7dl𤩂`Y 5*gcx4!s$\Q 6r_:=d\E >l;b/_/|{N>93Is_zה$Y 򣣣]S-dy3/Ųhi7 wTyn߳WtY 4*I˿&`$$Bԑ+)m{75,IMw^ʺ2ri1ՉTpAɎ.H]Є#؁]nUF4݈T
+,KƢɃNnQ"Um}?]eWTgᣗr.ǭk̉
+*3!Gƽa-|ARïg@6"JR<<-iw!<%%IR|5gFT^lB#M%"/`3kyZb}iq
+Kʺl&A]4ȿUdNMGҁ4IjV`Hb£*xU2IiTUBt37{YyVȋFJMa$5Eq"$,^i:xaRiX*t^DƸAkj)NLh|˳j#oqߩ)N<jXo(Ty*8܃*T{'[dnIkb'o.ar;	akHqR\szfR9P8{856Hon7ƳI]8iw7Ռ}"UP%Yz9F1cp8M-QoK&W!ֲ)?2n6 }"HP:krJAqNƷ*."->]WO>'PXzypNC3$/py2n{h\%xia},4w9hأ_xNbNv8wjR߻U/:Ĕ/02^F_Me:j~RIjm_e&Rg	Njrx{{rɰ_~%Q
+bD%QYڨgF/+̹{izuە},I{;rݦw[{4Z83(=Ў6B
+o8t[{LbYo?Ii*1.-{hϘa/$STjZ u߄#Q
+N+=Kx½׫l_#pk>[3	MgɎ`2.d'2R$رjAhFfo4E؊<
+"q*>,9S^c"bALE`zB0Dgi=u ?s`r\r6W3nG&lgsE7H^GCpi2b437,A=sᠲ8e=gI{;폘e
+h_
+78Ni\pzstndժ<7Ӽʍe\.2M3uwI
+ԝlH&+d3ֆV&o5\GsywȷqmThsrВ+#|:vY5cc]|p3ibBlYdٛ 7d`L&`F5diin\S0T&R	``TF8c6AUTl-3^+	[Q>~'皐rޕ`X5:dkN rĎ!paGx`{Z0T4`?hÅka|)wX-*]ImpN:KOpa`M4Xb۔eWkNހmUfZcP3U(DDV*ˊ4J^}_Y'YR>[;p[W ɹ7xy20B<h    IENDB`
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX135.png ./IPTVPlayer/icons/PlayerSelector/XXX135.png
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/icons/PlayerSelector/XXX135.png	1970-01-01 01:00:00.000000000 +0100
+++ ./IPTVPlayer/icons/PlayerSelector/XXX135.png	2015-11-24 20:13:20.673688999 +0100
@@ -0,0 +1,24 @@
+PNG
+
+   IHDR         98   PLTE<><¼DĂtĲdB|$"$,F\^\<
+*4f|J\,MNLĶĤv"Ԝ:L$4*D424$",b
+̘$ܪVVTftBD|Rd",qnlԶԴ,*,4ܽ<*dr,T܎
+4V2ֲHFDͶvT:d
+ԌoJljl\4<jTV\$L(&,\^d4dN\ܱ,
+<:<$,
+<LԊԄ$Nz|LNTĺ~*446<<*\Z|JTn^:ܬnT:t|vtD2d<&\PZ~,|N\24Ѳ<DBD̂lFf|FLtrt4.4n4"\DFLL6l,4dZ\4<.ԬL2l$$l<D|lF|(&$ļz,
+764fڮԜ2.,D.d̺"ZZ\dbd4$$<}~|TRTLJLJ줦&jZ6zR4
+윞rb>̆4D><Dd^\,y   tRNS 
+<   	pHYs       NIDATx͛|UcMմy2bQ\eQVnF`Xil	SJSDd4v"lm$)Mڂ
+D@{ݻKrw~~V(随8,GW5jU͟_{{:9άbR9<;]õAS1ٵUH4HcA+v ՚HD,GlMJ]ޔ߬&3;~<rĄ4^NA|TIC^^Lf#0K.9 LIDpBz%78'DIx@<0e`
+Ƭ5\&Ra'0Ș&tU
+BET (M[!5Aa 䀂Nta~R8R P	@#4#B9\ d`Pኂ, &$^˧$z{k`Un)	+3PszJ2`5:gJ)2^m
+='SC0<?3 ~<:J~dwPg	HgW/!zz)_'Lv6 ub`,ڹbCpUq4B#sTYN}]1I<b9M=/
+Ի(a`!gV y76DH̝WGUTcv'AsgrF@=#9a4fB6x"7:qwFCތU>(mmS:4P-^oDzOJv{ц:潗z^Az+lÑ9er#D~#A9F
+OlfW{䤨~_<`bgiy\|I͙G=dȈh1htEwq;00]P:ާe[!G+f8f5hΈ˗/_
+i$T$i8_T%`MRqω'oQ#3gQ2)(2\GyvuX6uMO^ $py-g}?GBAk8=ɞQP$g׵û410ҟn
+eÝ`-ec'`~;Q;<4QwBk/'氝cxnixXN':4%;Z!\K;ŢΑ-.1Q*wQ>R&~N/N8H0hsXpPi"NY(oǒ.JKl9xJ:^&Y^= ͯ4hU֎]je!E|ԳTiFObX$*/$}_U E|ʯH  4rtυQSTaǺDdaa}a*&$ꗼ!4<|gd2]\gYDǡD_$gGJj.ڊ#$16|UgŃt8"zI@0ܿX`SEGd#l$<ԁ㙢c"Hk틒^y4(%iF>i4,?q]xO<]&>g4GkXcndڙYZlS8k8Pv/M>Εg>q\zōZX{&_ԥu󵭘#L~TzS%Y=KZJjzHʌVC5'/i8DLZ
+RX8`ZzN	v/js䐷Z-/6+,p)G$ڌ9vJ]>h[_s9Z%KҲ-jG%˭1Ǯ*9nE-^rB# QmSMR=1>PfY/9z,Gj(,Ƈm2#bx;\64(jlpbX^apPVr\Gr܀1cF G؇˻<:!Gq*9RJ4!7mdC!N/R#Bӊgrl"ld;p˲]څ-ceL>uºx}jd׮*8 qc&%Tߴ6e^>Du
+v1mb+5l/]r4gͩkRӈ|-;\6}*'~Ay/28*\YmvF%ejӽZnR#&]F/%/}Q劧"0X<tK}@11tۄ6\Bĭ8tlT*5i,h[[4	ꬽ4O#Jy΀IMNNJ6ދ 97g>pN{=)[3ʥo3!%雃<"N-v œY4?f8>>D?}xS #FsfW+XVgz?+V,yQh(`| :=8GC1n-H~$g')=]&-vAh\dO50ӝ{6VZ]f/NL՚k&7	F~PCJiLs"ٙrgT28$Q!'evKf>!b<ʃ]FuQL#URY̌3"dVIkB+oWbh6V9 JY$V8il.FL&k_Pf׭dS݁wϩn!rmr\dOs0K5LA\?&Wpxs#2j(Nwt83&î/?v&uPsAb9KR0s35^1>樹ALߨKSR31Okkk0Ǫb񶥵[WV"),P3/1c,eZaN8APe_`+X11>Ub#}xGc'&1
+S\qqAebN*S|Bs7Df$A0QP0N#5!AKm$CM0aC3bj~	y>	Qee	/ւ>?pX|PnTѪ!ʱGwAy  ꊦ辧'	5u]JLߤ]=Kx
+{8pxJ7<\|U#ay9L*&    IENDB`
\ No newline at end of file
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/iptvdm/iptvdmui.py ./IPTVPlayer/iptvdm/iptvdmui.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/iptvdm/iptvdmui.py	2015-11-11 07:16:27.435260000 +0100
+++ ./IPTVPlayer/iptvdm/iptvdmui.py	2015-11-25 06:44:14.518646000 +0100
@@ -30,7 +30,7 @@
 from Components.Sources.StaticText import StaticText
 from Components.config import config
 
-from os import chmod as os_chmod, path as os_path, remove as os_remove
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
 ###################################################
 
 #########################################################
@@ -40,30 +40,8 @@
 
 class IPTVDMWidget(Screen):
 
-    sz_w = getDesktop(0).size().width() - 190
-    sz_h = getDesktop(0).size().height() - 195
-    if sz_h < 500:
-        sz_h += 4
-    skin = """
-        <screen name="IPTVDMWidget" position="center,center" title="IPTV Player download manager" size="%d,%d">
-         <ePixmap position="5,9"   zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         <ePixmap position="180,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         <ePixmap position="385,9" zPosition="4" size="30,30" pixmap="%s" transparent="1" alphatest="on" />
-         <ePixmap position="590,9" zPosition="4" size="35,30" pixmap="%s" transparent="1" alphatest="on" />
-         <widget render="Label" source="key_red"    position="45,9"  size="140,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-         <widget render="Label" source="key_yellow" position="225,9" size="300,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />            
-         <widget render="Label" source="key_green"  position="425,9" size="300,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />            
-         <widget render="Label" source="key_blue"   position="635,9" size="300,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />            
-         <widget name="list" position="5,100" zPosition="2" size="%d,%d" scrollbarMode="showOnDemand" transparent="0"  backgroundColor="#00000000" />
-         <widget name="titel" position="5,47" zPosition="1" size="%d,23" font="Regular;20" transparent="1"  backgroundColor="#00000000"/>
-        </screen>""" %(
-            sz_w, sz_h, # size
-            GetIconDir('red.png'), GetIconDir('yellow.png'), GetIconDir('green.png'), GetIconDir('blue.png'),
-            sz_w - 10, sz_h - 20, # size list
-            sz_w - 135, # size titel
-            )
-        # <widget render="Label" source="key_yellow" position="220,9" size="180,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" />
-        # <widget render="Label" source="key_blue" position="630,9" size="140,27" zPosition="5" valign="center" halign="left" backgroundColor="black" font="Regular;21" transparent="1" foregroundColor="white" shadowColor="black" shadowOffset="-1,-1" /> 
+    skin = LoadSkin("IPTVDMWidget")
+
     def __init__(self, session, downloadmanager):
         self.session = session
         Screen.__init__(self, session)
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/iptvupdate/updatemainwindow.py ./IPTVPlayer/iptvupdate/updatemainwindow.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/iptvupdate/updatemainwindow.py	2015-11-11 07:16:45.118414000 +0100
+++ ./IPTVPlayer/iptvupdate/updatemainwindow.py	2015-11-25 06:44:14.522644000 +0100
@@ -19,7 +19,7 @@
 from Plugins.Extensions.IPTVPlayer.libs.pCommon             import common
 from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
 ###################################################
-
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
 ###################################################
 # FOREIGN import
 ###################################################
@@ -35,7 +35,6 @@
 try:    import json
 except: import simplejson as json
 
-from os import path as os_path, remove as os_remove, listdir as os_listdir
 ###################################################
 
 
@@ -88,6 +87,7 @@
         self["list"].setList([])
 
     def layoutFinished(self):
+        self.close()
         self.setTitle( self.updateObjImpl.getTitle() )
         self["sub_title"].setText( self.updateObjImpl.getSubTitle() )
         self["list"].setSelectionState(enabled = False)
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/plugin.py ./IPTVPlayer/plugin.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/plugin.py	2015-11-17 06:34:21.247824000 +0100
+++ ./IPTVPlayer/plugin.py	2015-11-25 06:44:14.522644000 +0100
@@ -73,7 +73,9 @@
     #print config.plugins.iptvplayer.rtmpdumppath.value
     #print config.plugins.iptvplayer.f4mdumppath.value
     platform     = config.plugins.iptvplayer.plarform.value
-    if platform in ["auto", "unknown"] or not wgetpath or not rtmpdumppath or not f4mdumppath:
+    if platform in ["unknown"]:
+        doRunMain(session)
+    elif platform in ["auto"] or not wgetpath or not rtmpdumppath or not f4mdumppath:
         session.openWithCallback(boundFunction(doRunMain, session), IPTVSetupMainWidget)
     elif IPTVPlayerNeedInit():
         session.openWithCallback(boundFunction(doRunMain, session), IPTVSetupMainWidget, True)
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/setup/iptvsetupimpl.py ./IPTVPlayer/setup/iptvsetupimpl.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/setup/iptvsetupimpl.py	2015-11-25 06:44:10.544634000 +0100
+++ ./IPTVPlayer/setup/iptvsetupimpl.py	2015-11-25 06:44:14.522644000 +0100
@@ -7,7 +7,7 @@
 from Plugins.Extensions.IPTVPlayer.setup.iptvsetuphelper     import CBinaryStepHelper, CCmdValidator, SetupDownloaderCmdCreator
 from Plugins.Extensions.IPTVPlayer.components.iptvplayerinit import TranslateTXT as _
 ###################################################
-
+j00zekFork=True
 ###################################################
 # FOREIGN import
 ###################################################
@@ -33,12 +33,12 @@
         self.termination  = False
         
         self.tmpDir = GetTmpDir()
-        self.resourceServers = ["http://iptvplayer.pl/resources/", "http://iptvplayer.vline.pl/resources/"]
+        self.resourceServers = ["http://iptvplayer.pl/resources/", "http://iptvplayer.vline.pl/resources/", "http://hybrid.xunil.pl/IPTVPlayer_resources/"]
         
         self.ffmpegVersion = ""
         self.gstreamerVersion = ""
         self.openSSLVersion = ""
-        self.supportedPlatforms = ["sh4", "mipsel", "i686"]
+        self.supportedPlatforms = ["sh4", "mipsel", "i686", "arm"]
         self.platform = "unknown"
         
         # wget members
@@ -63,7 +63,7 @@
                                           (_("Do not install (not recommended)"), "")]
                                           
         # uchardet member
-        self.uchardetVersion = "Version 0.0.2"
+        self.uchardetVersion = 2
         self.uchardetpaths = ["/usr/bin/uchardet", GetBinDir("uchardet", "")]
         self._uchardetInstallChoiseList = [(_('Install into the "%s".') % ("/usr/bin/uchardet (%s)" % _("recommended")), "/usr/bin/uchardet"),
                                           (_('Install into the "%s".') % "IPTVPlayer/bin/uchardet", GetBinDir("uchardet", "")),
@@ -137,6 +137,18 @@
     def platformDetect(self):
         printDBG("IPTVSetupImpl.platformDetect")
         self.setInfo(_("Detection of the platform."), _("Plugin can be run on one of the following platforms: sh4, mipsel, i686."))
+        if 'j00zekFork' in globals():
+            from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import getPlatform
+            platform = getPlatform()
+            if platform != 'unknown':
+                print "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" + platform
+                self.platform = platform
+                config.plugins.iptvplayer.plarform.value = self.platform
+                printDBG("IPTVSetupImpl.j00zekFork platform[%s]" % self.platform)
+                config.plugins.iptvplayer.plarform.save()
+                configfile.save()
+                self.setOpenSSLVersion()
+                return
         cmdTabs = []
         for platform in self.supportedPlatforms:
             platformtesterPath = resolveFilename(SCOPE_PLUGINS, "Extensions/IPTVPlayer/bin/%s/platformtester" % platform)
@@ -287,7 +299,7 @@
     def rtmpdumpStep(self, ret=None):
         printDBG("IPTVSetupImpl.rtmpdumpStep")
         def _detectValidator(code, data):
-            if self.rtmpdumpVersion in data: return True,False
+            if self.rtmpdumpVersion in data or 'K-S-V patch' in data: return True,False
             else: return False,True
         def _deprecatedHandler(paths, stsTab, dataTab):
             sts, retPath = False, ""
@@ -329,7 +341,9 @@
         def _detectValidator(code, data):
             if self.binaryInstalledSuccessfully: self.stepHelper.setInstallChoiseList( self._uchardetInstallChoiseList2 )
             else: self.stepHelper.setInstallChoiseList( self._uchardetInstallChoiseList )
-            if self.uchardetVersion in data: return True,False
+            try: ver = int(re.search("Version ([0-9]+?\.[0-9]+?\.[0-9]+?)", data).group(1).replace('.',''))
+            except: ver = 0
+            if ver >= self.uchardetVersion: return True,False
             else: return False,True
         def _deprecatedHandler(paths, stsTab, dataTab):
             sts, retPath = False, ""
@@ -620,6 +634,7 @@
         for server in self.resourceServers:
             cmd = self.stepHelper.getDownloadCmdBuilder()(self.stepHelper.getName(), self.platform, self.openSSLVersion, server, self.tmpDir)
             cmdTabs.append(cmd)
+        print cmdTabs
         self.workingObj = CCmdValidator(self.binaryDownloadFinished, self.stepHelper.getDownloadValidator(), cmdTabs)
         self.workingObj.start()
     
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/setup/iptvsetupwidget.py ./IPTVPlayer/setup/iptvsetupwidget.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/setup/iptvsetupwidget.py	2015-11-05 22:26:57.957660252 +0100
+++ ./IPTVPlayer/setup/iptvsetupwidget.py	2015-11-25 06:44:14.522644000 +0100
@@ -12,7 +12,7 @@
 from Plugins.Extensions.IPTVPlayer.components.cover          import Cover3
 from Plugins.Extensions.IPTVPlayer.setup.iptvsetupimpl       import IPTVSetupImpl
 ###################################################
-
+from Plugins.Extensions.IPTVPlayer.j00zekScripts.j00zekToolSet import *
 ###################################################
 # FOREIGN import
 ###################################################
@@ -28,17 +28,7 @@
 
 class IPTVSetupMainWidget(Screen):
     IPTV_VERSION = GetIPTVPlayerVerstion()
-    skin = """
-    <screen name="IPTVPlayerWidget" position="center,center" size="600,300" title="IPTVPlayer setup version %s">
-            <widget name="sub_title"    position="10,10" zPosition="2" size="580,90"   valign="center" halign="center" font="Regular;24" transparent="1" foregroundColor="white" />
-            <widget name="info_field"   position="10,100" zPosition="2" size="580,200" valign="top" halign="center"   font="Regular;22" transparent="1" foregroundColor="white" />
-            
-            <widget name="spinner"   zPosition="2" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-            <widget name="spinner_1" zPosition="1" position="463,200" size="16,16" transparent="1" alphatest="blend" />
-            <widget name="spinner_2" zPosition="1" position="479,200" size="16,16" transparent="1" alphatest="blend" />
-            <widget name="spinner_3" zPosition="1" position="495,200" size="16,16" transparent="1" alphatest="blend" />
-            <widget name="spinner_4" zPosition="1" position="511,200" size="16,16" transparent="1" alphatest="blend" />
-    </screen>""" %( IPTV_VERSION)
+    skin = LoadSkin('IPTVSetupMainWidget')
 
     def __init__(self, session, autoStart=False):
         printDBG("IPTVUpdateMainWindow.__init__ -------------------------------")
diff -Naur -X ./exclude.pats /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/tools/iptvtools.py ./IPTVPlayer/tools/iptvtools.py
--- /home/j00zek/iptvplayer-GitLab-master-version/IPTVPlayer/tools/iptvtools.py	2015-11-17 06:34:21.247824000 +0100
+++ ./IPTVPlayer/tools/iptvtools.py	2015-11-25 15:36:48.278458999 +0100
@@ -372,9 +372,9 @@
 #####################################################
 # get host list based on files in /hosts folder
 #####################################################
-def GetHostsList():
+def GetHostsList( subfolder = '' ):
     printDBG('getHostsList begin')
-    HOST_PATH = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/hosts/')
+    HOST_PATH = resolveFilename(SCOPE_PLUGINS, 'Extensions/IPTVPlayer/hosts/%s' % subfolder)
     lhosts = [] 
     
     try:
